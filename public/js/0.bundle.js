webpackJsonp([0],{

/***/ 475:
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\nvar _ = (function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n  return _;\n}).call({});\n/**\n * Core Emmet object, available in global scope\n */\nvar emmet = (function(global) {\n\tvar defaultSyntax = 'html';\n\tvar defaultProfile = 'plain';\n\t\n\tif (typeof _ == 'undefined') {\n\t\ttry {\n\t\t\t// avoid collisions with RequireJS loader\n\t\t\t// also, JS obfuscators tends to translate\n\t\t\t// a[\"name\"] to a.name, which also breaks RequireJS\n\t\t\t_ = global[['require'][0]]('underscore'); // node.js\n\t\t} catch (e) {}\n\t}\n\n\tif (typeof _ == 'undefined') {\n\t\tthrow 'Cannot access to Underscore.js lib';\n\t}\n\n\t/** List of registered modules */\n\tvar modules = {\n\t\t_ : _\n\t};\n\t\n\t/**\n\t * Shared empty constructor function to aid in prototype-chain creation.\n\t */\n\tvar ctor = function(){};\n\t\n\t/**\n\t * Helper function to correctly set up the prototype chain, for subclasses.\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t * class properties to be extended.\n\t * Took it from Backbone.\n\t * @param {Object} parent\n\t * @param {Object} protoProps\n\t * @param {Object} staticProps\n\t * @returns {Object}\n\t */\n\tfunction inherits(parent, protoProps, staticProps) {\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() {\n\t\t\t\tparent.apply(this, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\t_.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps)\n\t\t\t_.extend(child.prototype, protoProps);\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps)\n\t\t\t_.extend(child, staticProps);\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\t\n\t/**\n\t * @type Function Function that loads module definition if it's not defined\n\t */\n\tvar moduleLoader = null;\n\t\n\t/**\n\t * Generic Emmet module loader (actually, it doesn’t load anything, just \n\t * returns module reference). Not using `require` name to avoid conflicts\n\t * with Node.js and RequireJS\n\t */\n\tfunction r(name) {\n\t\tif (!(name in modules) && moduleLoader)\n\t\t\tmoduleLoader(name);\n\t\t\n\t\treturn modules[name];\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Simple, AMD-like module definition. The module will be added into\n\t\t * <code>emmet</code> object and will be available via\n\t\t * <code>emmet.require(name)</code> or <code>emmet[name]</code>\n\t\t * @param {String} name\n\t\t * @param {Function} factory\n\t\t * @memberOf emmet\n\t\t */\n\t\tdefine: function(name, factory) {\n\t\t\t// do not let redefine existing properties\n\t\t\tif (!(name in modules)) {\n\t\t\t\tmodules[name] = _.isFunction(factory) \n\t\t\t\t\t? this.exec(factory)\n\t\t\t\t\t: factory;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to Emmet module\n\t\t * @param {String} name Module name\n\t\t */\n\t\trequire: r,\n\t\t\n\t\t/**\n\t\t * Helper method that just executes passed function but with all \n\t\t * important arguments like 'require' and '_'\n\t\t * @param {Function} fn\n\t\t * @param {Object} context Execution context\n\t\t */\n\t\texec: function(fn, context) {\n\t\t\treturn fn.call(context || global, _.bind(r, this), _, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * The self-propagating extend function for classes.\n\t\t * Took it from Backbone \n\t\t * @param {Object} protoProps\n\t\t * @param {Object} classProps\n\t\t * @returns {Object}\n\t\t */\n\t\textend: function(protoProps, classProps) {\n\t\t\tvar child = inherits(this, protoProps, classProps);\n\t\t\tchild.extend = this.extend;\n\t\t\t// a hack required to WSH inherit `toString` method\n\t\t\tif (protoProps.hasOwnProperty('toString'))\n\t\t\t\tchild.prototype.toString = protoProps.toString;\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * The essential function that expands Emmet abbreviation\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {String} syntax Abbreviation's context syntax\n\t\t * @param {String} profile Output profile (or its name)\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\n\t\t * written\n\t\t * @return {String}\n\t\t */\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\n\t\t\tif (!abbr) return '';\n\t\t\t\n\t\t\tsyntax = syntax || defaultSyntax;\n//\t\t\tprofile = profile || defaultProfile;\n\t\t\t\n\t\t\tvar filters = r('filters');\n\t\t\tvar parser = r('abbreviationParser');\n\t\t\t\n\t\t\tprofile = r('profile').get(profile, syntax);\n\t\t\tr('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar outputTree = parser.parse(data[0], {\n\t\t\t\tsyntax: syntax, \n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\t\n\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, profile);\n\t\t\treturn outputTree.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default syntax name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultSyntax: function() {\n\t\t\treturn defaultSyntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default profile name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultProfile: function() {\n\t\t\treturn defaultProfile;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Log message into console if it exists\n\t\t */\n\t\tlog: function() {\n\t\t\tif (global.console && global.console.log)\n\t\t\t\tglobal.console.log.apply(global.console, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Setups function that should synchronously load undefined modules\n\t\t * @param {Function} fn\n\t\t */\n\t\tsetModuleLoader: function(fn) {\n\t\t\tmoduleLoader = fn;\n\t\t}\n\t};\n})(this);\n\n// export core for Node.JS\nif (true) {\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\texports = module.exports = emmet;\n\t}\n\texports.emmet = emmet;\n}\n\n// export as Require.js module\nif (true) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (emmet),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}/**\n * Emmet abbreviation parser.\n * Takes string abbreviation and recursively parses it into a tree. The parsed \n * tree can be transformed into a string representation with \n * <code>toString()</code> method. Note that string representation is defined\n * by custom processors (called <i>filters</i>), not by abbreviation parser \n * itself.\n * \n * This module can be extended with custom pre-/post-processors to shape-up\n * final tree or its representation. Actually, many features of abbreviation \n * engine are defined in other modules as tree processors\n * \n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @memberOf __abbreviationParser\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationParser', function(require, _) {\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\n\tvar reWord = /[\\w\\-:\\$@]/;\n\t\n\tvar pairs = {\n\t\t'[': ']',\n\t\t'(': ')',\n\t\t'{': '}'\n\t};\n\t\n\tvar spliceFn = Array.prototype.splice;\n\t\n\tvar preprocessors = [];\n\tvar postprocessors = [];\n\tvar outputProcessors = [];\n\t\n\t/**\n\t * @type AbbreviationNode\n\t */\n\tfunction AbbreviationNode(parent) {\n\t\t/** @type AbbreviationNode */\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\tthis._attributes = [];\n\t\t\n\t\t/** @type String Raw abbreviation for current node */\n\t\tthis.abbreviation = '';\n\t\tthis.counter = 1;\n\t\tthis._name = null;\n\t\tthis._text = '';\n\t\tthis.repeatCount = 1;\n\t\tthis.hasImplicitRepeat = false;\n\t\t\n\t\t/** Custom data dictionary */\n\t\tthis._data = {};\n\t\t\n\t\t// output properties\n\t\tthis.start = '';\n\t\tthis.end = '';\n\t\tthis.content = '';\n\t\tthis.padding = '';\n\t}\n\t\n\tAbbreviationNode.prototype = {\n\t\t/**\n\t\t * Adds passed node as child or creates new child\n\t\t * @param {AbbreviationNode} child\n\t\t * @param {Number} position Index in children array where child should \n\t\t * be inserted\n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\taddChild: function(child, position) {\n\t\t\tchild = child || new AbbreviationNode;\n\t\t\tchild.parent = this;\n\t\t\t\n\t\t\tif (_.isUndefined(position)) {\n\t\t\t\tthis.children.push(child);\n\t\t\t} else {\n\t\t\t\tthis.children.splice(position, 0, child);\n\t\t\t}\n\t\t\t\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a deep copy of current node\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tclone: function() {\n\t\t\tvar node = new AbbreviationNode();\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\n\t\t\t_.each(attrs, function(a) {\n\t\t\t\tnode[a] = this[a];\n\t\t\t}, this);\n\t\t\t\n\t\t\t// clone attributes\n\t\t\tnode._attributes = _.map(this._attributes, function(attr) {\n\t\t\t\treturn _.clone(attr);\n\t\t\t});\n\t\t\t\n\t\t\tnode._data = _.clone(this._data);\n\t\t\t\n\t\t\t// clone children\n\t\t\tnode.children = _.map(this.children, function(child) {\n\t\t\t\tchild = child.clone();\n\t\t\t\tchild.parent = node;\n\t\t\t\treturn child;\n\t\t\t});\n\t\t\t\n\t\t\treturn node;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes current node from parent‘s child list\n\t\t * @returns {AbbreviationNode} Current node itself\n\t\t */\n\t\tremove: function() {\n\t\t\tif (this.parent) {\n\t\t\t\tthis.parent.children = _.without(this.parent.children, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces current node in parent‘s children list with passed nodes\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\n\t\t */\n\t\treplace: function() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar ix = _.indexOf(parent.children, this);\n\t\t\tvar items = _.flatten(arguments);\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\n\t\t\t\n\t\t\t// update parent\n\t\t\t_.each(items, function(item) {\n\t\t\t\titem.parent = parent;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\n\t\t * node and its children \n\t\t * @param {String} name Property to update\n\t\t * @param {Object} value New property value\n\t\t */\n\t\tupdateProperty: function(name, value) {\n\t\t\tthis[name] = value;\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tchild.updateProperty(name, value);\n\t\t\t});\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds first child node that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tfind: function(fn) {\n\t\t\treturn this.findAll(fn)[0];\n//\t\t\tif (!_.isFunction(fn)) {\n//\t\t\t\tvar elemName = fn.toLowerCase();\n//\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n//\t\t\t}\n//\t\t\t\n//\t\t\tvar result = null;\n//\t\t\t_.find(this.children, function(child) {\n//\t\t\t\tif (fn(child)) {\n//\t\t\t\t\treturn result = child;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\treturn result = child.find(fn);\n//\t\t\t});\n//\t\t\t\n//\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds all child nodes that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {Array}\n\t\t */\n\t\tfindAll: function(fn) {\n\t\t\tif (!_.isFunction(fn)) {\n\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n\t\t\t}\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tif (fn(child))\n\t\t\t\t\tresult.push(child);\n\t\t\t\t\n\t\t\t\tresult = result.concat(child.findAll(fn));\n\t\t\t});\n\t\t\t\n\t\t\treturn _.compact(result);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets/gets custom data\n\t\t * @param {String} name\n\t\t * @param {Object} value\n\t\t * @returns {Object}\n\t\t */\n\t\tdata: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tthis._data[name] = value;\n\t\t\t\t\n\t\t\t\tif (name == 'resource' && require('elements').is(value, 'snippet')) {\n\t\t\t\t\t// setting snippet as matched resource: update `content`\n\t\t\t\t\t// property with snippet value\n\t\t\t\t\tthis.content = value.data;\n\t\t\t\t\tif (this._text) {\n\t\t\t\t\t\tthis.content = require('abbreviationUtils')\n\t\t\t\t\t\t\t.insertChildContent(value.data, this._text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this._data[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name of current node\n\t\t * @returns {String}\n\t\t */\n\t\tname: function() {\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element')) {\n\t\t\t\treturn res.name;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of attributes for current node\n\t\t * @returns {Array}\n\t\t */\n\t\tattributeList: function() {\n\t\t\tvar attrs = [];\n\t\t\t\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element') && _.isArray(res.attributes)) {\n\t\t\t\tattrs = attrs.concat(res.attributes);\n\t\t\t}\n\t\t\t\n\t\t\treturn optimizeAttributes(attrs.concat(this._attributes));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or sets attribute value\n\t\t * @param {String} name Attribute name\n\t\t * @param {String} value New attribute value\n\t\t * @returns {String}\n\t\t */\n\t\tattribute: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (_.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to the matched <code>element</code>, if any.\n\t\t * See {@link elements} module for a list of available elements\n\t\t * @returns {Object}\n\t\t */\n\t\tmatchedResource: function() {\n\t\t\treturn this.data('resource');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of current node in parent‘s children list\n\t\t * @returns {Number}\n\t\t */\n\t\tindex: function() {\n\t\t\treturn this.parent ? _.indexOf(this.parent.children, this) : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets how many times current element should be repeated\n\t\t * @private\n\t\t */\n\t\t_setRepeat: function(count) {\n\t\t\tif (count) {\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\n\t\t\t} else {\n\t\t\t\tthis.hasImplicitRepeat = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets abbreviation that belongs to current node\n\t\t * @param {String} abbr\n\t\t */\n\t\tsetAbbreviation: function(abbr) {\n\t\t\tabbr = abbr || '';\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\t// find multiplier\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\n\t\t\t\tthat._setRepeat(repeatCount);\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\tthis.abbreviation = abbr;\n\t\t\t\n\t\t\tvar abbrText = extractText(abbr);\n\t\t\tif (abbrText) {\n\t\t\t\tabbr = abbrText.element;\n\t\t\t\tthis.content = this._text = abbrText.text;\n\t\t\t}\n\t\t\t\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\n\t\t\tif (abbrAttrs) {\n\t\t\t\tabbr = abbrAttrs.element;\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\n\t\t\t}\n\t\t\t\n\t\t\tthis._name = abbr;\n\t\t\t\n\t\t\t// validate name\n\t\t\tif (this._name && !reValidName.test(this._name)) {\n\t\t\t\tthrow 'Invalid abbreviation';\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of current node\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar start = this.start;\n\t\t\tvar end = this.end;\n\t\t\tvar content = this.content;\n\t\t\t\n\t\t\t// apply output processors\n\t\t\tvar node = this;\n\t\t\t_.each(outputProcessors, function(fn) {\n\t\t\t\tstart = fn(start, node, 'start');\n\t\t\t\tcontent = fn(content, node, 'content');\n\t\t\t\tend = fn(end, node, 'end');\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tvar innerContent = _.map(this.children, function(child) {\n\t\t\t\treturn child.toString();\n\t\t\t}).join('');\n\t\t\t\n\t\t\tcontent = require('abbreviationUtils').insertChildContent(content, innerContent, {\n\t\t\t\tkeepVariable: false\n\t\t\t});\n\t\t\t\n\t\t\treturn start + utils.padString(content, this.padding) + end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node contains children with empty <code>expr</code>\n\t\t * property\n\t\t * @return {Boolean}\n\t\t */\n\t\thasEmptyChildren: function() {\n\t\t\treturn !!_.find(this.children, function(child) {\n\t\t\t\treturn child.isEmpty();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node has implied name that should be resolved\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasImplicitName: function() {\n\t\t\treturn !this._name && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current element is a grouping one, e.g. has no \n\t\t * representation but serves as a container for other nodes\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisGroup: function() {\n\t\t\treturn !this.abbreviation;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \n\t\t * grouping node and should not be outputted\n\t\t * @return {Boolean}\n\t\t */\n\t\tisEmpty: function() {\n\t\t\treturn !this.abbreviation && !this.children.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current node should be repeated\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisRepeating: function() {\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node is a text-only node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTextNode: function() {\n\t\t\treturn !this.name() && !this.attributeList().length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates whether this node may be used to build elements or snippets\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisElement: function() {\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns latest and deepest child of current tree\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tdeepestChild: function() {\n\t\t\tif (!this.children.length)\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = _.last(deepestChild.children);\n\t\t\t}\n\t\t\t\n\t\t\treturn deepestChild;\n\t\t}\n\t};\n\t\n\t/**\n\t * Returns stripped string: a string without first and last character.\n\t * Used for “unquoting” strings\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction stripped(str) {\n\t\treturn str.substring(1, str.length - 1);\n\t}\n\t\n\tfunction consumeQuotedValue(stream, quote) {\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch === quote)\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (ch == '\\\\')\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Parses abbreviation into a tree\n\t * @param {String} abbr\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction parseAbbreviation(abbr) {\n\t\tabbr = require('utils').trim(abbr);\n\t\t\n\t\tvar root = new AbbreviationNode;\n\t\tvar context = root.addChild(), ch;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\tvar loopProtector = 1000, multiplier;\n\t\t\n\t\twhile (!stream.eol() && --loopProtector > 0) {\n\t\t\tch = stream.peek();\n\t\t\t\n\t\t\tswitch (ch) {\n\t\t\t\tcase '(': // abbreviation group\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\n\t\t\t\t\t\tif (multiplier = stream.match(/^\\*(\\d+)?/, true)) {\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t_.each(inner.children, function(child) {\n\t\t\t\t\t\t\tcontext.addChild(child);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '>': // child operator\n\t\t\t\t\tcontext = context.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '+': // sibling operator\n\t\t\t\t\tcontext = context.parent.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '^': // climb up operator\n\t\t\t\t\tvar parent = context.parent || context;\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault: // consume abbreviation\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(function(c) {\n\t\t\t\t\t\tif (c == '[' || c == '{') {\n\t\t\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\n\t\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (c == '+') {\n\t\t\t\t\t\t\t// let's see if this is an expando marker\n\t\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\n\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\treturn isMarker;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn c != '(' && isAllowedChar(c);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (loopProtector < 1)\n\t\t\tthrow 'Endless loop detected';\n\t\t\n\t\treturn root;\n\t}\n\t\n\t/**\n\t * Extract attributes and their values from attribute set: \n\t * <code>[attr col=3 title=\"Quoted string\"]</code>\n\t * @param {String} attrSet\n\t * @returns {Array}\n\t */\n\tfunction extractAttributes(attrSet, attrs) {\n\t\tattrSet = require('utils').trim(attrSet);\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(attrSet);\n\t\tstream.eatSpace();\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tstream.start = stream.pos;\n\t\t\tif (stream.eatWhile(reWord)) {\n\t\t\t\tvar attrName = stream.current();\n\t\t\t\tvar attrValue = '';\n\t\t\t\tif (stream.peek() == '=') {\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tvar quote = stream.peek();\n\t\t\t\t\t\n\t\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\tif (consumeQuotedValue(stream, quote)) {\n\t\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t\t\t// strip quotes\n\t\t\t\t\t\t\tattrValue = attrValue.substring(1, attrValue.length - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (stream.eatWhile(/[^\\s\\]]/)) {\n\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult.push({\n\t\t\t\t\tname: attrName, \n\t\t\t\t\tvalue: attrValue\n\t\t\t\t});\n\t\t\t\tstream.eatSpace();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \n\t * returns object with <code>element</code> and <code>attributes</code>\n\t * properties\n\t * @param {String} abbr\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \n\t * abbreviation\n\t */\n\tfunction parseAttributes(abbr) {\n\t\t/*\n\t\t * Example of incoming data:\n\t\t * #header\n\t\t * .some.data\n\t\t * .some.data#header\n\t\t * [attr]\n\t\t * #item[attr=Hello other=\"World\"].class\n\t\t */\n\t\tvar result = [];\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\n\t\tvar nameEnd = null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '#': // id\n\t\t\t\tcase '.': // class\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\n\t\t\t\t\t\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(reWord);\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tname: attrName, \n\t\t\t\t\t\tvalue: stream.current()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[': //begin attribute set\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) \n\t\t\t\t\t\tthrow 'Invalid attribute set definition';\n\t\t\t\t\t\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!result.length)\n\t\t\treturn null;\n\t\t\n\t\treturn {\n\t\t\telement: abbr.substring(0, nameEnd),\n\t\t\tattributes: optimizeAttributes(result)\n\t\t};\n\t}\n\t\n\t/**\n\t * Optimize attribute set: remove duplicates and merge class attributes\n\t * @param attrs\n\t */\n\tfunction optimizeAttributes(attrs) {\n\t\t// clone all attributes to make sure that original objects are \n\t\t// not modified\n\t\tattrs  = _.map(attrs, function(attr) {\n\t\t\treturn _.clone(attr);\n\t\t});\n\t\t\n\t\tvar lookup = {};\n\t\treturn _.filter(attrs, function(attr) {\n\t\t\tif (!(attr.name in lookup)) {\n\t\t\t\treturn lookup[attr.name] = attr;\n\t\t\t}\n\t\t\t\n\t\t\tvar la = lookup[attr.name];\n\t\t\t\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\n\t\t\t} else {\n\t\t\t\tla.value = attr.value;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\t/**\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\n\t * If nothing found, returns <code>null</code>\n\t * @param {String} abbr\n\t * \n\t */\n\tfunction extractText(abbr) {\n\t\tif (!~abbr.indexOf('{'))\n\t\t\treturn null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\n\t\t\t\t\t\n\t\t\t\tcase '{':\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\n\t\t\t\t\t\ttext: stripped(stream.current())\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * “Un-rolls“ contents of current node: recursively replaces all repeating \n\t * children with their repeated clones\n\t * @param {AbbreviationNode} node\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction unroll(node) {\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\n\t\t\tchild = node.children[i];\n\t\t\t\n\t\t\tif (child.isRepeating()) {\n\t\t\t\tmaxCount = j = child.repeatCount;\n\t\t\t\tchild.repeatCount = 1;\n\t\t\t\tchild.updateProperty('counter', 1);\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\n\t\t\t\twhile (--j > 0) {\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// to keep proper 'counter' property, we need to walk\n\t\t// on children once again\n\t\t_.each(node.children, unroll);\n\t\t\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Optimizes tree node: replaces empty nodes with their children\n\t * @param {AbbreviationNode} node\n\t * @return {AbbreviationNode}\n\t */\n\tfunction squash(node) {\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\n\t\t\t/** @type AbbreviationNode */\n\t\t\tvar n = node.children[i];\n\t\t\tif (n.isGroup()) {\n\t\t\t\tn.replace(squash(n).children);\n\t\t\t} else if (n.isEmpty()) {\n\t\t\t\tn.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t\t_.each(node.children, squash);\n\t\t\n\t\treturn node;\n\t}\n\t\n\tfunction isAllowedChar(ch) {\n\t\tvar charCode = ch.charCodeAt(0);\n\t\tvar specialChars = '#.*:$-_!@|%';\n\t\t\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\n\t}\n\t\n\t// XXX add counter replacer function as output processor\n\toutputProcessors.push(function(text, node) {\n\t\treturn require('utils').replaceCounter(text, node.counter, node.maxCount);\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses abbreviation into tree with respect of groups, \n\t\t * text nodes and attributes. Each node of the tree is a single \n\t\t * abbreviation. Tree represents actual structure of the outputted \n\t\t * result\n\t\t * @memberOf abbreviationParser\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {Object} options Additional options for parser and processors\n\t\t * \n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\tparse: function(abbr, options) {\n\t\t\toptions = options || {};\n\t\t\t\n\t\t\tvar tree = parseAbbreviation(abbr);\n\t\t\t\n\t\t\tif (options.contextNode) {\n\t\t\t\t// add info about context node –\n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \n\t\t\t\t// expanded\n\t\t\t\ttree._name = options.contextNode.name;\n\t\t\t\tvar attrLookup = {};\n\t\t\t\t_.each(tree._attributes, function(attr) {\n\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t_.each(options.contextNode.attributes, function(attr) {\n\t\t\t\t\tif (attr.name in attrLookup) {\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr = _.clone(attr);\n\t\t\t\t\t\ttree._attributes.push(attr);\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// apply preprocessors\n\t\t\t_.each(preprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\ttree = squash(unroll(tree));\n\t\t\t\n\t\t\t// apply postprocessors\n\t\t\t_.each(postprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\tAbbreviationNode: AbbreviationNode,\n\t\t\n\t\t/**\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\n\t\t * The passed tree is in unoptimized state.\n\t\t * @param {Function} fn Preprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPreprocessor: function(fn) {\n\t\t\tif (!_.include(preprocessors, fn))\n\t\t\t\tpreprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered preprocessor\n\t\t */\n\t\tremoveFilter: function(fn) {\n\t\t\tpreprocessor = _.without(preprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\n\t\t * right before it returns from <code>parse()</code> method\n\t\t * @param {Function} fn Postprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPostprocessor: function(fn) {\n\t\t\tif (!_.include(postprocessors, fn))\n\t\t\t\tpostprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered postprocessor function\n\t\t */\n\t\tremovePostprocessor: function(fn) {\n\t\t\tpostprocessors = _.without(postprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \n\t\t * function that applies to output part (<code>start</code>, \n\t\t * <code>end</code> and <code>content</code>) when \n\t\t * <code>AbbreviationNode.toString()</code> method is called\n\t\t */\n\t\taddOutputProcessor: function(fn) {\n\t\t\tif (!_.include(outputProcessors, fn))\n\t\t\t\toutputProcessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered output processor\n\t\t */\n\t\tremoveOutputProcessor: function(fn) {\n\t\t\toutputProcessors = _.without(outputProcessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\n\t\t * @param {String} ch\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedChar: function(ch) {\n\t\t\tch = String(ch); // convert Java object to JS\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\n\t\t}\n\t};\n});/**\n * Processor function that matches parsed <code>AbbreviationNode</code>\n * against resources defined in <code>resource</code> module\n * @param {Function} require\n * @param {Underscore} _\n */ \nemmet.exec(function(require, _) {\n\t/**\n\t * Finds matched resources for child nodes of passed <code>node</code> \n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\n\t * that describes output of parsed node \n\t * @param {AbbreviationNode} node\n\t * @param {String} syntax\n\t */\n\tfunction matchResources(node, syntax) {\n\t\tvar resources = require('resources');\n\t\tvar elements = require('elements');\n\t\tvar parser = require('abbreviationParser');\n\t\t\n\t\t// do a shallow copy because the children list can be modified during\n\t\t// resource matching\n\t\t_.each(_.clone(node.children), /** @param {AbbreviationNode} child */ function(child) {\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\n\t\t\tif (_.isString(r)) {\n\t\t\t\tchild.data('resource', elements.create('snippet', r));\n\t\t\t} else if (elements.is(r, 'reference')) {\n\t\t\t\t// it’s a reference to another abbreviation:\n\t\t\t\t// parse it and insert instead of current child\n\t\t\t\t/** @type AbbreviationNode */\n\t\t\t\tvar subtree = parser.parse(r.data, {\n\t\t\t\t\tsyntax: syntax\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// if context element should be repeated, check if we need to \n\t\t\t\t// transfer repeated element to specific child node\n\t\t\t\tif (child.repeatCount > 1) {\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t_.each(repeatedChildren, function(node) {\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// move child‘s children into the deepest child of new subtree\n\t\t\t\tvar deepestChild = subtree.deepestChild();\n\t\t\t\tif (deepestChild) {\n\t\t\t\t\t_.each(child.children, function(c) {\n\t\t\t\t\t\tdeepestChild.addChild(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// copy current attributes to children\n\t\t\t\t_.each(subtree.children, function(node) {\n\t\t\t\t\t_.each(child.attributeList(), function(attr) {\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tchild.replace(subtree.children);\n\t\t\t} else {\n\t\t\t\tchild.data('resource', r);\n\t\t\t}\n\t\t\t\n\t\t\tmatchResources(child, syntax);\n\t\t});\n\t}\n\t\n\t// XXX register abbreviation filter that creates references to resources\n\t// on abbreviation nodes\n\t/**\n\t * @param {AbbreviationNode} tree\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar syntax = options.syntax || emmet.defaultSyntax();\n\t\tmatchResources(tree, syntax);\n\t});\n\t\n});/**\n * Pasted content abbreviation processor. A pasted content is a content that\n * should be inserted into implicitly repeated abbreviation nodes.\n * This processor powers “Wrap With Abbreviation” action\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar parser = require('abbreviationParser');\n\tvar outputPlaceholder = '$#';\n\t\n\t/**\n\t * Locates output placeholders inside text\n\t * @param {String} text\n\t * @returns {Array} Array of ranges of output placeholder in text\n\t */\n\tfunction locateOutputPlaceholder(text) {\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(text);\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '\\\\') {\n\t\t\t\tstream.next();\n\t\t\t} else {\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Replaces output placeholders inside <code>source</code> with \n\t * <code>value</code>\n\t * @param {String} source\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction replaceOutputPlaceholders(source, value) {\n\t\tvar utils = require('utils');\n\t\tvar ranges = locateOutputPlaceholder(source);\n\t\t\n\t\tranges.reverse();\n\t\t_.each(ranges, function(r) {\n\t\t\tsource = utils.replaceSubstring(source, value, r);\n\t\t});\n\t\t\n\t\treturn source;\n\t}\n\t\n\t/**\n\t * Check if parsed node contains output placeholder – a target where\n\t * pasted content should be inserted\n\t * @param {AbbreviationNode} node\n\t * @returns {Boolean}\n\t */\n\tfunction hasOutputPlaceholder(node) {\n\t\tif (locateOutputPlaceholder(node.content).length)\n\t\t\treturn true;\n\t\t\n\t\t// check if attributes contains placeholder\n\t\treturn !!_.find(node.attributeList(), function(attr) {\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Insert pasted content into correct positions of parsed node\n\t * @param {AbbreviationNode} node\n\t * @param {String} content\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\n\t * found instead of appending to existing content\n\t */\n\tfunction insertPastedContent(node, content, overwrite) {\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\n\t\t\treturn hasOutputPlaceholder(item);\n\t\t});\n\t\t\n\t\tif (hasOutputPlaceholder(node))\n\t\t\tnodesWithPlaceholders.unshift(node);\n\t\t\n\t\tif (nodesWithPlaceholders.length) {\n\t\t\t_.each(nodesWithPlaceholders, function(item) {\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\n\t\t\t\t_.each(item._attributes, function(attr) {\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// on output placeholders in subtree, insert content in the deepest\n\t\t\t// child node\n\t\t\tvar deepest = node.deepestChild() || node;\n\t\t\tif (overwrite) {\n\t\t\t\tdeepest.content = content;\n\t\t\t} else {\n\t\t\t\tdeepest.content = require('abbreviationUtils').insertChildContent(deepest.content, content);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPreprocessor(function(tree, options) {\n\t\tif (options.pastedContent) {\n\t\t\tvar utils = require('utils');\n\t\t\tvar lines = _.map(utils.splitByLines(options.pastedContent, true), utils.trim);\n\t\t\t\n\t\t\t// set repeat count for implicitly repeated elements before\n\t\t\t// tree is unrolled\n\t\t\ttree.findAll(function(item) {\n\t\t\t\tif (item.hasImplicitRepeat) {\n\t\t\t\t\titem.data('paste', lines);\n\t\t\t\t\treturn item.repeatCount = lines.length;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPostprocessor(function(tree, options) {\n\t\t// for each node with pasted content, update text data\n\t\tvar targets = tree.findAll(function(item) {\n\t\t\tvar pastedContentObj = item.data('paste');\n\t\t\tvar pastedContent = '';\n\t\t\tif (_.isArray(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj[item.counter - 1];\n\t\t\t} else if (_.isFunction(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj(item.counter - 1, item.content);\n\t\t\t} else if (pastedContentObj) {\n\t\t\t\tpastedContent = pastedContentObj;\n\t\t\t}\n\t\t\t\n\t\t\tif (pastedContent) {\n\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\n\t\t\t}\n\t\t\t\n\t\t\titem.data('paste', null);\n\t\t\treturn !!pastedContentObj;\n\t\t});\n\t\t\n\t\tif (!targets.length && options.pastedContent) {\n\t\t\t// no implicitly repeated elements, put pasted content in\n\t\t\t// the deepest child\n\t\t\tinsertPastedContent(tree, options.pastedContent);\n\t\t}\n\t});\n});/**\n * Resolves tag names in abbreviations with implied name\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Resolves implicit node names in parsed tree\n\t * @param {AbbreviationNode} tree\n\t */\n\tfunction resolveNodeNames(tree) {\n\t\tvar tagName = require('tagName');\n\t\t_.each(tree.children, function(node) {\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\n\t\t\t}\n\t\t\tresolveNodeNames(node);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('abbreviationParser').addPostprocessor(resolveNodeNames);\n});/**\n * @author Stoyan Stefanov\n * @link https://github.com/stoyan/etc/tree/master/cssex\n */\n\nemmet.define('cssParser', function(require, _) {\nvar walker, tokens = [], isOp, isNameChar, isDigit;\n    \n    // walks around the source\n    walker = {\n        lines: null,\n        total_lines: 0,\n        linenum: -1,\n        line: '',\n        ch: '',\n        chnum: -1,\n        init: function (source) {\n            var me = walker;\n        \n            // source, yumm\n            me.lines = source\n                .replace(/\\r\\n/g, '\\n')\n                .replace(/\\r/g, '\\n')\n                .split('\\n');\n            me.total_lines = me.lines.length;\n        \n            // reset\n            me.chnum = -1;\n            me.linenum = -1;\n            me.ch = '';\n            me.line = '';\n        \n            // advance\n            me.nextLine();\n            me.nextChar();\n        },\n        nextLine: function () {\n            var me = this;\n            me.linenum += 1;\n            if (me.total_lines <= me.linenum) {\n                me.line = false;\n            } else {\n                me.line = me.lines[me.linenum];\n            }\n            if (me.chnum !== -1) {\n                me.chnum = 0;\n            }\n            return me.line;\n        }, \n        nextChar: function () {\n            var me = this;\n            me.chnum += 1;\n            while (me.line.charAt(me.chnum) === '') {\n                if (this.nextLine() === false) {\n                    me.ch = false;\n                    return false; // end of source\n                }\n                me.chnum = -1;\n                me.ch = '\\n';\n                return '\\n';\n            }\n            me.ch = me.line.charAt(me.chnum);\n            return me.ch;\n        },\n        peek: function() {\n            return this.line.charAt(this.chnum + 1);\n        }\n    };\n\n    // utility helpers\n    isNameChar = function (c) {\n    \t// be more tolerate for name tokens: allow & character for LESS syntax\n        return (c == '&' || c === '_' || c === '-' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n    };\n\n    isDigit = function (ch) {\n        return (ch !== false && ch >= '0' && ch <= '9');\n    };  \n\n    isOp = (function () {\n        var opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\n            opsmatcha = \"*^|$~\".split(''),\n            ops = {},\n            opsmatch = {},\n            i = 0;\n        for (; i < opsa.length; i += 1) {\n            ops[opsa[i]] = true;\n        }\n        for (i = 0; i < opsmatcha.length; i += 1) {\n            opsmatch[opsmatcha[i]] = true;\n        }\n        return function (ch, matchattr) {\n            if (matchattr) {\n                return !!opsmatch[ch];\n            }\n            return !!ops[ch];\n        };\n    }());\n    \n    // shorthands\n    function isset(v) {\n        return typeof v !== 'undefined';\n    }\n    function getConf() {\n        return {\n            'char': walker.chnum,\n            line: walker.linenum\n        };\n    }\n\n\n    // creates token objects and pushes them to a list\n    function tokener(value, type, conf) {\n        var w = walker, c = conf || {};\n        tokens.push({\n            charstart: isset(c['char']) ? c['char'] : w.chnum,\n            charend:   isset(c.charend) ? c.charend : w.chnum,\n            linestart: isset(c.line)    ? c.line    : w.linenum,\n            lineend:   isset(c.lineend) ? c.lineend : w.linenum,\n            value:     value,\n            type:      type || value\n        });\n    }\n    \n    // oops\n    function error(m, config) { \n        var w = walker,\n            conf = config || {},\n            c = isset(conf['char']) ? conf['char'] : w.chnum,\n            l = isset(conf.line) ? conf.line : w.linenum;\n        return {\n            name: \"ParseError\",\n            message: m + \" at line \" + (l + 1) + ' char ' + (c + 1),\n            walker: w,\n            tokens: tokens\n        };\n    }\n\n\n    // token handlers follow for:\n    // white space, comment, string, identifier, number, operator\n    function white() {\n    \n        var c = walker.ch,\n            token = '',\n            conf = getConf();\n    \n        while (c === \" \" || c === \"\\t\") {\n            token += c;\n            c = walker.nextChar();\n        }\n    \n        tokener(token, 'white', conf);\n    \n    }\n\n    function comment() {\n    \n        var w = walker,\n            c = w.ch,\n            token = c,\n            cnext,\n            conf = getConf();    \n     \n        cnext = w.nextChar();\n\n        if (cnext === '/') {\n            // inline comment in SCSS and such\n            token += cnext;\n            var pk = w.peek();\n            while (pk && pk !== '\\n') {\n                token += cnext;\n                cnext = w.nextChar();\n                pk = w.peek();\n            }\n        } else if (cnext === '*') {\n            // multiline CSS commment\n            while (!(c === \"*\" && cnext === \"/\")) {\n                token += cnext;\n                c = cnext;\n                cnext = w.nextChar();        \n            }            \n        } else {\n            // oops, not a comment, just a /\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, token, conf);\n        }\n        \n        token += cnext;\n        w.nextChar();\n        tokener(token, 'comment', conf);\n    }\n\n    function str() {\n        var w = walker,\n            c = w.ch,\n            q = c,\n            token = c,\n            cnext,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== q) {\n            \n            if (c === '\\n') {\n                cnext = w.nextChar();\n                if (cnext === \"\\\\\") {\n                    token += c + cnext;\n                } else {\n                    // end of line with no \\ escape = bad\n                    throw error(\"Unterminated string\", conf);\n                }\n            } else {\n                if (c === \"\\\\\") {\n                    token += c + w.nextChar();\n                } else {\n                    token += c;\n                }\n            }\n        \n            c = w.nextChar();\n        \n        }\n        token += c;\n        w.nextChar();\n        tokener(token, 'string', conf);\n    }\n    \n    function brace() {\n        var w = walker,\n            c = w.ch,\n            depth = 0,\n            token = c,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== ')' && !depth) {\n        \tif (c === '(') {\n        \t\tdepth++;\n        \t} else if (c === ')') {\n        \t\tdepth--;\n        \t} else if (c === false) {\n        \t\tthrow error(\"Unterminated brace\", conf);\n        \t}\n        \t\n        \ttoken += c;\n            c = w.nextChar();\n        }\n        \n        token += c;\n        w.nextChar();\n        tokener(token, 'brace', conf);\n    }\n\n    function identifier(pre) {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = (pre) ? pre + c : c;\n            \n        c = w.nextChar();\n    \n        if (pre) { // adjust token position\n        \tconf['char'] -= pre.length;\n        }\n        \n        while (isNameChar(c) || isDigit(c)) {\n            token += c;\n            c = w.nextChar();\n        }\n    \n        tokener(token, 'identifier', conf);    \n    }\n\n    function num() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            point = token === '.',\n            nondigit;\n        \n        c = w.nextChar();\n        nondigit = !isDigit(c);\n    \n        // .2px or .classname?\n        if (point && nondigit) {\n            // meh, NaN, could be a class name, so it's an operator for now\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, '.', conf);    \n        }\n        \n        // -2px or -moz-something\n        if (token === '-' && nondigit) {\n            return identifier('-');\n        }\n    \n        while (c !== false && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\n            if (c === '.') {\n                point = true;\n            }\n            token += c;\n            c = w.nextChar();\n        }\n\n        tokener(token, 'number', conf);    \n    \n    }\n\n    function op() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            next = w.nextChar();\n            \n        if (next === \"=\" && isOp(token, true)) {\n            token += next;\n            tokener(token, 'match', conf);\n            w.nextChar();\n            return;\n        } \n        \n        conf.charend = conf['char'] + 1;\n        conf.lineend = conf.line;    \n        tokener(token, token, conf);\n    }\n\n\n    // call the appropriate handler based on the first character in a token suspect\n    function tokenize() {\n\n        var ch = walker.ch;\n    \n        if (ch === \" \" || ch === \"\\t\") {\n            return white();\n        }\n\n        if (ch === '/') {\n            return comment();\n        } \n\n        if (ch === '\"' || ch === \"'\") {\n            return str();\n        }\n        \n        if (ch === '(') {\n            return brace();\n        }\n    \n        if (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\n            return num();\n        }\n    \n        if (isNameChar(ch)) {\n            return identifier();\n        }\n\n        if (isOp(ch)) {\n            return op();\n        }\n        \n        if (ch === \"\\n\") {\n            tokener(\"line\");\n            walker.nextChar();\n            return;\n        }\n        \n        throw error(\"Unrecognized character\");\n    }\n    \n    /**\n\t * Returns newline character at specified position in content\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @return {String}\n\t */\n\tfunction getNewline(content, pos) {\n\t\treturn content.charAt(pos) == '\\r' && content.charAt(pos + 1) == '\\n' \n\t\t\t? '\\r\\n' \n\t\t\t: content.charAt(pos);\n\t}\n\n    return {\n    \t/**\n    \t * @param source\n    \t * @returns\n    \t * @memberOf emmet.cssParser\n    \t */\n        lex: function (source) {\n            walker.init(source);\n            tokens = [];\n            while (walker.ch !== false) {\n                tokenize();            \n            }\n            return tokens;\n        },\n        \n        /**\n         * Tokenizes CSS source\n         * @param {String} source\n         * @returns {Array}\n         */\n        parse: function(source) {\n        \t// transform tokens\n\t \t\tvar pos = 0;\n\t \t\treturn _.map(this.lex(source), function(token) {\n\t \t\t\tif (token.type == 'line') {\n\t \t\t\t\ttoken.value = getNewline(source, pos);\n\t \t\t\t}\n\t \t\t\t\n\t \t\t\treturn {\n\t \t\t\t\ttype: token.type,\n\t \t\t\t\tstart: pos,\n\t \t\t\t\tend: (pos += token.value.length)\n\t \t\t\t};\n\t\t\t});\n\t\t},\n        \n        toSource: function (toks) {\n            var i = 0, max = toks.length, t, src = '';\n            for (; i < max; i += 1) {\n                t = toks[i];\n                if (t.type === 'line') {\n                    src += '\\n';\n                } else {\n                    src += t.value;\n                }\n            }\n            return src;\n        }\n    };\n});/**\n * HTML tokenizer by Marijn Haverbeke\n * http://codemirror.net/\n * @constructor\n * @memberOf __xmlParseDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('xmlParser', function(require, _) {\n\tvar Kludges = {\n\t\tautoSelfClosers : {},\n\t\timplicitlyClosed : {},\n\t\tcontextGrabbers : {},\n\t\tdoNotIndent : {},\n\t\tallowUnquoted : true,\n\t\tallowMissing : true\n\t};\n\n\t// Return variables for tokenizers\n\tvar tagName = null, type = null;\n\n\tfunction inText(stream, state) {\n\t\tfunction chain(parser) {\n\t\t\tstate.tokenize = parser;\n\t\t\treturn parser(stream, state);\n\t\t}\n\n\t\tvar ch = stream.next();\n\t\tif (ch == \"<\") {\n\t\t\tif (stream.eat(\"!\")) {\n\t\t\t\tif (stream.eat(\"[\")) {\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t} else if (stream.match(\"--\"))\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\t\treturn chain(doctype(1));\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t} else if (stream.eat(\"?\")) {\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\n\t\t\t\treturn \"meta\";\n\t\t\t} else {\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t\t\t\tstream.eatSpace();\n\t\t\t\ttagName = \"\";\n\t\t\t\tvar c;\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\n\t\t\t\t\ttagName += c;\n\t\t\t\tstate.tokenize = inTag;\n\t\t\t\treturn \"tag\";\n\t\t\t}\n\t\t} else if (ch == \"&\") {\n\t\t\tvar ok;\n\t\t\tif (stream.eat(\"#\")) {\n\t\t\t\tif (stream.eat(\"x\")) {\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t\t\t\t} else {\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t\t\t}\n\t\t\treturn ok ? \"atom\" : \"error\";\n\t\t} else {\n\t\t\tstream.eatWhile(/[^&<]/);\n\t\t\treturn \"text\";\n\t\t}\n\t}\n\n\tfunction inTag(stream, state) {\n\t\tvar ch = stream.next();\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t\t\tstate.tokenize = inText;\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t\t\treturn \"tag\";\n\t\t} else if (ch == \"=\") {\n\t\t\ttype = \"equals\";\n\t\t\treturn null;\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\n\t\t\tstate.tokenize = inAttribute(ch);\n\t\t\treturn state.tokenize(stream, state);\n\t\t} else {\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n\t\t\treturn \"word\";\n\t\t}\n\t}\n\n\tfunction inAttribute(quote) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.next() == quote) {\n\t\t\t\t\tstate.tokenize = inTag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"string\";\n\t\t};\n\t}\n\n\tfunction inBlock(style, terminator) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.match(terminator)) {\n\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t\treturn style;\n\t\t};\n\t}\n\t\n\tfunction doctype(depth) {\n\t\treturn function(stream, state) {\n\t\t\tvar ch;\n\t\t\twhile ((ch = stream.next()) != null) {\n\t\t\t\tif (ch == \"<\") {\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\n\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t} else if (ch == \">\") {\n\t\t\t\t\tif (depth == 1) {\n\t\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\n\t\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"meta\";\n\t\t};\n\t}\n\n\tvar curState = null, setStyle;\n\tfunction pass() {\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\n\t\t\tcurState.cc.push(arguments[i]);\n\t}\n\t\n\tfunction cont() {\n\t\tpass.apply(null, arguments);\n\t\treturn true;\n\t}\n\n\tfunction pushContext(tagName, startOfLine) {\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \n\t\t\t|| (curState.context && curState.context.noIndent);\n\t\tcurState.context = {\n\t\t\tprev : curState.context,\n\t\t\ttagName : tagName,\n\t\t\tindent : curState.indented,\n\t\t\tstartOfLine : startOfLine,\n\t\t\tnoIndent : noIndent\n\t\t};\n\t}\n\t\n\tfunction popContext() {\n\t\tif (curState.context)\n\t\t\tcurState.context = curState.context.prev;\n\t}\n\n\tfunction element(type) {\n\t\tif (type == \"openTag\") {\n\t\t\tcurState.tagName = tagName;\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\n\t\t} else if (type == \"closeTag\") {\n\t\t\tvar err = false;\n\t\t\tif (curState.context) {\n\t\t\t\tif (curState.context.tagName != tagName) {\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n\t\t\t\t\t\tpopContext();\n\t\t\t\t\t}\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(endclosetag(err));\n\t\t}\n\t\treturn cont();\n\t}\n\t\n\tfunction endtag(startOfLine) {\n\t\treturn function(type) {\n\t\t\tif (type == \"selfcloseTag\"\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\tpushContext(curState.tagName, startOfLine);\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\treturn cont();\n\t\t};\n\t}\n\t\n\tfunction endclosetag(err) {\n\t\treturn function(type) {\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tpopContext();\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(arguments.callee);\n\t\t};\n\t}\n\t\n\tfunction maybePopContext(nextTagName) {\n\t\tvar parentTagName;\n\t\twhile (true) {\n\t\t\tif (!curState.context) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpopContext();\n\t\t}\n\t}\n\n\tfunction attributes(type) {\n\t\tif (type == \"word\") {\n\t\t\tsetStyle = \"attribute\";\n\t\t\treturn cont(attribute, attributes);\n\t\t}\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\n\t\t\treturn pass();\n\t\tsetStyle = \"error\";\n\t\treturn cont(attributes);\n\t}\n\t\n\tfunction attribute(type) {\n\t\tif (type == \"equals\")\n\t\t\treturn cont(attvalue, attributes);\n\t\tif (!Kludges.allowMissing)\n\t\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvalue(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\n\t\t\tsetStyle = \"string\";\n\t\t\treturn cont();\n\t\t}\n\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvaluemaybe(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\telse\n\t\t\treturn pass();\n\t}\n\t\n\tfunction startState() {\n\t\treturn {\n\t\t\ttokenize : inText,\n\t\t\tcc : [],\n\t\t\tindented : 0,\n\t\t\tstartOfLine : true,\n\t\t\ttagName : null,\n\t\t\tcontext : null\n\t\t};\n\t}\n\t\n\tfunction token(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.startOfLine = true;\n\t\t\tstate.indented = 0;\n\t\t}\n\t\t\n\t\tif (stream.eatSpace())\n\t\t\treturn null;\n\n\t\tsetStyle = type = tagName = null;\n\t\tvar style = state.tokenize(stream, state);\n\t\tstate.type = type;\n\t\tif ((style || type) && style != \"comment\") {\n\t\t\tcurState = state;\n\t\t\twhile (true) {\n\t\t\t\tvar comb = state.cc.pop() || element;\n\t\t\t\tif (comb(type || style))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstate.startOfLine = false;\n\t\treturn setStyle || style;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * @memberOf emmet.xmlParser\n\t\t * @returns\n\t\t */\n\t\tparse: function(data, offset) {\n\t\t\toffset = offset || 0;\n\t\t\tvar state = startState();\n\t\t\tvar stream = require('stringStream').create(data);\n\t\t\tvar tokens = [];\n\t\t\twhile (!stream.eol()) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttype: token(stream, state),\n\t\t\t\t\tstart: stream.start + offset,\n\t\t\t\t\tend: stream.pos + offset\n\t\t\t\t});\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn tokens;\n\t\t}\t\t\n\t};\n});\n/*!\n * string_score.js: String Scoring Algorithm 0.1.10 \n *\n * http://joshaven.com/string_score\n * https://github.com/joshaven/string_score\n *\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\n * MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Date: Tue Mar 1 2011\n*/\n\n/**\n * Scores a string against another string.\n *  'Hello World'.score('he');     //=> 0.5931818181818181\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\n */\nemmet.define('string-score', function(require, _) {\n\treturn {\n\t\tscore: function(string, abbreviation, fuzziness) {\n\t\t\t// If the string is equal to the abbreviation, perfect match.\n\t\t\t  if (string == abbreviation) {return 1;}\n\t\t\t  //if it's not a perfect match and is empty return 0\n\t\t\t  if(abbreviation == \"\") {return 0;}\n\n\t\t\t  var total_character_score = 0,\n\t\t\t      abbreviation_length = abbreviation.length,\n\t\t\t      string_length = string.length,\n\t\t\t      start_of_string_bonus,\n\t\t\t      abbreviation_score,\n\t\t\t      fuzzies=1,\n\t\t\t      final_score;\n\t\t\t  \n\t\t\t  // Walk through abbreviation and add up scores.\n\t\t\t  for (var i = 0,\n\t\t\t         character_score/* = 0*/,\n\t\t\t         index_in_string/* = 0*/,\n\t\t\t         c/* = ''*/,\n\t\t\t         index_c_lowercase/* = 0*/,\n\t\t\t         index_c_uppercase/* = 0*/,\n\t\t\t         min_index/* = 0*/;\n\t\t\t     i < abbreviation_length;\n\t\t\t     ++i) {\n\t\t\t    \n\t\t\t    // Find the first case-insensitive match of a character.\n\t\t\t    c = abbreviation.charAt(i);\n\t\t\t    \n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\n\t\t\t    \n\t\t\t    if (index_in_string === -1) { \n\t\t\t      if (fuzziness) {\n\t\t\t        fuzzies += 1-fuzziness;\n\t\t\t        continue;\n\t\t\t      } else {\n\t\t\t        return 0;\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      character_score = 0.1;\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Set base score for matching 'c'.\n\t\t\t    \n\t\t\t    // Same case bonus.\n\t\t\t    if (string[index_in_string] === c) { \n\t\t\t      character_score += 0.1; \n\t\t\t    }\n\t\t\t    \n\t\t\t    // Consecutive letter & start-of-string Bonus\n\t\t\t    if (index_in_string === 0) {\n\t\t\t      // Increase the score when matching first character of the remainder of the string\n\t\t\t      character_score += 0.6;\n\t\t\t      if (i === 0) {\n\t\t\t        // If match is the first character of the string\n\t\t\t        // & the first character of abbreviation, add a\n\t\t\t        // start-of-string match bonus.\n\t\t\t        start_of_string_bonus = 1; //true;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    else {\n\t\t\t  // Acronym Bonus\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\n\t\t\t  // preceded it with two perfect character matches.\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\n\t\t\t  }\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Left trim the already matched part of the string\n\t\t\t    // (forces sequential matching).\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\n\t\t\t    \n\t\t\t    total_character_score += character_score;\n\t\t\t  } // end of for loop\n\t\t\t  \n\t\t\t  // Uncomment to weigh smaller words higher.\n\t\t\t  // return total_character_score / string_length;\n\t\t\t  \n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\n\t\t\t  \n\t\t\t  // Reduce penalty for longer strings.\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\n\t\t\t  \n\t\t\t  final_score = final_score / fuzzies;\n\t\t\t  \n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\n\t\t\t    final_score += 0.15;\n\t\t\t  }\n\t\t\t  \n\t\t\t  return final_score;\n\t\t}\n\t};\n});/**\n * Utility module for Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('utils', function(require, _) {\n\t/** \n\t * Special token used as a placeholder for caret positions inside \n\t * generated output \n\t */\n\tvar caretPlaceholder = '${0}';\n\t\n\t/**\n\t * A simple string builder, optimized for faster text concatenation\n\t * @param {String} value Initial value\n\t */\n\tfunction StringBuilder(value) {\n\t\tthis._data = [];\n\t\tthis.length = 0;\n\t\t\n\t\tif (value)\n\t\t\tthis.append(value);\n\t}\n\t\n\tStringBuilder.prototype = {\n\t\t/**\n\t\t * Append string\n\t\t * @param {String} text\n\t\t */\n\t\tappend: function(text) {\n\t\t\tthis._data.push(text);\n\t\t\tthis.length += text.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this._data.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/** @memberOf utils */\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\n\t\t\n\t\t/**\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \n\t\t * @param {String} str\n\t\t * @return {Boolean}\n\t\t */\n\t\tendsWithTag: function(str) {\n\t\t\treturn this.reTag.test(str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is a number\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisNumeric: function(ch) {\n\t\t\tif (typeof(ch) == 'string')\n\t\t\t\tch = ch.charCodeAt(0);\n\t\t\t\t\n\t\t\treturn (ch && ch > 47 && ch < 58);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Trim whitespace from string\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function(text) {\n\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns newline character\n\t\t * @returns {String}\n\t\t */\n\t\tgetNewline: function() {\n\t\t\tvar res = require('resources');\n\t\t\tif (!res) {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\t\n\t\t\tvar nl = res.getVariable('newline');\n\t\t\treturn _.isString(nl) ? nl : '\\n';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new newline character that will be used in output\n\t\t * @param {String} str\n\t\t */\n\t\tsetNewline: function(str) {\n\t\t\tvar res = require('resources');\n\t\t\tres.setVariable('newline', str);\n\t\t\tres.setVariable('nl', str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\n\t\t * empty lines\n\t\t * @param {String} text Text to split\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\n\t\t * @return {Array}\n\t\t */\n\t\tsplitByLines: function(text, removeEmpty) {\n\t\t\t// IE fails to split string by regexp, \n\t\t\t// need to normalize newlines first\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\n\t\t\tvar nl = this.getNewline();\n\t\t\tvar lines = (text || '')\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\n\t\t\t\t.replace(/\\r/g, '\\n')\n\t\t\t\t.replace(/\\n/g, nl)\n\t\t\t\t.split(nl);\n\t\t\t\n\t\t\tif (removeEmpty) {\n\t\t\t\tlines = _.filter(lines, function(line) {\n\t\t\t\t\treturn line.length && !!this.trim(line);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes newline character: replaces newlines in <code>text</code> \n\t\t * with newline defined in preferences\n\t\t * @param {String} text\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeNewline: function(text) {\n\t\t\treturn this.splitByLines(text).join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeats string <code>howMany</code> times\n\t\t * @param {String} str\n\t\t * @param {Number} how_many\n\t\t * @return {String}\n\t\t */\n\t\trepeatString: function(str, howMany) {\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < howMany; i++) \n\t\t\t\tresult.push(str);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of paddings that should be used to align passed string\n\t\t * @param {Array} strings\n\t\t * @returns {Array}\n\t\t */\n\t\tgetStringsPads: function(strings) {\n\t\t\tvar lengths = _.map(strings, function(s) {\n\t\t\t\treturn _.isString(s) ? s.length : +s;\n\t\t\t});\n\t\t\t\n\t\t\tvar max = _.max(lengths);\n\t\t\treturn _.map(lengths, function(l) {\n\t\t\t\tvar pad = max - l;\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indents text with padding\n\t\t * @param {String} text Text to indent\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\n\t\t * @return {String}\n\t\t */\n\t\tpadString: function(text, pad) {\n\t\t\tvar padStr = (_.isNumber(pad)) \n\t\t\t\t? this.repeatString(require('resources').getVariable('indentation') || '\\t', pad) \n\t\t\t\t: pad;\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar nl = this.getNewline();\n\t\t\t\t\n\t\t\tresult.push(lines[0]);\n\t\t\tfor (var j = 1; j < lines.length; j++) \n\t\t\t\tresult.push(nl + padStr + lines[j]);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Pad string with zeroes\n\t\t * @param {String} str String to pad\n\t\t * @param {Number} pad Desired string length\n\t\t * @return {String}\n\t\t */\n\t\tzeroPadString: function(str, pad) {\n\t\t\tvar padding = '';\n\t\t\tvar il = str.length;\n\t\t\t\t\n\t\t\twhile (pad > il++) padding += '0';\n\t\t\treturn padding + str; \n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes padding at the beginning of each text's line\n\t\t * @param {String} text\n\t\t * @param {String} pad\n\t\t */\n\t\tunindentString: function(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].search(pad) == 0)\n\t\t\t\t\tlines[i] = lines[i].substr(pad.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines.join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\n\t\t * @param {String} str Original string\n\t\t * @param {String} symbol Symbol to replace\n\t\t * @param {String} replace Symbol replacement. Might be a function that \n\t\t * returns new value\n\t\t * @return {String}\n\t\t */\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\n\t\t\tvar i = 0;\n\t\t\tvar il = str.length;\n\t\t\tvar sl = symbol.length;\n\t\t\tvar matchCount = 0;\n\t\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t// escaped symbol, skip next character\n\t\t\t\t\ti += sl + 1;\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\n\t\t\t\t\t// have match\n\t\t\t\t\tvar curSl = sl;\n\t\t\t\t\tmatchCount++;\n\t\t\t\t\tvar newValue = replace;\n\t\t\t\t\tif (_.isFunction(replace)) {\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\n\t\t\t\t\t\tif (replaceData) {\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\n\t\t\t\t\t\t\tnewValue = replaceData[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === false) { // skip replacement\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\n\t\t\t\t\t// adjust indexes\n\t\t\t\t\til = str.length;\n\t\t\t\t\ti += newValue.length;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn str;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace variables like ${var} in string\n\t\t * @param {String} str\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\n\t\t * @return {String}\n\t\t */\n\t\treplaceVariables: function(str, vars) {\n\t\t\tvars = vars || {};\n\t\t\tvar resolver = _.isFunction(vars) ? vars : function(str, p1) {\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\n\t\t\t};\n\t\t\t\n\t\t\tvar res = require('resources');\n\t\t\treturn require('tabStops').processText(str, {\n\t\t\t\tvariable: function(data) {\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\n\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t// try to find variable in resources\n\t\t\t\t\t\tnewValue = res.getVariable(data.name);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === null || _.isUndefined(newValue))\n\t\t\t\t\t\t// nothing found, return token itself\n\t\t\t\t\t\tnewValue = data.token;\n\t\t\t\t\treturn newValue;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\n\t\t * @param {String} str String where character should be replaced\n\t\t * @param {String} value New value\n\t\t * @return {String}\n\t\t */\n\t\treplaceCounter: function(str, value, total) {\n\t\t\tvar symbol = '$';\n\t\t\t// in case we received strings from Java, convert the to native strings\n\t\t\tstr = String(str);\n\t\t\tvalue = String(value);\n\t\t\t\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\n\t\t\t\tvalue = +value;\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\n\t\t\t\t\t// it's a variable, skip it\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// replace sequense of $ symbols with padded number  \n\t\t\t\tvar j = pos + 1;\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\n\t\t\t\tvar pad = j - pos;\n\t\t\t\t\n\t\t\t\t// get counter base\n\t\t\t\tvar base = 0, decrement = false, m;\n\t\t\t\tif (m = str.substr(j).match(/^@(\\-?)(\\d*)/)) {\n\t\t\t\t\tj += m[0].length;\n\t\t\t\t\t\n\t\t\t\t\tif (m[1]) {\n\t\t\t\t\t\tdecrement = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbase = parseInt(m[2] || 1) - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (decrement && total && _.isNumber(value)) {\n\t\t\t\t\tvalue = total - value + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue += base;\n\t\t\t\t\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if string matches against <code>reTag</code> regexp. This \n\t\t * function may be used to test if provided string contains HTML tags\n\t\t * @param {String} str\n\t\t * @returns {Boolean}\n\t\t */\n\t\tmatchesTag: function(str) {\n\t\t\treturn this.reTag.test(str || '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\n\t\t * to make sure that existing special characters won't be altered\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tescapeText: function(text) {\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunescapeText: function(text) {\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns caret placeholder\n\t\t * @returns {String}\n\t\t */\n\t\tgetCaretPlaceholder: function() {\n\t\t\treturn _.isFunction(caretPlaceholder) \n\t\t\t\t? caretPlaceholder.apply(this, arguments)\n\t\t\t\t: caretPlaceholder;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new representation for carets in generated output\n\t\t * @param {String} value New caret placeholder. Might be a \n\t\t * <code>Function</code>\n\t\t */\n\t\tsetCaretPlaceholder: function(value) {\n\t\t\tcaretPlaceholder = value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns line padding\n\t\t * @param {String} line\n\t\t * @return {String}\n\t\t */\n\t\tgetLinePadding: function(line) {\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that returns padding of line of <code>pos</code>\n\t\t * position in <code>content</code>\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @returns {String}\n\t\t */\n\t\tgetLinePaddingFromPosition: function(content, pos) {\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\n\t\t * regular expressions\n\t\t * @param {String} str\n\t\t * @return {String}\n\t\t */\n\t\tescapeForRegexp: function(str) {\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\n\t\t\treturn str.replace(specials, \"\\\\$&\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Make decimal number look good: convert it to fixed precision end remove\n\t\t * traling zeroes \n\t\t * @param {Number} num\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\n\t\t * @return {String}\n\t\t */\n\t\tprettifyNumber: function(num, fraction) {\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * A simple mutable string shim, optimized for faster text concatenation\n\t\t * @param {String} value Initial value\n\t\t * @returns {StringBuilder}\n\t\t */\n\t\tstringBuilder: function(value) {\n\t\t\treturn new StringBuilder(value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace substring of <code>str</code> with <code>value</code>\n\t\t * @param {String} str String where to replace substring\n\t\t * @param {String} value New substring value\n\t\t * @param {Number} start Start index of substring to replace. May also\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\n\t\t * argument is not required\n\t\t * @param {Number} end End index of substring to replace. If ommited, \n\t\t * <code>start</code> argument is used\n\t\t */\n\t\treplaceSubstring: function(str, value, start, end) {\n\t\t\tif (_.isObject(start) && 'end' in start) {\n\t\t\t\tend = start.end;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(end))\n\t\t\t\tend = start + end.length;\n\t\t\t\n\t\t\tif (_.isUndefined(end))\n\t\t\t\tend = start;\n\t\t\t\n\t\t\tif (start < 0 || start > str.length)\n\t\t\t\treturn str;\n\t\t\t\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Narrows down text range, adjusting selection to non-space characters\n\t\t * @param {String} text\n\t\t * @param {Number} start Starting range in <code>text</code> where \n\t\t * slection should be adjusted. Can also be any object that is accepted\n\t\t * by <code>Range</code> class\n\t\t * @return {Range}\n\t\t */\n\t\tnarrowToNonSpace: function(text, start, end) {\n\t\t\tvar range = require('range').create(start, end);\n\t\t\t\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\n\t\t\t// narrow down selection until first non-space character\n\t\t\twhile (range.start < range.end) {\n\t\t\t\tif (!reSpace.test(text.charAt(range.start)))\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\trange.start++;\n\t\t\t}\n\t\t\t\n\t\t\twhile (range.end > range.start) {\n\t\t\t\trange.end--;\n\t\t\t\tif (!reSpace.test(text.charAt(range.end))) {\n\t\t\t\t\trange.end++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn range;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find start and end index of text line for <code>from</code> index\n\t\t * @param {String} text \n\t\t * @param {Number} from\n\t\t */\n\t\tfindNewlineBounds: function(text, from) {\n\t\t\tvar len = text.length,\n\t\t\t\tstart = 0,\n\t\t\t\tend = len - 1;\n\t\t\t\n\t\t\t// search left\n\t\t\tfor (var i = from - 1; i > 0; i--) {\n\t\t\t\tvar ch = text.charAt(i);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// search right\n\t\t\tfor (var j = from; j < len; j++) {\n\t\t\t\tvar ch = text.charAt(j);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tend = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn require('range').create(start, end - start);\n\t\t},\n\n\t\t/**\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\n\t\t */\n\t\tdeepMerge: function() {\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\t\ttarget = arguments[0] || {},\n\t\t\t\ti = 1,\n\t\t\t\tlength = arguments.length;\n\n\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\t\tif (!_.isObject(target) && !_.isFunction(target)) {\n\t\t\t\ttarget = {};\n\t\t\t}\n\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t// Only deal with non-null/undefined values\n\t\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t\t// Extend the base object\n\t\t\t\t\tfor ( name in options ) {\n\t\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif ( copy && ( _.isObject(copy) || (copyIsArray = _.isArray(copy)) ) ) {\n\t\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && _.isArray(src) ? src : [];\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && _.isObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the modified object\n\t\t\treturn target;\n\t\t}\n\t};\n});\n/**\n * Helper module to work with ranges\n * @constructor\n * @memberOf __rangeDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('range', function(require, _) {\n\tfunction cmp(a, b, op) {\n\t\tswitch (op) {\n\t\t\tcase 'eq':\n\t\t\tcase '==':\n\t\t\t\treturn a === b;\n\t\t\tcase 'lt':\n\t\t\tcase '<':\n\t\t\t\treturn a < b;\n\t\t\tcase 'lte':\n\t\t\tcase '<=':\n\t\t\t\treturn a <= b;\n\t\t\tcase 'gt':\n\t\t\tcase '>':\n\t\t\t\treturn a > b;\n\t\t\tcase 'gte':\n\t\t\tcase '>=':\n\t\t\t\treturn a >= b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * @type Range\n\t * @constructor\n\t * @param {Object} start\n\t * @param {Number} len\n\t */\n\tfunction Range(start, len) {\n\t\tif (_.isObject(start) && 'start' in start) {\n\t\t\t// create range from object stub\n\t\t\tthis.start = Math.min(start.start, start.end);\n\t\t\tthis.end = Math.max(start.start, start.end);\n\t\t} else if (_.isArray(start)) {\n\t\t\tthis.start = start[0];\n\t\t\tthis.end = start[1];\n\t\t} else {\n\t\t\tlen = _.isString(len) ? len.length : +len;\n\t\t\tthis.start = start;\n\t\t\tthis.end = start + len;\n\t\t}\n\t}\n\t\n\tRange.prototype = {\n\t\tlength: function() {\n\t\t\treturn Math.abs(this.end - this.start);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns <code>true</code> if passed range is equals to current one\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\tequal: function(range) {\n\t\t\treturn this.cmp(range, 'eq', 'eq');\n//\t\t\treturn this.start === range.start && this.end === range.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shifts indexes position with passed <code>delat</code>\n\t\t * @param {Number} delta\n\t\t * @returns {Range} range itself\n\t\t */\n\t\tshift: function(delta) {\n\t\t\tthis.start += delta;\n\t\t\tthis.end += delta;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if two ranges are overlapped\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\toverlap: function(range) {\n\t\t\treturn range.start <= this.end && range.end >= this.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds intersection of two ranges\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\n\t\t */\n\t\tintersection: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the union of the thow ranges.\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\n\t\t */\n\t\tunion: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.min(range.start, this.start);\n\t\t\t\tvar end = Math.max(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range.\n\t\t * @param {Number} loc\n\t\t */\n\t\tinside: function(loc) {\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\n//\t\t\treturn this.start <= loc && this.end > loc;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range, but not equals bounds.\n\t\t * @param {Number} loc\n\t\t */\n\t\tcontains: function(loc) {\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current range completely includes specified one\n\t\t * @param {Range} r\n\t\t * @returns {Boolean} \n\t\t */\n\t\tinclude: function(r) {\n\t\t\treturn this.cmp(loc, 'lte', 'gte');\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Low-level comparision method\n\t\t * @param {Number} loc\n\t\t * @param {String} left Left comparison operator\n\t\t * @param {String} right Right comaprison operator\n\t\t */\n\t\tcmp: function(loc, left, right) {\n\t\t\tvar a, b;\n\t\t\tif (loc instanceof Range) {\n\t\t\t\ta = loc.start;\n\t\t\t\tb = loc.end;\n\t\t\t} else {\n\t\t\t\ta = b = loc;\n\t\t\t}\n\t\t\t\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns substring of specified <code>str</code> for current range\n\t\t * @param {String} str\n\t\t * @returns {String}\n\t\t */\n\t\tsubstring: function(str) {\n\t\t\treturn this.length() > 0 \n\t\t\t\t? str.substring(this.start, this.end) \n\t\t\t\t: '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates copy of current range\n\t\t * @returns {Range}\n\t\t */\n\t\tclone: function() {\n\t\t\treturn new Range(this.start, this.length());\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {Array}\n\t\t */\n\t\ttoArray: function() {\n\t\t\treturn [this.start, this.end];\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new range object instance\n\t\t * @param {Object} start Range start or array with 'start' and 'end'\n\t\t * as two first indexes or object with 'start' and 'end' properties\n\t\t * @param {Number} len Range length or string to produce range from\n\t\t * @returns {Range}\n\t\t * @memberOf emmet.range\n\t\t */\n\t\tcreate: function(start, len) {\n\t\t\tif (_.isUndefined(start) || start === null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (start instanceof Range)\n\t\t\t\treturn start;\n\t\t\t\n\t\t\tif (_.isObject(start) && 'start' in start && 'end' in start) {\n\t\t\t\tlen = start.end - start.start;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn new Range(start, len);\n\t\t},\n\t\t\n\t\t/**\n\t\t * <code>Range</code> object factory, the same as <code>this.create()</code>\n\t\t * but last argument represents end of range, not length\n\t\t * @returns {Range}\n\t\t */\n\t\tcreate2: function(start, end) {\n\t\t\tif (_.isNumber(start) && _.isNumber(end)) {\n\t\t\t\tend -= start;\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(start, end);\n\t\t}\n\t};\n});/**\n * Utility module that provides ordered storage of function handlers. \n * Many Emmet modules' functionality can be extended/overridden by custom\n * function. This modules provides unified storage of handler functions, their \n * management and execution\n * \n * @constructor\n * @memberOf __handlerListDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('handlerList', function(require, _) {\n\t/**\n\t * @type HandlerList\n\t * @constructor\n\t */\n\tfunction HandlerList() {\n\t\tthis._list = [];\n\t}\n\t\n\tHandlerList.prototype = {\n\t\t/**\n\t\t * Adds function handler\n\t\t * @param {Function} fn Handler\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\n\t\t * <b>order</b> : (<code>Number</code>) – order in handler list. Handlers\n\t\t * with higher order value will be executed earlier.\n\t\t */\n\t\tadd: function(fn, options) {\n\t\t\tthis._list.push(_.extend({order: 0}, options || {}, {fn: fn}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes handler from list\n\t\t * @param {Function} fn\n\t\t */\n\t\tremove: function(fn) {\n\t\t\tthis._list = _.without(this._list, _.find(this._list, function(item) {\n\t\t\t\treturn item.fn === fn;\n\t\t\t}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handlers. By default, handlers \n\t\t * with the same <code>order</code> option returned in reverse order, \n\t\t * i.e. the latter function was added into the handlers list, the higher \n\t\t * it will be in the returned array \n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.sortBy(this._list, 'order').reverse();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handler functions\n\t\t * @returns {Array}\n\t\t */\n\t\tlistFn: function() {\n\t\t\treturn _.pluck(this.list(), 'fn');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Executes handler functions in their designated order. If function\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \n\t\t * handle passed <code>args</code>, the next function will be executed\n\t\t * and so on.\n\t\t * @param {Object} skipValue If function returns this value, execute \n\t\t * next handler.\n\t\t * @param {Array} args Arguments to pass to handler function\n\t\t * @returns {Boolean} Whether any of registered handlers performed\n\t\t * successfully  \n\t\t */\n\t\texec: function(skipValue, args) {\n\t\t\targs = args || [];\n\t\t\tvar result = null;\n\t\t\t_.find(this.list(), function(h) {\n\t\t\t\tresult = h.fn.apply(h, args);\n\t\t\t\tif (result !== skipValue)\n\t\t\t\t\treturn true;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Factory method that produces <code>HandlerList</code> instance\n\t\t * @returns {HandlerList}\n\t\t * @memberOf handlerList\n\t\t */\n\t\tcreate: function() {\n\t\t\treturn new HandlerList();\n\t\t}\n\t};\n});/**\n * Helper class for convenient token iteration\n */\nemmet.define('tokenIterator', function(require, _) {\n\t/**\n\t * @type TokenIterator\n\t * @param {Array} tokens\n\t * @type TokenIterator\n\t * @constructor\n\t */\n\tfunction TokenIterator(tokens) {\n\t\t/** @type Array */\n\t\tthis.tokens = tokens;\n\t\tthis._position = 0;\n\t\tthis.reset();\n\t}\n\t\n\tTokenIterator.prototype = {\n\t\tnext: function() {\n\t\t\tif (this.hasNext()) {\n\t\t\t\tvar token = this.tokens[++this._i];\n\t\t\t\tthis._position = token.start;\n\t\t\t\treturn token;\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\tcurrent: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\tposition: function() {\n\t\t\treturn this._position;\n\t\t},\n\t\t\n\t\thasNext: function() {\n\t\t\treturn this._i < this._il - 1;\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\tthis._i = -1;\n\t\t\tthis._il = this.tokens.length;\n\t\t},\n\t\t\n\t\titem: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\titemNext: function() {\n\t\t\treturn this.tokens[this._i + 1];\n\t\t},\n\t\t\n\t\titemPrev: function() {\n\t\t\treturn this.tokens[this._i - 1];\n\t\t},\n\t\t\n\t\tnextUntil: function(type, callback) {\n\t\t\tvar token;\n\t\t\tvar test = _.isString(type) \n\t\t\t\t? function(t){return t.type == type;} \n\t\t\t\t: type;\n\t\t\t\n\t\t\twhile (token = this.next()) {\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback.call(this, token);\n\t\t\t\tif (test.call(this, token))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(tokens) {\n\t\t\treturn new TokenIterator(tokens);\n\t\t}\n\t};\n});/**\n * A trimmed version of CodeMirror's StringStream module for string parsing\n */\nemmet.define('stringStream', function(require, _) {\n\t/**\n\t * @type StringStream\n\t * @constructor\n\t * @param {String} string\n\t */\n\tfunction StringStream(string) {\n\t\tthis.pos = this.start = 0;\n\t\tthis.string = string;\n\t}\n\t\n\tStringStream.prototype = {\n\t\t/**\n\t\t * Returns true only if the stream is at the end of the line.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teol: function() {\n\t\t\treturn this.pos >= this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns true only if the stream is at the start of the line\n\t\t * @returns {Boolean}\n\t\t */\n\t\tsol: function() {\n\t\t\treturn this.pos == 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream without advancing it. \n\t\t * Will return <code>undefined</code> at the end of the line.\n\t\t * @returns {String}\n\t\t */\n\t\tpeek: function() {\n\t\t\treturn this.string.charAt(this.pos);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream and advances it.\n\t\t * Also returns <code>undefined</code> when no more characters are available.\n\t\t * @returns {String}\n\t\t */\n\t\tnext: function() {\n\t\t\tif (this.pos < this.string.length)\n\t\t\t\treturn this.string.charAt(this.pos++);\n\t\t},\n\t\t\n\t\t/**\n\t\t * match can be a character, a regular expression, or a function that\n\t\t * takes a character and returns a boolean. If the next character in the\n\t\t * stream 'matches' the given argument, it is consumed and returned.\n\t\t * Otherwise, undefined is returned.\n\t\t * @param {Object} match\n\t\t * @returns {String}\n\t\t */\n\t\teat: function(match) {\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\n\t\t\tif (typeof match == \"string\")\n\t\t\t\tok = ch == match;\n\t\t\telse\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\n\t\t\t\n\t\t\tif (ok) {\n\t\t\t\t++this.pos;\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\n\t\t * @param {Object} match\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatWhile: function(match) {\n\t\t\tvar start = this.pos;\n\t\t\twhile (this.eat(match)) {}\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatSpace: function() {\n\t\t\tvar start = this.pos;\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n\t\t\t\t++this.pos;\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Moves the position to the end of the line.\n\t\t */\n\t\tskipToEnd: function() {\n\t\t\tthis.pos = this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to the next occurrence of the given character, if found on the\n\t\t * current line (doesn't advance the stream if the character does not\n\t\t * occur on the line). Returns true if the character was found.\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tskipTo: function(ch) {\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.pos = found;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\n\t\t * character, considering possible pair nesting. This function is used\n\t\t * to consume pair of characters, like opening and closing braces\n\t\t * @param {String} open\n\t\t * @param {String} close\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\n\t\t * consumed\n\t\t */\n\t\tskipToPair: function(open, close) {\n\t\t\tvar braceCount = 0, ch;\n\t\t\tvar pos = this.pos, len = this.string.length;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == open) {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == close) {\n\t\t\t\t\tbraceCount--;\n\t\t\t\t\tif (braceCount < 1) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Backs up the stream n characters. Backing it up further than the\n\t\t * start of the current token will cause things to break, so be careful.\n\t\t * @param {Number} n\n\t\t */\n\t\tbackUp : function(n) {\n\t\t\tthis.pos -= n;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Act like a multi-character <code>eat</code>—if <code>consume</code> is true or\n\t\t * not given—or a look-ahead that doesn't update the stream position—if\n\t\t * it is false. <code>pattern</code> can be either a string or a\n\t\t * regular expression starting with ^. When it is a string,\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\n\t\t * case-insensitive. When successfully matching a regular expression,\n\t\t * the returned value will be the array returned by <code>match</code>,\n\t\t * in case you need to extract matched groups.\n\t\t * \n\t\t * @param {RegExp} pattern\n\t\t * @param {Boolean} consume\n\t\t * @param {Boolean} caseInsensitive\n\t\t * @returns\n\t\t */\n\t\tmatch: function(pattern, consume, caseInsensitive) {\n\t\t\tif (typeof pattern == \"string\") {\n\t\t\t\tvar cased = caseInsensitive\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\n\t\t\t\t\t: function(str) {return str;};\n\t\t\t\t\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n\t\t\t\t\tif (consume !== false)\n\t\t\t\t\t\tthis.pos += pattern.length;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\n\t\t\t\tif (match && consume !== false)\n\t\t\t\t\tthis.pos += match[0].length;\n\t\t\t\treturn match;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Get the string between the start of the current token and the \n\t\t * current stream position.\n\t\t * @returns {String}\n\t\t */\n\t\tcurrent: function() {\n\t\t\treturn this.string.slice(this.start, this.pos);\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(string) {\n\t\t\treturn new StringStream(string);\n\t\t}\n\t};\n});/**\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n * Contains convenient method to get access for snippets with respect of \n * inheritance. Also provides ability to store data in different vocabularies\n * ('system' and 'user') for fast and safe resource update\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('resources', function(require, _) {\n\tvar VOC_SYSTEM = 'system';\n\tvar VOC_USER = 'user';\n\t\n\tvar cache = {};\n\t\t\n\t/** Regular expression for XML tag matching */\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\n\t\t\n\tvar systemSettings = {};\n\tvar userSettings = {};\n\t\n\t/** @type HandlerList List of registered abbreviation resolvers */\n\tvar resolvers = require('handlerList').create();\n\t\n\t/**\n\t * Normalizes caret plceholder in passed text: replaces | character with\n\t * default caret placeholder\n\t * @param {String} text\n\t * @returns {String}\n\t */\n\tfunction normalizeCaretPlaceholder(text) {\n\t\tvar utils = require('utils');\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\n\t}\n\t\n\tfunction parseItem(name, value, type) {\n\t\tvalue = normalizeCaretPlaceholder(value);\n\t\t\n\t\tif (type == 'snippets') {\n\t\t\treturn require('elements').create('snippet', value);\n\t\t}\n\t\t\n\t\tif (type == 'abbreviations') {\n\t\t\treturn parseAbbreviation(name, value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Parses single abbreviation\n\t * @param {String} key Abbreviation name\n\t * @param {String} value Abbreviation value\n\t * @return {Object}\n\t */\n\tfunction parseAbbreviation(key, value) {\n\t\tkey = require('utils').trim(key);\n\t\tvar elements = require('elements');\n\t\tvar m;\n\t\tif (m = reTag.exec(value)) {\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\n\t\t} else {\n\t\t\t// assume it's reference to another abbreviation\n\t\t\treturn elements.create('reference', value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Normalizes snippet key name for better fuzzy search\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction normalizeName(str) {\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Sets new unparsed data for specified settings vocabulary\n\t\t * @param {Object} data\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\n\t\t * @memberOf resources\n\t\t */\n\t\tsetVocabulary: function(data, type) {\n\t\t\tcache = {};\n\t\t\tif (type == VOC_SYSTEM)\n\t\t\t\tsystemSettings = data;\n\t\t\telse\n\t\t\t\tuserSettings = data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource vocabulary by its name\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\n\t\t * @return {Object}\n\t\t */\n\t\tgetVocabulary: function(name) {\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed \n\t\t * abbreviation\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetMatchedResource: function(node, syntax) {\n\t\t\treturn resolvers.exec(null, _.toArray(arguments)) \n\t\t\t\t|| this.findSnippet(syntax, node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns variable value\n\t\t * @return {String}\n\t\t */\n\t\tgetVariable: function(name) {\n\t\t\treturn (this.getSection('variables') || {})[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Store runtime variable in user storage\n\t\t * @param {String} name Variable name\n\t\t * @param {String} value Variable value\n\t\t */\n\t\tsetVariable: function(name, value){\n\t\t\tvar voc = this.getVocabulary('user') || {};\n\t\t\tif (!('variables' in voc))\n\t\t\t\tvoc.variables = {};\n\t\t\t\t\n\t\t\tvoc.variables[name] = value;\n\t\t\tthis.setVocabulary(voc, 'user');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if there are resources for specified syntax\n\t\t * @param {String} syntax\n\t\t * @return {Boolean}\n\t\t */\n\t\thasSyntax: function(syntax) {\n\t\t\treturn syntax in this.getVocabulary(VOC_USER) \n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers new abbreviation resolver.\n\t\t * @param {Function} fn Abbreviation resolver which will receive \n\t\t * abbreviation as first argument and should return parsed abbreviation\n\t\t * object if abbreviation has handled successfully, <code>null</code>\n\t\t * otherwise\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddResolver: function(fn, options) {\n\t\t\tresolvers.add(fn, options);\n\t\t},\n\t\t\n\t\tremoveResolver: function(fn) {\n\t\t\tresolvers.remove(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actual section data, merged from both\n\t\t * system and user data\n\t\t * @param {String} name Section name (syntax)\n\t\t * @param {String} ...args Subsections\n\t\t * @returns\n\t\t */\n\t\tgetSection: function(name) {\n\t\t\tif (!name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (!(name in cache)) {\n\t\t\t\tcache[name] = require('utils').deepMerge({}, systemSettings[name], userSettings[name]);\n\t\t\t}\n\t\t\t\n\t\t\tvar data = cache[name], subsections = _.rest(arguments), key;\n\t\t\twhile (data && (key = subsections.shift())) {\n\t\t\t\tif (key in data) {\n\t\t\t\t\tdata = data[key];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\n\t\t * with respect of `extends` attribute\n\t\t * @param {String} topSection Top section name (syntax)\n\t\t * @param {String} subsection Inner section name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindItem: function(topSection, subsection) {\n\t\t\tvar data = this.getSection(topSection);\n\t\t\twhile (data) {\n\t\t\t\tif (subsection in data)\n\t\t\t\t\treturn data[subsection];\n\t\t\t\t\n\t\t\t\tdata = this.getSection(data['extends']);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a snippet definition inside syntax section.\n\t\t * Definition is searched inside `snippets` and `abbreviations` \n\t\t * subsections  \n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindSnippet: function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tmemo = memo || [];\n\t\t\t\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-'))\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function(n) {\n\t\t\t\t\t\tif (data[n])\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\t\t\t\n\t\t\treturn matchedItem;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Performs fuzzy search of snippet definition\n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns\n\t\t */\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\n\t\t\tminScore = minScore || 0.3;\n\t\t\t\n\t\t\tvar payload = this.getAllSnippets(syntax);\n\t\t\tvar sc = require('string-score');\n\t\t\t\n\t\t\tname = normalizeName(name);\n\t\t\tvar scores = _.map(payload, function(value, key) {\n\t\t\t\treturn {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tscore: sc.score(value.nk, name, 0.1)\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tvar result = _.last(_.sortBy(scores, 'score'));\n\t\t\tif (result && result.score >= minScore) {\n\t\t\t\tvar k = result.key;\n\t\t\t\treturn payload[k].parsedValue;\n//\t\t\t\treturn parseItem(k, payload[k].value, payload[k].type);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns plain dictionary of all available abbreviations and snippets\n\t\t * for specified syntax with respect of inheritance\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAllSnippets: function(syntax) {\n\t\t\tvar cacheKey = 'all-' + syntax;\n\t\t\tif (!cache[cacheKey]) {\n\t\t\t\tvar stack = [], sectionKey = syntax;\n\t\t\t\tvar memo = [];\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\tvar section = this.getSection(sectionKey);\n\t\t\t\t\tif (!section)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t_.each(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\t\t\tvar stackItem = {};\n\t\t\t\t\t\t_.each(section[sectionName] || null, function(v, k) {\n\t\t\t\t\t\t\tstackItem[k] = {\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\n\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\n\t\t\t\t\t\t\t\ttype: sectionName\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tstack.push(stackItem);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tmemo.push(sectionKey);\n\t\t\t\t\tsectionKey = section['extends'];\n\t\t\t\t} while (sectionKey && !_.include(memo, sectionKey));\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcache[cacheKey] = _.extend.apply(_, stack.reverse());\n\t\t\t}\n\t\t\t\n\t\t\treturn cache[cacheKey];\n\t\t}\n\t};\n});/**\n * Module describes and performs Emmet actions. The actions themselves are\n * defined in <i>actions</i> folder\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('actions', function(require, _, zc) {\n\tvar actions = {};\n\t\n\t/**\n\t * “Humanizes” action name, makes it more readable for people\n\t * @param {String} name Action name (like 'expand_abbreviation')\n\t * @return Humanized name (like 'Expand Abbreviation')\n\t */\n\tfunction humanizeActionName(name) {\n\t\treturn require('utils').trim(name.charAt(0).toUpperCase() \n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\n\t\t\t}));\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Registers new action\n\t\t * @param {String} name Action name\n\t\t * @param {Function} fn Action function\n\t\t * @param {Object} options Custom action options:<br>\n\t\t * <b>label</b> : (<code>String</code>) – Human-readable action name. \n\t\t * May contain '/' symbols as submenu separators<br>\n\t\t * <b>hidden</b> : (<code>Boolean</code>) – Indicates whether action\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\n\t\t * \n\t\t * @memberOf actions\n\t\t */\n\t\tadd: function(name, fn, options) {\n\t\t\tname = name.toLowerCase();\n\t\t\toptions = options || {};\n\t\t\tif (!options.label) {\n\t\t\t\toptions.label = humanizeActionName(name);\n\t\t\t}\n\t\t\t\n\t\t\tactions[name] = {\n\t\t\t\tname: name,\n\t\t\t\tfn: fn,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns action object\n\t\t * @param {String} name Action name\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn actions[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Runs Emmet action. For list of available actions and their\n\t\t * arguments see <i>actions</i> folder.\n\t\t * @param {String} name Action name \n\t\t * @param {Array} args Additional arguments. It may be array of arguments\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\n\t\t * means action was performed successfully.\n\t\t * @example\n\t\t * emmet.require('actions').run('expand_abbreviation', editor);  \n\t\t * emmet.require('actions').run('wrap_with_abbreviation', [editor, 'div']);  \n\t\t */\n\t\trun: function(name, args) {\n\t\t\tif (!_.isArray(args)) {\n\t\t\t\targs = _.rest(arguments);\n\t\t\t}\n\t\t\t\n\t\t\tvar action = this.get(name);\n\t\t\tif (action) {\n\t\t\t\treturn action.fn.apply(emmet, args);\n\t\t\t} else {\n\t\t\t\temmet.log('Action \"%s\" is not defined', name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as object\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn actions;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as array\n\t\t * @returns {Array}\n\t\t */\n\t\tgetList: function() {\n\t\t\treturn _.values(this.getAll());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\n\t\t * it will be splitted by '/' symbol into submenus (for example: \n\t\t * CSS/Reflect Value) and grouped with other items\n\t\t * @param {Array} skipActions List of action identifiers that should be \n\t\t * skipped from menu\n\t\t * @returns {Array}\n\t\t */\n\t\tgetMenu: function(skipActions) {\n\t\t\tvar result = [];\n\t\t\tskipActions = skipActions || [];\n\t\t\t_.each(this.getList(), function(action) {\n\t\t\t\tif (action.options.hidden || _.include(skipActions, action.name))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar actionName = humanizeActionName(action.name);\n\t\t\t\tvar ctx = result;\n\t\t\t\tif (action.options.label) {\n\t\t\t\t\tvar parts = action.options.label.split('/');\n\t\t\t\t\tactionName = parts.pop();\n\t\t\t\t\t\n\t\t\t\t\t// create submenus, if needed\n\t\t\t\t\tvar menuName, submenu;\n\t\t\t\t\twhile (menuName = parts.shift()) {\n\t\t\t\t\t\tsubmenu = _.find(ctx, function(item) {\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!submenu) {\n\t\t\t\t\t\t\tsubmenu = {\n\t\t\t\t\t\t\t\tname: menuName,\n\t\t\t\t\t\t\t\ttype: 'submenu',\n\t\t\t\t\t\t\t\titems: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tctx.push(submenu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tctx = submenu.items;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.push({\n\t\t\t\t\ttype: 'action',\n\t\t\t\t\tname: action.name,\n\t\t\t\t\tlabel: actionName\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns action name associated with menu item title\n\t\t * @param {String} title\n\t\t * @returns {String}\n\t\t */\n\t\tgetActionNameForMenuTitle: function(title, menu) {\n\t\t\tvar item = null;\n\t\t\t_.find(menu || this.getMenu(), function(val) {\n\t\t\t\tif (val.type == 'action') {\n\t\t\t\t\tif (val.label == title || val.name == title) {\n\t\t\t\t\t\treturn item = val.name;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn item = this.getActionNameForMenuTitle(title, val.items);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn item || null;\n\t\t}\n\t};\n});/**\n * Output profile module.\n * Profile defines how XHTML output data should look like\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('profile', function(require, _) {\n\tvar profiles = {};\n\t\n\tvar defaultProfile = {\n\t\ttag_case: 'asis',\n\t\tattr_case: 'asis',\n\t\tattr_quotes: 'double',\n\t\t\n\t\t// each tag on new line\n\t\ttag_nl: 'decide',\n\t\t\n\t\t// with tag_nl === true, defines if leaf node (e.g. node with no children)\n\t\t// should have formatted line breaks\n\t\ttag_nl_leaf: false,\n\t\t\n\t\tplace_cursor: true,\n\t\t\n\t\t// indent tags\n\t\tindent: true,\n\t\t\n\t\t// how many inline elements should be to force line break \n\t\t// (set to 0 to disable)\n\t\tinline_break: 3,\n\t\t\n\t\t// use self-closing style for writing empty elements, e.g. <br /> or <br>\n\t\tself_closing_tag: 'xhtml',\n\t\t\n\t\t// Profile-level output filters, re-defines syntax filters \n\t\tfilters: '',\n\t\t\n\t\t// Additional filters applied to abbreviation.\n\t\t// Unlike \"filters\", this preference doesn't override default filters\n\t\t// but add the instead every time given profile is chosen\n\t\textraFilters: ''\n\t};\n\t\n\t/**\n\t * @constructor\n\t * @type OutputProfile\n\t * @param {Object} options\n\t */\n\tfunction OutputProfile(options) {\n\t\t_.extend(this, defaultProfile, options);\n\t}\n\t\n\tOutputProfile.prototype = {\n\t\t/**\n\t\t * Transforms tag name case depending on current profile settings\n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\ttagName: function(name) {\n\t\t\treturn stringCase(name, this.tag_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Transforms attribute name case depending on current profile settings \n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\tattributeName: function(name) {\n\t\t\treturn stringCase(name, this.attr_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns quote character for current profile\n\t\t * @returns {String}\n\t\t */\n\t\tattributeQuote: function() {\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns self-closing tag symbol for current profile\n\t\t * @param {String} param\n\t\t * @returns {String}\n\t\t */\n\t\tselfClosing: function(param) {\n\t\t\tif (this.self_closing_tag == 'xhtml')\n\t\t\t\treturn ' /';\n\t\t\t\n\t\t\tif (this.self_closing_tag === true)\n\t\t\t\treturn '/';\n\t\t\t\n\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns cursor token based on current profile settings\n\t\t * @returns {String}\n\t\t */\n\t\tcursor: function() {\n\t\t\treturn this.place_cursor ? require('utils').getCaretPlaceholder() : '';\n\t\t}\n\t};\n\t\n\t/**\n\t * Helper function that converts string case depending on \n\t * <code>caseValue</code> \n\t * @param {String} str String to transform\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t * <i>upper</i> and <i>leave</i>\n\t * @returns {String}\n\t */\n\tfunction stringCase(str, caseValue) {\n\t\tswitch (String(caseValue || '').toLowerCase()) {\n\t\t\tcase 'lower':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'upper':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n\t\n\t/**\n\t * Creates new output profile\n\t * @param {String} name Profile name\n\t * @param {Object} options Profile options\n\t */\n\tfunction createProfile(name, options) {\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\n\t}\n\t\n\tfunction createDefaultProfiles() {\n\t\tcreateProfile('xhtml');\n\t\tcreateProfile('html', {self_closing_tag: false});\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\n\t}\n\t\n\tcreateDefaultProfiles();\n\t\n\treturn  {\n\t\t/**\n\t\t * Creates new output profile and adds it into internal dictionary\n\t\t * @param {String} name Profile name\n\t\t * @param {Object} options Profile options\n\t\t * @memberOf emmet.profile\n\t\t * @returns {Object} New profile\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tif (arguments.length == 2)\n\t\t\t\treturn createProfile(name, options);\n\t\t\telse\n\t\t\t\t// create profile object only\n\t\t\t\treturn new OutputProfile(_.defaults(name || {}, defaultProfile));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns profile by its name. If profile wasn't found, returns\n\t\t * 'plain' profile\n\t\t * @param {String} name Profile name. Might be profile itself\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\n\t\t * profile is searched in resources first, then in predefined profiles\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name, syntax) {\n\t\t\tif (!name && syntax) {\n\t\t\t\t// search in user resources first\n\t\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\t\tif (profile) {\n\t\t\t\t\tname = profile;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!name) {\n\t\t\t\treturn profiles.plain;\n\t\t\t}\n\t\t\t\n\t\t\tif (name instanceof OutputProfile) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(name) && name.toLowerCase() in profiles) {\n\t\t\t\treturn profiles[name.toLowerCase()];\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Deletes profile with specified name\n\t\t * @param {String} name Profile name\n\t\t */\n\t\tremove: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\tif (name in profiles)\n\t\t\t\tdelete profiles[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets all user-defined profiles\n\t\t */\n\t\treset: function() {\n\t\t\tprofiles = {};\n\t\t\tcreateDefaultProfiles();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that converts string case depending on \n\t\t * <code>caseValue</code> \n\t\t * @param {String} str String to transform\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t\t * <i>upper</i> and <i>leave</i>\n\t\t * @returns {String}\n\t\t */\n\t\tstringCase: stringCase\n\t};\n});/**\n * Utility module used to prepare text for pasting into back-end editor\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('editorUtils', function(require, _) {\n\treturn  {\n\t\t/**\n\t\t * Check if cursor is placed inside XHTML tag\n\t\t * @param {String} html Contents of the document\n\t\t * @param {Number} caretPos Current caret position inside tag\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInsideTag: function(html, caretPos) {\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\n\t\t\t\n\t\t\t// search left to find opening brace\n\t\t\tvar pos = caretPos;\n\t\t\twhile (pos > -1) {\n\t\t\t\tif (html.charAt(pos) == '<') \n\t\t\t\t\tbreak;\n\t\t\t\tpos--;\n\t\t\t}\n\t\t\t\n\t\t\tif (pos != -1) {\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sanitizes incoming editor data and provides default values for\n\t\t * output-specific info\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {String} syntax\n\t\t * @param {String} profile\n\t\t */\n\t\toutputInfo: function(editor, syntax, profile) {\n\t\t\t// most of this code makes sense for Java/Rhino environment\n\t\t\t// because string that comes from Java are not actually JS string\n\t\t\t// but Java String object so the have to be explicitly converted\n\t\t\t// to native string\n\t\t\tprofile = profile || editor.getProfileName();\n\t\t\treturn  {\n\t\t\t\t/** @memberOf outputInfo */\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\n\t\t\t\tprofile: profile || null,\n\t\t\t\tcontent: String(editor.getContent())\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unindent content, thus preparing text for tag wrapping\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunindent: function(editor, text) {\n\t\t\treturn require('utils').unindentString(text, this.getCurrentLinePadding(editor));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns padding of current editor's line\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tgetCurrentLinePadding: function(editor) {\n\t\t\treturn require('utils').getLinePadding(editor.getCurrentLine());\n\t\t}\n\t};\n});\n/**\n * Utility methods for Emmet actions\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('actionUtils', function(require, _) {\n\treturn {\n\t\tmimeTypes: {\n\t\t\t'gif' : 'image/gif',\n\t\t\t'png' : 'image/png',\n\t\t\t'jpg' : 'image/jpeg',\n\t\t\t'jpeg': 'image/jpeg',\n\t\t\t'svg' : 'image/svg+xml',\n\t\t\t'html': 'text/html',\n\t\t\t'htm' : 'text/html'\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts abbreviations from text stream, starting from the end\n\t\t * @param {String} str\n\t\t * @return {String} Abbreviation or empty string\n\t\t * @memberOf emmet.actionUtils\n\t\t */\n\t\textractAbbreviation: function(str) {\n\t\t\tvar curOffset = str.length;\n\t\t\tvar startIndex = -1;\n\t\t\tvar groupCount = 0;\n\t\t\tvar braceCount = 0;\n\t\t\tvar textCount = 0;\n\t\t\t\n\t\t\tvar utils = require('utils');\n\t\t\tvar parser = require('abbreviationParser');\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tcurOffset--;\n\t\t\t\tif (curOffset < 0) {\n\t\t\t\t\t// moved to the beginning of the line\n\t\t\t\t\tstartIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ch = str.charAt(curOffset);\n\t\t\t\t\n\t\t\t\tif (ch == ']') {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == '[') {\n\t\t\t\t\tif (!braceCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbraceCount--;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\ttextCount++;\n\t\t\t\t} else if (ch == '{') {\n\t\t\t\t\tif (!textCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttextCount--;\n\t\t\t\t} else if (ch == ')') {\n\t\t\t\t\tgroupCount++;\n\t\t\t\t} else if (ch == '(') {\n\t\t\t\t\tif (!groupCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgroupCount--;\n\t\t\t\t} else {\n\t\t\t\t\tif (braceCount || textCount) \n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (!parser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\n\t\t\t\t\t\t// found stop symbol\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \n\t\t\t\t// found something, remove some invalid symbols from the \n\t\t\t\t// beginning and return abbreviation\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\t\telse\n\t\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Gets image size from image byte stream.\n\t\t * @author http://romeda.org/rePublish/\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\n\t\t */\n\t\tgetImageSize: function(stream) {\n\t\t\tvar pngMagicNum = \"\\211PNG\\r\\n\\032\\n\",\n\t\t\t\tjpgMagicNum = \"\\377\\330\",\n\t\t\t\tgifMagicNum = \"GIF8\",\n\t\t\t\tnextByte = function() {\n\t\t\t\t\treturn stream.charCodeAt(pos++);\n\t\t\t\t};\n\t\t\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\n\t\t\t\t// PNG. Easy peasy.\n\t\t\t\tvar pos = stream.indexOf('IHDR') + 4;\n\t\t\t\n\t\t\t\treturn { width:  (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte(),\n\t\t\t\t\t\t height: (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte() };\n\t\t\t\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\n\t\t\t\tpos = 6;\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\n\t\t\t\t};\n\t\t\t\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\n\t\t\t\tpos = 2;\n\t\t\t\n\t\t\t\tvar l = stream.length;\n\t\t\t\twhile (pos < l) {\n\t\t\t\t\tif (nextByte() != 0xFF) return;\n\t\t\t\t\n\t\t\t\t\tvar marker = nextByte();\n\t\t\t\t\tif (marker == 0xDA) break;\n\t\t\t\t\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\n\t\t\t\t\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\treturn { height:  (nextByte() << 8) | nextByte(),\n\t\t\t\t\t\t\t\t width: (nextByte() << 8) | nextByte() };\n\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += size - 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Captures context XHTML element from editor under current caret position.\n\t\t * This node can be used as a helper for abbreviation extraction\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Object}\n\t\t */\n\t\tcaptureContext: function(editor) {\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1};\n\t\t\tvar syntax = String(editor.getSyntax());\n\t\t\tif (syntax in allowedSyntaxes) {\n\t\t\t\tvar content = String(editor.getContent());\n\t\t\t\tvar tag = require('htmlMatcher').find(content, editor.getCaretPos());\n\t\t\t\t\n\t\t\t\tif (tag && tag.type == 'tag') {\n\t\t\t\t\tvar startTag = tag.open;\n\t\t\t\t\tvar contextNode = {\n\t\t\t\t\t\tname: startTag.name,\n\t\t\t\t\t\tattributes: []\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// parse attributes\n\t\t\t\t\tvar tagTree = require('xmlEditTree').parse(startTag.range.substring(content));\n\t\t\t\t\tif (tagTree) {\n\t\t\t\t\t\tcontextNode.attributes = _.map(tagTree.getAll(), function(item) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: item.name(),\n\t\t\t\t\t\t\t\tvalue: item.value()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn contextNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find expression bounds in current editor at caret position. \n\t\t * On each character a <code>fn</code> function will be called and must \n\t\t * return <code>true</code> if current character meets requirements, \n\t\t * <code>false</code> otherwise\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Function} fn Function to test each character of expression\n\t\t * @return {Range}\n\t\t */\n\t\tfindExpressionBounds: function(editor, fn) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar il = content.length;\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\n\t\t\tvar exprEnd = exprStart + 1;\n\t\t\t\t\n\t\t\t// start by searching left\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\n\t\t\t\n\t\t\t// then search right\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\n\t\t\t\n\t\t\tif (exprEnd > exprStart) {\n\t\t\t\treturn require('range').create([++exprStart, exprEnd]);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Object} data\n\t\t * @returns {Boolean}\n\t\t */\n\t\tcompoundUpdate: function(editor, data) {\n\t\t\tif (data) {\n\t\t\t\tvar sel = editor.getSelectionRange();\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common syntax detection method for editors that doesn’t provide any\n\t\t * info about current syntax scope. \n\t\t * @param {IEmmetEditor} editor Current editor\n\t\t * @param {String} hint Any syntax hint that editor can provide \n\t\t * for syntax detection. Default is 'html'\n\t\t * @returns {String} \n\t\t */\n\t\tdetectSyntax: function(editor, hint) {\n\t\t\tvar syntax = hint || 'html';\n\t\t\t\n\t\t\tif (!require('resources').hasSyntax(syntax)) {\n\t\t\t\tsyntax = 'html';\n\t\t\t}\n\t\t\t\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\n\t\t\t\tsyntax = 'css';\n\t\t\t}\n\t\t\t\n\t\t\treturn syntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common method for detecting output profile\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {String}\n\t\t */\n\t\tdetectProfile: function(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\t\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tvar profile = require('resources').getVariable('profile');\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Tries to detect if current document is XHTML one.\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisXHTML: function(editor) {\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside &lt;style&gt; tag\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns\n\t\t */\n\t\tisStyle: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(content, caretPos);\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \n\t\t\t\t&& tag.innerRange.cmp(caretPos, 'lte', 'gte');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\n\t\t * element\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineCSS: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tree = require('xmlEditTree').parseFromPosition(content, caretPos, true);\n            if (tree) {\n                var attr = tree.itemFromPosition(caretPos, true);\n                return attr && attr.name().toLowerCase() == 'style' \n                \t&& attr.valueRange(true).cmp(caretPos, 'lte', 'gte');\n            }\n            \n            return false;\n\t\t}\n\t};\n});/**\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationUtils', function(require, _) {\n\treturn {\n\t\t/**\n\t\t * Check if passed abbreviation node has matched snippet resource\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t * @memberOf abbreviationUtils\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is unary (no closing tag)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisUnary: function(node) {\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar r = node.matchedResource();\n\t\t\treturn r && r.is_empty;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInline: function(node) {\n\t\t\treturn node.isTextNode() \n\t\t\t\t|| !node.name() \n\t\t\t\t|| require('tagName').isInlineLevel(node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is block-level\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBlock: function(node) {\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if given node is a snippet\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function tests if passed node content contains HTML tags. \n\t\t * This function is mostly used for output formatting\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasTagsInContent: function(node) {\n\t\t\treturn require('utils').matchesTag(node.content);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if current element contains block-level children\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasBlockChildren: function(node) {\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \n\t\t\t\t|| _.any(node.children, function(child) {\n\t\t\t\t\treturn this.isBlock(child);\n\t\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Utility function that inserts content instead of <code>${child}</code>\n\t\t * variables on <code>text</code>\n\t\t * @param {String} text Text where child content should be inserted\n\t\t * @param {String} childContent Content to insert\n\t\t * @param {Object} options\n\t\t * @returns {String\n\t\t */\n\t\tinsertChildContent: function(text, childContent, options) {\n\t\t\toptions = _.extend({\n\t\t\t\tkeepVariable: true,\n\t\t\t\tappendIfNoChild: true\n\t\t\t}, options || {});\n\t\t\t\n\t\t\tvar childVariableReplaced = false;\n\t\t\tvar utils = require('utils');\n\t\t\ttext = utils.replaceVariables(text, function(variable, name, data) {\n\t\t\t\tvar output = variable;\n\t\t\t\tif (name == 'child') {\n\t\t\t\t\t// add correct indentation\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\n\t\t\t\t\tchildVariableReplaced = true;\n\t\t\t\t\tif (options.keepVariable)\n\t\t\t\t\t\toutput += variable;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn output;\n\t\t\t});\n\t\t\t\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\n\t\t\t\ttext += childContent;\n\t\t\t}\n\t\t\t\n\t\t\treturn text;\n\t\t}\n\t};\n});/**\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.define('base64', function(require, _) {\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t\n\treturn {\n\t\t/**\n\t\t * Encodes data using base64 algorithm\n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} input\n\t\t * @returns {String}\n\t\t * @memberOf emmet.base64\n\t\t */\n\t\tencode : function(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0, il = input.length, b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t},\n\n\t\t/**\n\t\t * Decodes string using MIME base64 algorithm\n\t\t * \n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} data\n\t\t * @return {String}\n\t\t */\n\t\tdecode : function(data) {\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\n\t\t\tvar b64 = chars, il = data.length;\n\n\t\t\tif (!data) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tdata += '';\n\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\n\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n\t\t\t\to1 = bits >> 16 & 0xff;\n\t\t\t\to2 = bits >> 8 & 0xff;\n\t\t\t\to3 = bits & 0xff;\n\n\t\t\t\tif (h3 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\n\t\t\t\t} else if (h4 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\n\t\t\t\t} else {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\n\t\t\t\t}\n\t\t\t} while (i < il);\n\n\t\t\treturn tmpArr.join('');\n\t\t}\n\t};\n});/**\n * HTML matcher: takes string and searches for HTML tag pairs for given position \n * \n * Unlike “classic” matchers, it parses content from the specified \n * position, not from the start, so it may work even outside HTML documents\n * (for example, inside strings of programming languages like JavaScript, Python \n * etc.)\n * @constructor\n * @memberOf __htmlMatcherDefine\n */\nemmet.define('htmlMatcher', function(require, _) {\n\t// Regular Expressions for parsing tags and attributes\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\n\t\n\tfunction openTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\tselfClose: !!match[3],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'open'\n\t\t};\n\t}\n\t\n\tfunction closeTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'close'\n\t\t};\n\t}\n\t\n\tfunction comment(i, match) {\n\t\treturn {\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, _.isNumber(match) ? match - i : match[0]),\n\t\t\ttype: 'comment'\n\t\t};\n\t}\n\t\n\t/**\n\t * Creates new tag matcher session\n\t * @param {String} text\n\t */\n\tfunction createMatcher(text) {\n\t\tvar memo = {}, m;\n\t\treturn {\n\t\t\t/**\n\t\t\t * Test if given position matches opening tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\topen: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'open' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Test if given position matches closing tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\tclose: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'close' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Matches either opening or closing tag for given position\n\t\t\t * @param i\n\t\t\t * @returns\n\t\t\t */\n\t\t\tmatches: function(i) {\n\t\t\t\tvar key = 'p' + i;\n\t\t\t\t\n\t\t\t\tif (!(key in memo)) {\n\t\t\t\t\tif (text.charAt(i) == '<') {\n\t\t\t\t\t\tvar substr = text.slice(i);\n\t\t\t\t\t\tif (m = substr.match(reOpenTag)) {\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\n\t\t\t\t\t\t} else if (m = substr.match(reCloseTag)) {\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// remember that given position contains no valid tag\n\t\t\t\t\t\t\tmemo[key] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn memo[key];\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Returns original text\n\t\t\t * @returns {String}\n\t\t\t */\n\t\t\ttext: function() {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction matches(text, pos, pattern) {\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\n\t}\n\t\n\t/**\n\t * Search for closing pair of opening tag\n\t * @param {Object} open Open tag instance\n\t * @param {Object} matcher Matcher instance\n\t */\n\tfunction findClosingPair(open, matcher) {\n\t\tvar stack = [], tag = null;\n\t\tvar text = matcher.text();\n\t\t\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\n\t\t\tif (matches(text, pos, '<!--')) {\n\t\t\t\t// skip to end of comment\n\t\t\t\tfor (var j = pos; j < len; j++) {\n\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\tpos = j + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (tag = matcher.matches(pos)) {\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\n\t\t\t\t\tstack.push(tag.name);\n\t\t\t\t} else if (tag.type == 'close') {\n\t\t\t\t\tif (!stack.length) { // found valid pair?\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// check if current closing tag matches previously opened one\n\t\t\t\t\tif (_.last(stack) == tag.name) {\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\twhile (stack.length && !found) {\n\t\t\t\t\t\t\tvar last = stack.pop();\n\t\t\t\t\t\t\tif (last == tag.name) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!stack.length && !found) {\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Main function: search for tag pair in <code>text</code> for given \n\t\t * position\n\t\t * @memberOf htmlMatcher\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\tfind: function(text, pos) {\n\t\t\tvar range = require('range');\n\t\t\tvar matcher = createMatcher(text); \n\t\t\tvar open = null, close = null;\n\t\t\t\n\t\t\tfor (var i = pos; i >= 0; i--) {\n\t\t\t\tif (open = matcher.open(i)) {\n\t\t\t\t\t// found opening tag\n\t\t\t\t\tif (open.selfClose) {\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\n\t\t\t\t\t\t\t// inside self-closing tag, found match\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// outside self-closing tag, continue\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclose = findClosingPair(open, matcher);\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// found closing tag.\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\n\t\t\t\t\t\tif (r.contains(pos)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (open.range.contains(pos)) {\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = null;\n\t\t\t\t} else if (matches(text, i, '-->')) {\n\t\t\t\t\t// skip back to comment start\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\t// found another comment end, do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (matches(text, i, '<!--')) {\n\t\t\t\t\t// we're inside comment, match it\n\t\t\t\t\tvar j = i + 4, jl = text.length;\n\t\t\t\t\tfor (; j < jl; j++) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\tj += 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = comment(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (open) {\n\t\t\t\tvar outerRange = null;\n\t\t\t\tvar innerRange = null;\n\t\t\t\t\n\t\t\t\tif (close) {\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (open.type == 'comment') {\n\t\t\t\t\t// adjust positions of inner range for comment\n\t\t\t\t\tvar _c = outerRange.substring(text);\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\topen: open,\n\t\t\t\t\tclose: close,\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\n\t\t\t\t\tinnerRange: innerRange,\n\t\t\t\t\tinnerContent: function() {\n\t\t\t\t\t\treturn this.innerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\touterRange: outerRange,\n\t\t\t\t\touterContent: function() {\n\t\t\t\t\t\treturn this.outerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\n\t\t\t\t\tcontent: function() {\n\t\t\t\t\t\treturn this.range.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\tsource: text\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * The same as <code>find()</code> method, but restricts matched result \n\t\t * to <code>tag</code> type\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\ttag: function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Utility module for handling tabstops tokens generated by Emmet's \n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \n * occurrences, replace them with tokens suitable for your editor of choice and \n * return object with processed text and list of found tabstops and their ranges.\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \n * sorted array with plain objects.\n * \n * Placeholders with the same are meant to be <i>linked</i> in your editor.\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('tabStops', function(require, _) {\n\t/**\n\t * Global placeholder value, automatically incremented by \n\t * <code>variablesResolver()</code> function\n\t */\n\tvar startPlaceholderNum = 100;\n\t\n\tvar tabstopIndex = 0;\n\t\n\tvar defaultOptions = {\n\t\treplaceCarets: false,\n\t\tescape: function(ch) {\n\t\t\treturn '\\\\' + ch;\n\t\t},\n\t\ttabstop: function(data) {\n\t\t\treturn data.token;\n\t\t},\n\t\tvariable: function(data) {\n\t\t\treturn data.token;\n\t\t}\n\t};\n\t\n\t// XXX register output processor that will upgrade tabstops of parsed node\n\t// in order to prevent tabstop index conflicts\n\trequire('abbreviationParser').addOutputProcessor(function(text, node, type) {\n\t\tvar maxNum = 0;\n\t\tvar tabstops = require('tabStops');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar tsOptions = {\n\t\t\ttabstop: function(data) {\n\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\tif (group == 0)\n\t\t\t\t\treturn '${0}';\n\t\t\t\t\n\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\tif (data.placeholder) {\n\t\t\t\t\t// respect nested placeholders\n\t\t\t\t\tvar ix = group + tabstopIndex;\n\t\t\t\t\tvar placeholder = tabstops.processText(data.placeholder, tsOptions);\n\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t// upgrade tabstops\n\t\ttext = tabstops.processText(text, tsOptions);\n\t\t\n\t\t// resolve variables\n\t\ttext = utils.replaceVariables(text, tabstops.variablesResolver(node));\n\t\t\n\t\ttabstopIndex += maxNum + 1;\n\t\treturn text;\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\n\t\t * and returns a processed version of <code>text</code> with expanded \n\t\t * placeholders and list of tabstops found.\n\t\t * @param {String} text Text to process\n\t\t * @param {Object} options List of processor options:<br>\n\t\t * \n\t\t * <b>replaceCarets</b> : <code>Boolean</code> — replace all default\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\n\t\t * \n\t\t * <b>escape</b> : <code>Function</code> — function that handle escaped\n\t\t * characters (mostly '$'). By default, it returns the character itself \n\t\t * to be displayed as is in output, but sometimes you will use \n\t\t * <code>extract</code> method as intermediate solution for further \n\t\t * processing and want to keep character escaped. Thus, you should override\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\n\t\t * \n\t\t * <b>tabstop</b> : <code>Function</code> – a tabstop handler. Receives \n\t\t * a single argument – an object describing token: its position, number \n\t\t * group, placeholder and token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * <b>variable</b> : <code>Function</code> – variable handler. Receives \n\t\t * a single argument – an object describing token: its position, name \n\t\t * and original token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * @returns {Object} Object with processed <code>text</code> property\n\t\t * and array of <code>tabstops</code> found\n\t\t * @memberOf tabStops\n\t\t */\n\t\textract: function(text, options) {\n\t\t\t// prepare defaults\n\t\t\tvar utils = require('utils');\n\t\t\tvar placeholders = {carets: ''};\n\t\t\tvar marks = [];\n\t\t\t\n\t\t\toptions = _.extend({}, defaultOptions, options, {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar token = data.token;\n\t\t\t\t\tvar ret = '';\n\t\t\t\t\tif (data.placeholder == 'cursor') {\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: 'carets',\n\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unify placeholder value for single group\n\t\t\t\t\t\tif ('placeholder' in data)\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.group in placeholders)\n\t\t\t\t\t\t\tret = placeholders[data.group];\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: data.group,\n\t\t\t\t\t\t\tvalue: ret\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif (options.replaceCarets) {\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\n\t\t\t}\n\t\t\t\n\t\t\t// locate tabstops and unify group's placeholders\n\t\t\ttext = this.processText(text, options);\n\t\t\t\n\t\t\t// now, replace all tabstops with placeholders\n\t\t\tvar buf = utils.stringBuilder(), lastIx = 0;\n\t\t\tvar tabStops = _.map(marks, function(mark) {\n\t\t\t\tbuf.append(text.substring(lastIx, mark.start));\n\t\t\t\t\n\t\t\t\tvar pos = buf.length;\n\t\t\t\tvar ph = placeholders[mark.group] || '';\n\t\t\t\t\n\t\t\t\tbuf.append(ph);\n\t\t\t\tlastIx = mark.end;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tgroup: mark.group,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend:  pos + ph.length\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tbuf.append(text.substring(lastIx));\n\t\t\t\n\t\t\treturn {\n\t\t\t\ttext: buf.toString(),\n\t\t\t\ttabstops: _.sortBy(tabStops, 'start')\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Text processing routine. Locates escaped characters and tabstops and\n\t\t * replaces them with values returned by handlers defined in \n\t\t * <code>options</code>\n\t\t * @param {String} text\n\t\t * @param {Object} options See <code>extract</code> method options \n\t\t * description\n\t\t * @returns {String}\n\t\t */\n\t\tprocessText: function(text, options) {\n\t\t\toptions = _.extend({}, defaultOptions, options);\n\t\t\t\n\t\t\tvar buf = require('utils').stringBuilder();\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(text);\n\t\t\tvar ch, m, a;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\n\t\t\t\t\t// handle escaped character\n\t\t\t\t\tbuf.append(options.escape(stream.next()));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = ch;\n\t\t\t\t\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\t// looks like a tabstop\n\t\t\t\t\tstream.start = stream.pos - 1;\n\t\t\t\t\t\n\t\t\t\t\tif (m = stream.match(/^[0-9]+/)) {\n\t\t\t\t\t\t// it's $N\n\t\t\t\t\t\ta = options.tabstop({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/)) {\n\t\t\t\t\t\t// ${variable}\n\t\t\t\t\t\ta = options.variable({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false)) {\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\n\t\t\t\t\t\t// parse placeholder, including nested ones\n\t\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (placeholder) {\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ta = options.tabstop(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbuf.append(a);\n\t\t\t}\n\t\t\t\n\t\t\treturn buf.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {Number} offset Tab index offset\n\t\t * @returns {Number} Maximum tabstop index in element\n\t\t */\n\t\tupgrade: function(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\t\t\n\t\t\t\t\tif (data.placeholder)\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\n\t\t\t\t\telse\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t_.each(['start', 'end', 'content'], function(p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn maxNum;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that produces a callback function for \n\t\t * <code>replaceVariables()</code> method from {@link utils}\n\t\t * module. This callback will replace variable definitions (like \n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\n\t\t * or outputs tabstop with variable name otherwise.\n\t\t * @param {AbbreviationNode} node Context node\n\t\t * @returns {Function}\n\t\t */\n\t\tvariablesResolver: function(node) {\n\t\t\tvar placeholderMemo = {};\n\t\t\tvar res = require('resources');\n\t\t\treturn function(str, varName) {\n\t\t\t\t// do not mark `child` variable as placeholder – it‘s a reserved\n\t\t\t\t// variable name\n\t\t\t\tif (varName == 'child')\n\t\t\t\t\treturn str;\n\t\t\t\t\n\t\t\t\tif (varName == 'cursor')\n\t\t\t\t\treturn require('utils').getCaretPlaceholder();\n\t\t\t\t\n\t\t\t\tvar attr = node.attribute(varName);\n\t\t\t\tif (!_.isUndefined(attr) && attr !== str) {\n\t\t\t\t\treturn attr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar varValue = res.getVariable(varName);\n\t\t\t\tif (varValue)\n\t\t\t\t\treturn varValue;\n\t\t\t\t\n\t\t\t\t// output as placeholder\n\t\t\t\tif (!placeholderMemo[varName])\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\n\t\t\t\t\t\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets global tabstop index. When parsed tree is converted to output\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \n\t\t * defined in snippets and elements are upgraded in order to prevent\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\n\t\t * should not be linked with the same placehilder of the child node.\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\n\t\t * upgrades tabstops of the same index for each node and writes maximum\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\n\t\t * this variable at reasonable value, it is recommended to call \n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \n\t\t * @returns\n\t\t */\n\t\tresetTabstopIndex: function() {\n\t\t\ttabstopIndex = 0;\n\t\t\tstartPlaceholderNum = 100;\n\t\t}\n\t};\n});/**\n * Common module's preferences storage. This module \n * provides general storage for all module preferences, their description and\n * default values.<br><br>\n * \n * This module can also be used to list all available properties to create \n * UI for updating properties\n * \n * @memberOf __preferencesDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('preferences', function(require, _) {\n\tvar preferences = {};\n\tvar defaults = {};\n\tvar _dbgDefaults = null;\n\tvar _dbgPreferences = null;\n\n\tfunction toBoolean(val) {\n\t\tif (_.isString(val)) {\n\t\t\tval = val.toLowerCase();\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\n\t\t}\n\n\t\treturn !!val;\n\t}\n\t\n\tfunction isValueObj(obj) {\n\t\treturn _.isObject(obj) \n\t\t\t&& 'value' in obj \n\t\t\t&& _.keys(obj).length < 3;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new preference item with default value\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @param {String} description Item textual description\n\t\t * @memberOf preferences\n\t\t */\n\t\tdefine: function(name, value, description) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tdescription: description\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Updates preference item value. Preference value should be defined\n\t\t * first with <code>define</code> method.\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @memberOf preferences\n\t\t */\n\t\tset: function(name, value) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = value;\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tif (!(k in defaults)) {\n\t\t\t\t\tthrow 'Property \"' + k + '\" is not defined. You should define it first with `define` method of current module';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// do not set value if it equals to default value\n\t\t\t\tif (v !== defaults[k].value) {\n\t\t\t\t\t// make sure we have value of correct type\n\t\t\t\t\tswitch (typeof defaults[k].value) {\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tv = toBoolean(v);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: // convert to string\n\t\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\t\tv += '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpreferences[k] = v;\n\t\t\t\t} else if  (k in preferences) {\n\t\t\t\t\tdelete preferences[k];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns preference value\n\t\t * @param {String} name\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \n\t\t * not defined\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (name in preferences)\n\t\t\t\treturn preferences[name];\n\t\t\t\n\t\t\tif (name in defaults)\n\t\t\t\treturn defaults[name].value;\n\t\t\t\n\t\t\treturn void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma-separated preference value as array of values\n\t\t * @param {String} name\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \n\t\t * not defined, <code>null</code> if string cannot be converted to array\n\t\t */\n\t\tgetArray: function(name) {\n\t\t\tvar val = this.get(name);\n\t\t\tif (_.isUndefined(val) || val === null || val === '')  {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tval = _.map(val.split(','), require('utils').trim);\n\t\t\tif (!val.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn val;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma and colon-separated preference value as dictionary\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetDict: function(name) {\n\t\t\tvar result = {};\n\t\t\t_.each(this.getArray(name), function(val) {\n\t\t\t\tvar parts = val.split(':');\n\t\t\t\tresult[parts[0]] = parts[1];\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns description of preference item\n\t\t * @param {String} name Preference name\n\t\t * @returns {Object}\n\t\t */\n\t\tdescription: function(name) {\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Completely removes specified preference(s)\n\t\t * @param {String} name Preference name (or array of names)\n\t\t */\n\t\tremove: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t_.each(name, function(key) {\n\t\t\t\tif (key in preferences)\n\t\t\t\t\tdelete preferences[key];\n\t\t\t\t\n\t\t\t\tif (key in defaults)\n\t\t\t\t\tdelete defaults[key];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns sorted list of all available properties\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.map(_.keys(defaults).sort(), function(key) {\n\t\t\t\treturn {\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: this.get(key),\n\t\t\t\t\ttype: typeof defaults[key].value,\n\t\t\t\t\tdescription: defaults[key].description\n\t\t\t\t};\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Loads user-defined preferences from JSON\n\t\t * @param {Object} json\n\t\t * @returns\n\t\t */\n\t\tload: function(json) {\n\t\t\t_.each(json, function(value, key) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n\t\t * Returns hash of user-modified preferences\n\t\t * @returns {Object}\n\t\t */\n\t\texportModified: function() {\n\t\t\treturn _.clone(preferences);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Reset to defaults\n\t\t * @returns\n\t\t */\n\t\treset: function() {\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: use empty storage\n\t\t */\n\t\t_startTest: function() {\n\t\t\t_dbgDefaults = defaults;\n\t\t\t_dbgPreferences = preferences;\n\t\t\tdefaults = {};\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: restore original storage\n\t\t */\n\t\t_stopTest: function() {\n\t\t\tdefaults = _dbgDefaults;\n\t\t\tpreferences = _dbgPreferences;\n\t\t}\n\t};\n});/**\n * Module for handling filters\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('filters', function(require, _) {\n\t/** List of registered filters */\n\tvar registeredFilters = {};\n\t\n\t/** Filters that will be applied for unknown syntax */\n\tvar basicFilters = 'html';\n\t\n\tfunction list(filters) {\n\t\tif (!filters)\n\t\t\treturn [];\n\t\t\n\t\tif (_.isString(filters))\n\t\t\treturn filters.split(/[\\|,]/g);\n\t\t\n\t\treturn filters;\n\t}\n\t\n\treturn  {\n\t\t/**\n\t\t * Register new filter\n\t\t * @param {String} name Filter name\n\t\t * @param {Function} fn Filter function\n\t\t */\n\t\tadd: function(name, fn) {\n\t\t\tregisteredFilters[name] = fn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Apply filters for final output tree\n\t\t * @param {AbbreviationNode} tree Output tree\n\t\t * @param {Array} filters List of filters to apply. Might be a \n\t\t * <code>String</code>\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \n\t\t * module. Filters defined it profile are not used, <code>profile</code>\n\t\t * is passed to filter function\n\t\t * @memberOf emmet.filters\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tapply: function(tree, filters, profile) {\n\t\t\tvar utils = require('utils');\n\t\t\tprofile = require('profile').get(profile);\n\t\t\t\n\t\t\t_.each(list(filters), function(filter) {\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\n\t\t\t\tif (name && name in registeredFilters) {\n\t\t\t\t\ttree = registeredFilters[name](tree, profile);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Composes list of filters that should be applied to a tree, based on \n\t\t * passed data\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\n\t\t * @param {Object} profile Output profile\n\t\t * @param {String} additionalFilters List or pipe-separated\n\t\t * string of additional filters to apply\n\t\t * @returns {Array}\n\t\t */\n\t\tcomposeList: function(syntax, profile, additionalFilters) {\n\t\t\tprofile = require('profile').get(profile);\n\t\t\tvar filters = list(profile.filters || require('resources').findItem(syntax, 'filters') || basicFilters);\n\t\t\t\n\t\t\tif (profile.extraFilters) {\n\t\t\t\tfilters = filters.concat(list(profile.extraFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (additionalFilters) {\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (!filters || !filters.length) {\n\t\t\t\t// looks like unknown syntax, apply basic filters\n\t\t\t\tfilters = list(basicFilters);\n\t\t\t}\n\t\t\t\t\n\t\t\treturn filters;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts filter list from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \n\t\t * extracted filters\n\t\t */\n\t\textractFromAbbreviation: function(abbr) {\n\t\t\tvar filters = '';\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\n\t\t\t\tfilters = p1;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\treturn [abbr, list(filters)];\n\t\t}\n\t};\n});/**\n * Module that contains factories for element types used by Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('elements', function(require, _) {\n\tvar factories = {};\n\tvar reAttrs = /([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\2/g;\n\t\n\tvar result = {\n\t\t/**\n\t\t * Create new element factory\n\t\t * @param {String} name Element identifier\n\t\t * @param {Function} factory Function that produces element of specified \n\t\t * type. The object generated by this factory is automatically \n\t\t * augmented with <code>type</code> property pointing to element\n\t\t * <code>name</code>\n\t\t * @memberOf elements\n\t\t */\n\t\tadd: function(name, factory) {\n\t\t\tvar that = this;\n\t\t\tfactories[name] = function() {\n\t\t\t\tvar elem = factory.apply(that, arguments);\n\t\t\t\tif (elem)\n\t\t\t\t\telem.type = name;\n\t\t\t\t\n\t\t\t\treturn elem;\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns factory for specified name\n\t\t * @param {String} name\n\t\t * @returns {Function}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn factories[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates new element with specified type\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tcreate: function(name) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar factory = this.get(name);\n\t\t\treturn factory ? factory.apply(this, args) : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is of specified type\n\t\t * @param {Object} elem\n\t\t * @param {String} type\n\t\t * @returns {Boolean}\n\t\t */\n\t\tis: function(elem, type) {\n\t\t\treturn elem && elem.type === type;\n\t\t}\n\t};\n\t\n\t// register resource references\n\tfunction commonFactory(value) {\n\t\treturn {data: value};\n\t}\n\t\n\t/**\n\t * Element factory\n\t * @param {String} elementName Name of output element\n\t * @param {String} attrs Attributes definition. You may also pass\n\t * <code>Array</code> where each contains object with <code>name</code> \n\t * and <code>value</code> properties, or <code>Object</code>\n\t * @param {Boolean} isEmpty Is expanded element should be empty\n\t */\n\tresult.add('element', function(elementName, attrs, isEmpty) {\n\t\tvar ret = {\n\t\t\t/** @memberOf __emmetDataElement */\n\t\t\tname: elementName,\n\t\t\tis_empty: !!isEmpty\n\t\t};\n\t\t\n\t\tif (attrs) {\n\t\t\tret.attributes = [];\n\t\t\tif (_.isArray(attrs)) {\n\t\t\t\tret.attributes = attrs;\n\t\t\t} else if (_.isString(attrs)) {\n\t\t\t\tvar m;\n\t\t\t\twhile (m = reAttrs.exec(attrs)) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\tvalue: m[3]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_.each(attrs, function(value, name) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: name, \n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t});\n\t\n\tresult.add('snippet', commonFactory);\n\tresult.add('reference', commonFactory);\n\tresult.add('empty', function() {\n\t\treturn {};\n\t});\n\t\n\treturn result;\n});/**\n * Abstract implementation of edit tree interface.\n * Edit tree is a named container of editable “name-value” child elements, \n * parsed from <code>source</code>. This container provides convenient methods\n * for editing/adding/removing child elements. All these update actions are\n * instantly reflected in the <code>source</code> code with respect of formatting.\n * <br><br>\n * For example, developer can create an edit tree from CSS rule and add or \n * remove properties from it–all changes will be immediately reflected in the \n * original source.\n * <br><br>\n * All classes defined in this module should be extended the same way as in\n * Backbone framework: using <code>extend</code> method to create new class and \n * <code>initialize</code> method to define custom class constructor.\n * \n * @example\n * <pre><code>\n * var MyClass = require('editTree').EditElement.extend({\n * \tinitialize: function() {\n * \t\t// constructor code here\n * \t}\n * });\n * \n * var elem = new MyClass(); \n * </code></pre>\n * \n * \n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __editTreeDefine\n */\nemmet.define('editTree', function(require, _, core) {\n\tvar range = require('range').create;\n\t\n\t/**\n\t * Named container of edited source\n\t * @type EditContainer\n\t * @param {String} source\n\t * @param {Object} options\n\t */\n\tfunction EditContainer(source, options) {\n\t\tthis.options = _.extend({offset: 0}, options);\n\t\t/**\n\t\t * Source code of edited structure. All changes in the structure are \n\t\t * immediately reflected into this property\n\t\t */\n\t\tthis.source = source;\n\t\t\n\t\t/** \n\t\t * List of all editable children\n\t\t * @private \n\t\t */\n\t\tthis._children = [];\n\t\t\n\t\t/**\n\t\t * Hash of all positions of container\n\t\t * @private\n\t\t */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditContainer.extend = core.extend;\n\t\n\tEditContainer.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Replace substring of tag's source\n\t\t * @param {String} value\n\t\t * @param {Number} start\n\t\t * @param {Number} end\n\t\t * @private\n\t\t */\n\t\t_updateSource: function(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = range(start, _.isUndefined(end) ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\t\t\t\n\t\t\tvar update = function(obj) {\n\t\t\t\t_.each(obj, function(v, k) {\n\t\t\t\t\tif (v >= r.end)\n\t\t\t\t\t\tobj[k] += delta;\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\t\t\t\n\t\t\t// update affected positions of children\n\t\t\t_.each(this.list(), function(item) {\n\t\t\t\tupdate(item._positions);\n\t\t\t});\n\t\t\t\n\t\t\tthis.source = require('utils').replaceSubstring(this.source, value, r);\n\t\t},\n\t\t\t\n\t\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {EditElement} Newly created element\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\t// this is abstract implementation\n\t\t\tvar item = new EditElement(name, value);\n\t\t\tthis._children.push(item);\n\t\t\treturn item;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns attribute object\n\t\t * @param {String} name Attribute name or its index\n\t\t * @returns {EditElement}\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (_.isNumber(name))\n\t\t\t\treturn this.list()[name];\n\t\t\t\n\t\t\tif (_.isString(name))\n\t\t\t\treturn _.find(this.list(), function(prop) {\n\t\t\t\t\treturn prop.name() === name;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all children by name or indexes\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tgetAll: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t// split names and indexes\n\t\t\tvar names = [], indexes = [];\n\t\t\t_.each(name, function(item) {\n\t\t\t\tif (_.isString(item))\n\t\t\t\t\tnames.push(item);\n\t\t\t\telse if (_.isNumber(item))\n\t\t\t\t\tindexes.push(item);\n\t\t\t});\n\t\t\t\n\t\t\treturn _.filter(this.list(), function(attribute, i) {\n\t\t\t\treturn _.include(indexes, i) || _.include(names, attribute.name());\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or updates element value. If such element doesn't exists,\n\t\t * it will be created automatically and added at the end of child list.\n\t\t * @param {String} name Element name or its index\n\t\t * @param {String} value New element value\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(name, value, pos) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element)\n\t\t\t\treturn element.value(value);\n\t\t\t\n\t\t\tif (!_.isUndefined(value)) {\n\t\t\t\t// no such element — create it\n\t\t\t\treturn this.add(name, value, pos);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all values of child elements found by <code>getAll()</code>\n\t\t * method\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tvalues: function(name) {\n\t\t\treturn _.map(this.getAll(name), function(element) {\n\t\t\t\treturn element.value();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remove child element\n\t\t * @param {String} name Property name or its index\n\t\t */\n\t\tremove: function(name) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) {\n\t\t\t\tthis._updateSource('', element.fullRange());\n\t\t\t\tthis._children = _.without(this._children, element);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all editable child elements\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn this._children;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of editble child in list\n\t\t * @param {Object} item\n\t\t * @returns {Number}\n\t\t */\n\t\tindexOf: function(item) {\n\t\t\treturn _.indexOf(this.list(), this.get(item));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets or gets container name\n\t\t * @param {String} val New name. If not passed, current \n\t\t * name is returned\n\t\t * @return {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name range object\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns range of current source\n\t\t * @param {Boolean} isAbsolute\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(isAbsolute ? this.options.offset : 0, this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element that belongs to specified position\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {EditElement}\n\t\t */\n\t\titemFromPosition: function(pos, isAbsolute) {\n\t\t\treturn _.find(this.list(), function(elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns source code of current container \n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.source;\n\t\t}\n\t};\n\t\n\t/**\n\t * @param {EditContainer} parent\n\t * @param {Object} nameToken\n\t * @param {Object} valueToken\n\t */\n\tfunction EditElement(parent, nameToken, valueToken) {\n\t\t/** @type EditContainer */\n\t\tthis.parent = parent;\n\t\t\n\t\tthis._name = nameToken.value;\n\t\tthis._value = valueToken ? valueToken.value : '';\n\t\t\n\t\tthis._positions = {\n\t\t\tname: nameToken.start,\n\t\t\tvalue: valueToken ? valueToken.start : -1\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditElement.extend = core.extend;\n\t\n\tEditElement.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Make position absolute\n\t\t * @private\n\t\t * @param {Number} num\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {Boolean}\n\t\t */\n\t\t_pos: function(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\n\t\t},\n\t\t\t\n\t\t/**\n\t\t * Sets of gets element value\n\t\t * @param {String} val New element value. If not passed, current \n\t\t * value is returned\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._value !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\n\t\t\t\tthis._value = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets element name\n\t\t * @param {String} val New element name. If not passed, current \n\t\t * name is returned\n\t\t * @returns {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element name token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tnamePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element value token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tvaluePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name\n\t\t * @param {Boolean} isAbsolute Return absolute range \n\t\t * @returns {Range}\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full element range, including possible indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\treturn this.range(isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element value range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tvalueRange: function(isAbsolute) {\n\t\t\treturn range(this.valuePosition(isAbsolute), this.value());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns current element string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.value();\n\t\t},\n\t\t\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\tEditContainer: EditContainer,\n\t\tEditElement: EditElement,\n\t\t\n\t\t/**\n\t\t * Creates token that can be fed to <code>EditElement</code>\n\t\t * @param {Number} start\n\t\t * @param {String} value\n\t\t * @param {String} type\n\t\t * @returns\n\t\t */\n\t\tcreateToken: function(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\t\t\t\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}\n\t};\n});/**\n * CSS EditTree is a module that can parse a CSS rule into a tree with \n * convenient methods for adding, modifying and removing CSS properties. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __cssEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('cssEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: '\\n\\t',\n\t\tstyleSeparator: ': ',\n\t\toffset: 0\n\t};\n\t\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\n\t\n\t/**\n\t * Returns range object\n\t * @param {Number} start\n\t * @param {Number} len \n\t * @returns {Range}\n\t */\n\tfunction range(start, len) {\n\t\treturn require('range').create(start, len);\n\t}\n\t\n\t/**\n\t * Removes whitespace tokens from the array ends\n\t * @param {Array} tokens\n\t * @param {Number} mask Mask indicating from which end whitespace should be \n\t * removed \n\t * @returns {Array}\n\t */\n\tfunction trimWhitespaceTokens(tokens, mask) {\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\n\t\tvar whitespace = ['white', 'line'];\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) == WHITESPACE_REMOVE_FROM_END)\n\t\t\twhile (tokens.length && _.include(whitespace, _.last(tokens).type)) {\n\t\t\t\ttokens.pop();\n\t \t\t}\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) == WHITESPACE_REMOVE_FROM_START)\n\t\t\twhile (tokens.length && _.include(whitespace, tokens[0].type)) {\n\t\t\t\ttokens.shift();\n\t\t\t}\n\t\t\n\t\treturn tokens;\n\t}\n\t\n\t/**\n\t * Helper function that searches for selector range for <code>CSSEditRule</code>\n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findSelectorRange(it) {\n\t\tvar tokens = [], token;\n \t\tvar start = it.position(), end;\n \t\t\n \t\twhile (token = it.next()) {\n\t\t\tif (token.type == '{')\n\t\t\t\tbreak;\n\t\t\ttokens.push(token);\n\t\t}\n \t\t\n \t\ttrimWhitespaceTokens(tokens);\n \t\t\n \t\tif (tokens.length) {\n \t\t\tstart = tokens[0].start;\n \t\t\tend = _.last(tokens).end;\n \t\t} else {\n \t\t\tend = start;\n \t\t}\n \t\t\n \t\treturn range(start, end - start);\n\t}\n\t\n\t/**\n\t * Helper function that searches for CSS property value range next to\n\t * iterator's current position  \n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findValueRange(it) {\n\t\t// find value start position\n\t\tvar skipTokens = ['white', 'line', ':'];\n\t\tvar tokens = [], token, start, end;\n\t\t\n\t\tit.nextUntil(function(tok) {\n\t\t\treturn !_.include(skipTokens, this.itemNext().type);\n\t\t});\n\t\t\n\t\tstart = it.current().end;\n\t\t// consume value\n\t\twhile (token = it.next()) {\n\t\t\tif (token.type == '}' || token.type == ';') {\n\t\t\t\t// found value end\n\t\t\t\ttrimWhitespaceTokens(tokens, WHITESPACE_REMOVE_FROM_START \n\t\t\t\t\t\t| (token.type == '}' ? WHITESPACE_REMOVE_FROM_END : 0));\n\t\t\t\t\n\t\t\t\tif (tokens.length) {\n\t\t\t\t\tstart = tokens[0].start;\n\t\t\t\t\tend = _.last(tokens).end;\n\t\t\t\t} else {\n\t\t\t\t\tend = start;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\ttokens.push(token);\n\t\t}\n\t\t\n\t\t// reached the end of tokens list\n\t\tif (tokens.length) {\n\t\t\treturn range(tokens[0].start, _.last(tokens).end - tokens[0].start);\n\t\t}\n\t}\n\t\n\t/**\n\t * Finds parts of complex CSS value\n\t * @param {String} str\n\t * @returns {Array} Returns list of <code>Range</code>'s\n\t */\n\tfunction findParts(str) {\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(str);\n\t\tvar ch;\n\t\tvar result = [];\n\t\tvar sep = /[\\s\\u00a0,]/;\n\t\t\n\t\tvar add = function() {\n\t\t\tstream.next();\n\t\t\tresult.push(range(stream.start, stream.current()));\n\t\t\tstream.start = stream.pos;\n\t\t};\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\t\tstream.next();\n\t\t\t\tif (!stream.skipTo(ch)) break;\n\t\t\t\tadd();\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// function found, may have nested function\n\t\t\t\tstream.backUp(1);\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tadd();\n\t\t\t} else {\n\t\t\t\tif (sep.test(ch)) {\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\n\t\t\t\t\tstream.eatWhile(sep);\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tadd();\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * A bit hacky way to identify invalid CSS property definition: when user\n\t * starts writing new abbreviation in CSS rule, he actually creates invalid\n\t * CSS property definition and this method tries to identify such abbreviation\n\t * and prevent it from being added to CSS edit tree \n\t * @param {TokenIterator} it\n\t */\n\tfunction isValidIdentifier(it) {\n//\t\treturn true;\n\t\tvar tokens = it.tokens;\n\t\tfor (var i = it._i + 1, il = tokens.length; i < il; i++) {\n\t\t\tif (tokens[i].type == ':')\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (tokens[i].type == 'identifier' || tokens[i].type == 'line')\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * @class\n\t * @extends EditContainer\n\t */\n\tvar CSSEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\t/** @type TokenIterator */\n\t \t\tvar it = require('tokenIterator').create(\n\t \t\t\t\trequire('cssParser').parse(source));\n\t \t\t\n\t \t\tvar selectorRange = findSelectorRange(it);\n\t \t\tthis._positions.name = selectorRange.start;\n\t \t\tthis._name = selectorRange.substring(source);\n\t \t\t\n\t \t\tif (!it.current() || it.current().type != '{')\n\t \t\t\tthrow 'Invalid CSS rule';\n\t \t\t\n\t \t\tthis._positions.contentStart = it.position() + 1;\n\t \t\t\n\t \t\t// consume properties\n\t \t\tvar propertyRange, valueRange, token;\n\t\t\twhile (token = it.next()) {\n\t\t\t\tif (token.type == 'identifier' && isValidIdentifier(it)) {\n\t\t\t\t\tpropertyRange = range(token);\n\t\t\t\t\tvalueRange = findValueRange(it);\n\t\t\t\t\tvar end = (it.current() && it.current().type == ';') \n\t\t\t\t\t\t? range(it.current())\n\t\t\t\t\t\t: range(valueRange.end, 0);\n\t\t\t\t\tthis._children.push(new CSSEditElement(this,\n\t\t\t\t\t\t\teditTree.createToken(propertyRange.start, propertyRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(valueRange.start, valueRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(end.start, end.substring(source))\n\t\t\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar source = this.source;\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {CSSEditProperty} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t// a small hack here:\n\t\t\t\t// Sometimes users add empty lines before properties to logically\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\n\t\t\t\t// characters between rules may lead to undesired behavior,\n\t\t\t\t// especially when current rule is duplicated or used as a donor\n\t\t\t\t// to create new rule.\n\t\t\t\t// To solve this issue, we‘ll take only last newline indentation\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tp.styleBefore = '\\n' + _.last(lines);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\n\t\t\t\t\n\t\t\t\t// graceful and naive comments removal \n\t\t\t\tp.styleBefore = _.last(p.styleBefore.split('*/'));\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new CSS property \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {CSSEditProperty}\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator');\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t/** @type CSSEditProperty */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\t// make sure that donor has terminating semicolon\n\t\t\t\tdonor.end(';');\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator');\n\t\t\t}\n\t\t\t\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\n\t\t\t\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\n\t\t\t\n\t\t\t_.extend(property, styles);\n\t\t\t\n\t\t\t// write new property into the source\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\n\t\t\t\n\t\t\t// insert new property\n\t\t\tthis._children.splice(pos, 0, property);\n\t\t\treturn property;\n\t\t}\n\t});\n\t\n\t/**\n\t * @class\n\t * @type CSSEditElement\n\t * @constructor\n\t */\n\tvar CSSEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(rule, name, value, end) {\n\t\t\tthis.styleBefore = rule.options.styleBefore;\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\n\t\t\t\n\t\t\tthis._end = end.value;\n\t\t\tthis._positions.end = end.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ranges of complex value parts\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\n\t\t */\n\t\tvalueParts: function(isAbsolute) {\n\t\t\tvar parts = findParts(this.value());\n\t\t\tif (isAbsolute) {\n\t\t\t\tvar offset = this.valuePosition(true);\n\t\t\t\t_.each(parts, function(p) {\n\t\t\t\t\tp.shift(offset);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn parts;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets property end value (basically, it's a semicolon)\n\t\t * @param {String} val New end value. If not passed, current \n\t\t * value is returned\n\t\t */\n\t\tend: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._end !== val) {\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\n\t\t\t\tthis._end = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns item string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses CSS rule into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.cssEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new CSSEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractRule(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts single CSS selector definition from source code\n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {Range}\n\t\t */\n\t\textractRule: function(content, pos, isBackward) {\n\t\t\tvar result = '';\n\t\t\tvar len = content.length;\n\t\t\tvar offset = pos;\n\t\t\tvar stopChars = '{}/\\\\<>\\n\\r';\n\t\t\tvar bracePos = -1, ch;\n\t\t\t\n\t\t\t// search left until we find rule edge\n\t\t\twhile (offset >= 0) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (ch == '}' && !isBackward) {\n\t\t\t\t\toffset++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset--;\n\t\t\t}\n\t\t\t\n\t\t\t// search right for full rule set\n\t\t\twhile (offset < len) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (bracePos != -1)\n\t\t\t\t\t\tresult = content.substring(bracePos, offset + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset++;\n\t\t\t}\n\t\t\t\n\t\t\tif (result) {\n\t\t\t\t// find CSS selector\n\t\t\t\toffset = bracePos - 1;\n\t\t\t\tvar selector = '';\n\t\t\t\twhile (offset >= 0) {\n\t\t\t\t\tch = content.charAt(offset);\n\t\t\t\t\tif (stopChars.indexOf(ch) != -1) break;\n\t\t\t\t\toffset--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// also trim whitespace\n\t\t\t\tselector = content.substring(offset + 1, bracePos).replace(/^[\\s\\n\\r]+/m, '');\n\t\t\t\treturn require('range').create(bracePos - selector.length, result.length + selector.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t \t * Removes vendor prefix from CSS property\n\t \t * @param {String} name CSS property\n\t \t * @return {String}\n\t \t */\n\t \tbaseName: function(name) {\n\t \t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\n\t \t},\n\t \t\n\t \t/**\n\t \t * Finds parts of complex CSS value\n\t \t * @param {String} str\n\t \t * @returns {Array}\n\t \t */\n\t \tfindParts: findParts\n\t};\n});/**\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \n * convenient methods for adding, modifying and removing attributes. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __xmlEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('xmlEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: ' ',\n\t\tstyleSeparator: '=',\n\t\tstyleQuote: '\"',\n\t\toffset: 0\n\t};\n\t\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\n\t\n\tvar XMLEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tthis._positions.name = 1;\n\t\t\t\n\t\t\tvar attrToken = null;\n\t\t\tvar tokens = require('xmlParser').parse(source);\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t_.each(tokens, function(token) {\n\t\t\t\ttoken.value = range.create(token).substring(source);\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'tag':\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'attribute':\n\t\t\t\t\t\t// add empty attribute\n\t\t\t\t\t\tif (attrToken) {\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tattrToken = token;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\n\t\t\t\t\t\tattrToken = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tif (attrToken) {\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar source = this.source;\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {EditElement} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t\n\t\t\t\tif (p.valuePosition() !== -1) {\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar editTree = require('editTree');\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t\n\t\t\t/** @type XMLEditAttribute */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t}\n\t\t\t\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\n\t\t\t\n\t\t\tvar attribute = new XMLEditElement(this, \n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\n\t\t\t\t\t);\n\t\t\t\n\t\t\t_.extend(attribute, styles);\n\t\t\t\n\t\t\t// write new attribute into the source\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\n\t\t\t\n\t\t\t// insert new attribute\n\t\t\tthis._children.splice(pos, 0, attribute);\n\t\t\treturn attribute;\n\t\t}\n\t});\n\t\n\tvar XMLEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(parent, nameToken, valueToken) {\n\t\t\tthis.styleBefore = parent.options.styleBefore;\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\n\t\t\t\n\t\t\tvar value = '', quote = parent.options.styleQuote;\n\t\t\tif (valueToken) {\n\t\t\t\tvalue = valueToken.value;\n\t\t\t\tquote = value.charAt(0);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\tvalue = value.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.styleQuote = quote;\n\t\t\t\n\t\t\tthis._value = value;\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses HTML element into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.htmlEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new XMLEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse HTML from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {XMLEditElement}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \n\t\t * <code>pos</code> position\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isBackward\n\t\t * @returns {Range}\n\t\t */\n\t\textractTag: function(content, pos, isBackward) {\n\t\t\tvar len = content.length, i;\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t// max extraction length. I don't think there may be tags larger \n\t\t\t// than 2000 characters length\n\t\t\tvar maxLen = Math.min(2000, len);\n\t\t\t\n\t\t\t/** @type Range */\n\t\t\tvar r = null;\n\t\t\t\n\t\t\tvar match = function(pos) {\n\t\t\t\tvar m;\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\n\t\t\t\t\treturn range.create(pos, m[0]);\n\t\t\t};\n\t\t\t\n\t\t\t// lookup backward, in case we are inside tag already\n\t\t\tfor (i = pos; i >= 0; i--) {\n\t\t\t\tif (r = match(i)) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (r && (r.inside(pos) || isBackward))\n\t\t\t\treturn r;\n\t\t\t\n\t\t\tif (!r && isBackward)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\t// search forward\n\t\t\tfor (i = pos; i < len; i++) {\n\t\t\t\tif (r = match(i))\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \n * position and replaces it with formatted output. \n * <br><br>\n * This behavior can be overridden with custom handlers which can perform \n * different actions when 'Expand Abbreviation' action is called.\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\n * definitions registers its own expand abbreviation handler.  \n *  \n * @constructor\n * @memberOf __expandAbbreviationActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('expandAbbreviation', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar actions = require('actions');\n\t/**\n\t * 'Expand abbreviation' editor action \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\tactions.add('expand_abbreviation', function(editor, syntax, profile) {\n\t\tvar args = _.toArray(arguments);\n\t\t\n\t\t// normalize incoming arguments\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\targs[1] = info.syntax;\n\t\targs[2] = info.profile;\n\t\t\n\t\treturn handlers.exec(false, args);\n\t});\n\t\n\t/**\n\t * A special version of <code>expandAbbreviation</code> function: if it can't\n\t * find abbreviation, it will place Tab character at caret position\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\tactions.add('expand_abbreviation_with_tab', function(editor, syntax, profile) {\n\t\tvar sel = editor.getSelection();\n\t\tvar indent = require('resources').getVariable('indentation');\n\t\tif (sel) {\n\t\t\t// indent selection\n\t\t\tvar utils = require('utils');\n\t\t\tvar selRange = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = utils.padString(sel, indent);\n\t\t\t\n\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\n\t\t\tvar replaceRange = require('range').create(editor.getCaretPos(), selRange.length());\n\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\n\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!actions.run('expand_abbreviation', editor, syntax, profile)) {\n\t\t\teditor.replaceContent(indent, editor.getCaretPos());\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n\t\n\t// XXX setup default handler\n\t/**\n\t * Extracts abbreviation from current caret \n\t * position and replaces it with formatted output \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\thandlers.add(function(editor, syntax, profile) {\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = module.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile, \n\t\t\t\t\trequire('actionUtils').captureContext(editor));\n\t\t\tif (content) {\n\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {order: -1});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds custom expand abbreviation handler. The passed function should \n\t\t * return <code>true</code> if it was performed successfully, \n\t\t * <code>false</code> otherwise.\n\t\t * \n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\n\t\t * in order they were added\n\t\t * @memberOf expandAbbreviation\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for abbreviation in editor from current caret position\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tfindAbbreviation: function(editor) {\n\t\t\t/** @type Range */\n\t\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = String(editor.getContent());\n\t\t\tif (range.length()) {\n\t\t\t\t// abbreviation is selected by user\n\t\t\t\treturn range.substring(content);\n\t\t\t}\n\t\t\t\n\t\t\t// search for new abbreviation from current caret position\n\t\t\tvar curLine = editor.getCurrentLineRange();\n\t\t\treturn require('actionUtils').extractAbbreviation(content.substring(curLine.start, range.start));\n\t\t}\n\t};\n});/**\n * Action that wraps content with abbreviation. For convenience, action is \n * defined as reusable module\n * @constructor\n * @memberOf __wrapWithAbbreviationDefine\n */\nemmet.define('wrapWithAbbreviation', function(require, _) {\n\t/** Back-references to current module */\n\tvar module = null;\n\t\n\t/**\n\t * Wraps content with abbreviation\n\t * @param {IEmmetEditor} Editor instance\n\t * @param {String} abbr Abbreviation to wrap with\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\trequire('actions').add('wrap_with_abbreviation', function (editor, abbr, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.editorUtils */\n\t\tvar editorUtils = require('editorUtils');\n\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\t\t\n\t\tif (!abbr) \n\t\t\treturn null;\n\t\t\n\t\tabbr = String(abbr);\n\t\t\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find tag pair\n\t\t\tvar match = require('htmlMatcher').tag(info.content, range.start);\n\t\t\tif (!match) {  // nothing to wrap\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\trange = utils.narrowToNonSpace(info.content, match.range);\n\t\t}\n\t\t\n\t\tvar newContent = utils.escapeText(range.substring(info.content));\n\t\tvar result = module\n\t\t\t.wrap(abbr, editorUtils.unindent(editor, newContent), info.syntax, \n\t\t\t\t\tinfo.profile, require('actionUtils').captureContext(editor));\n\t\t\n\t\tif (result) {\n\t\t\teditor.replaceContent(result, range.start, range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Wraps passed text with abbreviation. Text will be placed inside last\n\t\t * expanded element\n\t\t * @memberOf wrapWithAbbreviation\n\t\t * @param {String} abbr Abbreviation\n\t\t * @param {String} text Text to wrap\n\t\t * @param {String} syntax Document type (html, xml, etc.). Default is 'html'\n\t\t * @param {String} profile Output profile's name. Default is 'plain'\n\t\t * @param {Object} contextNode Context node inside which abbreviation\n\t\t * is wrapped. It will be used as a reference for node name resolvers\n\t\t * @return {String}\n\t\t */\n\t\twrap: function(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\t\t\t\n\t\t\trequire('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t};\n});/**\n * Toggles HTML and CSS comments depending on current caret context. Unlike\n * the same action in most editors, this action toggles comment on currently\n * matched item—HTML tag or CSS selector—when nothing is selected.\n * \n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __toggleCommentAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Toggle HTML comment on current selection or tag\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleHTMLComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find matching tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) { // found pair\n\t\t\t\trange = tag.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '<!--', '-->', range);\n\t}\n\n\t/**\n\t * Simple CSS commenting\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trange = property \n\t\t\t\t\t? property.range(true) \n\t\t\t\t\t: require('range').create(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trange = require('range').create(editor.getCurrentLineRange());\n\t\t\trequire('utils').narrowToNonSpace(info.content, range);\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '/*', '*/', range);\n\t}\n\t\n\t/**\n\t * Returns CSS property from <code>rule</code> that matches passed position\n\t * @param {EditContainer} rule\n\t * @param {Number} absPos\n\t * @returns {EditElement}\n\t */\n\tfunction cssItemFromPosition(rule, absPos) {\n\t\t// do not use default EditContainer.itemFromPosition() here, because\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\n\t\tvar relPos = absPos - (rule.options.offset || 0);\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\n\t\treturn _.find(rule.list(), function(item) {\n\t\t\tif (item.range().end === relPos) {\n\t\t\t\t// at the end of property, but outside of it\n\t\t\t\t// if there’s a space character at current position,\n\t\t\t\t// use current property\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\n\t\t\t}\n\t\t\t\n\t\t\treturn item.range().inside(relPos);\n\t\t});\n\t}\n\n\t/**\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\n\t * @param {String} text Where to search\n\t * @param {Number} from Search start index\n\t * @param {String} start_token Comment start string\n\t * @param {String} end_token Comment end string\n\t * @return {Range} Returns null if comment wasn't found\n\t */\n\tfunction searchComment(text, from, startToken, endToken) {\n\t\tvar commentStart = -1;\n\t\tvar commentEnd = -1;\n\t\t\n\t\tvar hasMatch = function(str, start) {\n\t\t\treturn text.substr(start, str.length) == str;\n\t\t};\n\t\t\t\n\t\t// search for comment start\n\t\twhile (from--) {\n\t\t\tif (hasMatch(startToken, from)) {\n\t\t\t\tcommentStart = from;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (commentStart != -1) {\n\t\t\t// search for comment end\n\t\t\tfrom = commentStart;\n\t\t\tvar contentLen = text.length;\n\t\t\twhile (contentLen >= from++) {\n\t\t\t\tif (hasMatch(endToken, from)) {\n\t\t\t\t\tcommentEnd = from + endToken.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (commentStart != -1 && commentEnd != -1) \n\t\t\t? require('range').create(commentStart, commentEnd - commentStart) \n\t\t\t: null;\n\t}\n\n\t/**\n\t * Generic comment toggling routine\n\t * @param {IEmmetEditor} editor\n\t * @param {String} commentStart Comment start token\n\t * @param {String} commentEnd Comment end token\n\t * @param {Range} range Selection range\n\t * @return {Boolean}\n\t */\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar newContent = null;\n\t\t\n\t\tvar utils = require('utils');\n\t\t\t\n\t\t/**\n\t\t * Remove comment markers from string\n\t\t * @param {Sting} str\n\t\t * @return {String}\n\t\t */\n\t\tfunction removeComment(str) {\n\t\t\treturn str\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\n\t\t\t\t\tcaretPos -= str.length;\n\t\t\t\t\treturn '';\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\n\t\t}\n\t\t\n\t\t// first, we need to make sure that this substring is not inside \n\t\t// comment\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\n\t\tif (commentRange && commentRange.overlap(range)) {\n\t\t\t// we're inside comment, remove it\n\t\t\trange = commentRange;\n\t\t\tnewContent = removeComment(range.substring(content));\n\t\t} else {\n\t\t\t// should add comment\n\t\t\t// make sure that there's no comment inside selection\n\t\t\tnewContent = commentStart + ' ' +\n\t\t\t\trange.substring(content)\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\n\t\t\t\t' ' + commentEnd;\n\t\t\t\t\n\t\t\t// adjust caret position\n\t\t\tcaretPos += commentStart.length + 1;\n\t\t}\n\n\t\t// replace editor content\n\t\tif (newContent !== null) {\n\t\t\tnewContent = utils.escapeText(newContent);\n\t\t\teditor.setCaretPos(range.start);\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\n\t\t\teditor.setCaretPos(caretPos);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Toggle comment on current editor's selection or HTML tag/CSS rule\n\t * @param {IEmmetEditor} editor\n\t */\n\trequire('actions').add('toggle_comment', function(editor) {\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tif (info.syntax == 'css') {\n\t\t\t// in case our editor is good enough and can recognize syntax from \n\t\t\t// current token, we have to make sure that cursor is not inside\n\t\t\t// 'style' attribute of html element\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && tag.open.range.inside(caretPos)) {\n\t\t\t\tinfo.syntax = 'html';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (info.syntax == 'css')\n\t\t\treturn toggleCSSComment(editor);\n\t\t\n\t\treturn toggleHTMLComment(editor);\n\t});\n});/**\n * Move between next/prev edit points. 'Edit points' are places between tags \n * and quotes of empty attributes in html\n * @constructor\n * \n * @memberOf __editPointActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Search for new caret insertion point\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {Number} inc Search increment: -1 — search left, 1 — search right\n\t * @param {Number} offset Initial offset relative to current caret position\n\t * @return {Number} Returns -1 if insertion point wasn't found\n\t */\n\tfunction findNewEditPoint(editor, inc, offset) {\n\t\tinc = inc || 1;\n\t\toffset = offset || 0;\n\t\t\n\t\tvar curPoint = editor.getCaretPos() + offset;\n\t\tvar content = String(editor.getContent());\n\t\tvar maxLen = content.length;\n\t\tvar nextPoint = -1;\n\t\tvar reEmptyLine = /^\\s+$/;\n\t\t\n\t\tfunction getLine(ix) {\n\t\t\tvar start = ix;\n\t\t\twhile (start >= 0) {\n\t\t\t\tvar c = content.charAt(start);\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t\tbreak;\n\t\t\t\tstart--;\n\t\t\t}\n\t\t\t\n\t\t\treturn content.substring(start, ix);\n\t\t}\n\t\t\t\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\n\t\t\tcurPoint += inc;\n\t\t\tvar curChar = content.charAt(curPoint);\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\n\t\t\t\t\n\t\t\tswitch (curChar) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\n\t\t\t\t\t\t// empty attribute\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (nextChar == '<') {\n\t\t\t\t\t\t// between tags\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\tcase '\\r':\n\t\t\t\t\t// empty line\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\n\t\t\t\t\t\tnextPoint = curPoint;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPoint != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn nextPoint;\n\t}\n\t\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\t\n\t/**\n\t * Move caret to previous edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('prev_edit_point', function(editor) {\n\t\tvar curPos = editor.getCaretPos();\n\t\tvar newPoint = findNewEditPoint(editor, -1);\n\t\t\t\n\t\tif (newPoint == curPos)\n\t\t\t// we're still in the same point, try searching from the other place\n\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\n\t\t\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Previous Edit Point'});\n\t\n\t/**\n\t * Move caret to next edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('next_edit_point', function(editor) {\n\t\tvar newPoint = findNewEditPoint(editor, 1);\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Actions that use stream parsers and tokenizers for traversing:\n * -- Search for next/previous items in HTML\n * -- Search for next/previous items in CSS\n * @constructor\n * @memberOf __selectItemActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\t\n\t/**\n\t * Generic function for searching for items to select\n\t * @param {IEmmetEditor} editor\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\n\t * @param {Function} extractFn Function that extracts item content\n\t * @param {Function} rangeFn Function that search for next token range\n\t */\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\n\t\tvar range = require('range');\n\t\tvar content = require('editorUtils').outputInfo(editor).content;\n\t\t\n\t\tvar contentLength = content.length;\n\t\tvar itemRange, rng;\n\t\t/** @type Range */\n\t\tvar prevRange = range.create(-1, 0);\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\t\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\n\t\t\t\tif (prevRange.equal(itemRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprevRange = itemRange.clone();\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\n\t\t\t\t\n\t\t\t\tif (rng) {\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsearchPos += isBackward ? -1 : 1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t// XXX HTML section\n\t\n\t/**\n\t * Find next HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findNextHTMLItem(editor) {\n\t\tvar isFirst = true;\n\t\treturn findItem(editor, false, function(content, searchPos){\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\n\t\t\t} else {\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\n\t\t\t}\n\t\t}, function(tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\n\t\t});\n\t}\n\t\n\t/**\n\t * Find previous HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findPrevHTMLItem(editor) {\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\n\t\t});\n\t}\n\t\n\t/**\n\t * Creates possible selection ranges for HTML tag\n\t * @param {String} source Original HTML source for tokens\n\t * @param {Array} tokens List of HTML tokens\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\n\t\t_.each(tokens, function(tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range.create({\n\t\t\t\t\t\t\tstart: tok.start + 1, \n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\t result.push(range.create(attrStart, tok.end - attrStart));\n\t\t\t\t\t \n\t\t\t\t\t attrValueRange = range.create(tok);\n\t\t\t\t\t attrValue = attrValueRange.substring(source);\n\t\t\t\t\t \n\t\t\t\t\t // is this a quoted attribute?\n\t\t\t\t\t if (isQuote(attrValue.charAt(0)))\n\t\t\t\t\t\t attrValueRange.start++;\n\t\t\t\t\t \n\t\t\t\t\t if (isQuote(attrValue.charAt(attrValue.length - 1)))\n\t\t\t\t\t\t attrValueRange.end--;\n\t\t\t\t\t \n\t\t\t\t\t result.push(attrValueRange);\n\t\t\t\t\t \n\t\t\t\t\t if (attrName == 'class') {\n\t\t\t\t\t\t result = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// offset ranges\n\t\t_.each(result, function(r) {\n\t\t\tr.shift(offset);\n\t\t});\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {        // remove empty\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {   // remove duplicates\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Returns ranges of class names in \"class\" attribute value\n\t * @param {String} className\n\t * @returns {Array}\n\t */\n\tfunction classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(className);\n\t\tvar range = require('range');\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Returns best HTML tag range match for current selection\n\t * @param {String} tag Tag declaration\n\t * @param {Number} offset Tag's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\n\t\tvar ranges = makePossibleRangesHTML(tag, require('xmlParser').parse(tag), offset);\n\t\t\n\t\tif (isBackward)\n\t\t\tranges.reverse();\n\t\t\n\t\t// try to find selected range\n\t\tvar curRange = _.find(ranges, function(r) {\n\t\t\treturn r.equal(selRange);\n\t\t});\n\t\t\n\t\tif (curRange) {\n\t\t\tvar ix = _.indexOf(ranges, curRange);\n\t\t\tif (ix < ranges.length - 1)\n\t\t\t\treturn ranges[ix + 1];\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// no selected range, find nearest one\n\t\tif (isBackward)\n\t\t\t// search backward\n\t\t\treturn _.find(ranges, function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t});\n\t\t\n\t\t// search forward\n\t\t// to deal with overlapping ranges (like full attribute definition\n\t\t// and attribute value) let's find range under caret first\n\t\tif (!curRange) {\n\t\t\tvar matchedRanges = _.filter(ranges, function(r) {\n\t\t\t\treturn r.inside(selRange.end);\n\t\t\t});\n\t\t\t\n\t\t\tif (matchedRanges.length > 1)\n\t\t\t\treturn matchedRanges[1];\n\t\t}\n\t\t\n\t\t\n\t\treturn _.find(ranges, function(r) {\n\t\t\treturn r.end > selRange.end;\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for opening tag in content, starting at specified position\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction findOpeningTagFromPosition(html, pos) {\n\t\tvar tag;\n\t\twhile (pos >= 0) {\n\t\t\tif (tag = getOpeningTagFromPosition(html, pos))\n\t\t\t\treturn tag;\n\t\t\tpos--;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction getOpeningTagFromPosition(html, pos) {\n\t\tvar m;\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\n\t\t\treturn require('range').create(pos, m[0]);\n\t\t}\n\t}\n\t\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\t\n\t/**\n\t * Makes all possible selection ranges for specified CSS property\n\t * @param {CSSProperty} property\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesCSS(property) {\n\t\t// find all possible ranges, sorted by position and size\n\t\tvar valueRange = property.valueRange(true);\n\t\tvar result = [property.range(true), valueRange];\n\t\tvar stringStream = require('stringStream');\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar range = require('range');\n\t\t\n\t\t// locate parts of complex values.\n\t\t// some examples:\n\t\t// – 1px solid red: 3 parts\n\t\t// – arial, sans-serif: enumeration, 2 parts\n\t\t// – url(image.png): function value part\n\t\tvar value = property.value();\n\t\t_.each(property.valueParts(), function(r) {\n\t\t\t// add absolute range\n\t\t\tvar clone = r.clone();\n\t\t\tresult.push(clone.shift(valueRange.start));\n\t\t\t\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(r.substring(value));\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\n\t\t\t\t// we have a function, find values in it.\n\t\t\t\t// but first add function contents\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.skipToPair('(', ')');\n\t\t\t\tvar fnBody = stream.current();\n\t\t\t\tresult.push(range.create(clone.start + stream.start, fnBody));\n\t\t\t\t\n\t\t\t\t// find parts\n\t\t\t\t_.each(cssEditTree.findParts(fnBody), function(part) {\n\t\t\t\t\tresult.push(range.create(clone.start + stream.start + part.start, part.substring(fnBody)));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\t// optimize result: remove empty ranges and duplicates\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Tries to find matched CSS property and nearest range for selection\n\t * @param {CSSRule} rule\n\t * @param {Range} selRange\n\t * @param {Boolean} isBackward\n\t * @returns {Range}\n\t */\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\n\t\t/** @type CSSProperty */\n\t\tvar property = null;\n\t\tvar possibleRanges, curRange = null, ix;\n\t\tvar list = rule.list();\n\t\tvar searchFn, nearestItemFn;\n\t\t\n\t\tif (isBackward) {\n\t\t\tlist.reverse();\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).start <= selRange.start;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t};\n\t\t} else {\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).end >= selRange.end;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.end > selRange.start;\n\t\t\t};\n\t\t}\n\t\t\n\t\t// search for nearest to selection CSS property\n\t\twhile (property = _.find(list, searchFn)) {\n\t\t\tpossibleRanges = makePossibleRangesCSS(property);\n\t\t\tif (isBackward)\n\t\t\t\tpossibleRanges.reverse();\n\t\t\t\n\t\t\t// check if any possible range is already selected\n\t\t\tcurRange = _.find(possibleRanges, function(r) {\n\t\t\t\treturn r.equal(selRange);\n\t\t\t});\n\t\t\t\n\t\t\tif (!curRange) {\n\t\t\t\t// no selection, select nearest item\n\t\t\t\tvar matchedRanges = _.filter(possibleRanges, function(r) {\n\t\t\t\t\treturn r.inside(selRange.end);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (matchedRanges.length > 1) {\n\t\t\t\t\tcurRange = matchedRanges[1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (curRange = _.find(possibleRanges, nearestItemFn))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tix = _.indexOf(possibleRanges, curRange);\n\t\t\t\tif (ix != possibleRanges.length - 1) {\n\t\t\t\t\tcurRange = possibleRanges[ix + 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcurRange = null;\n\t\t\tselRange.start = selRange.end = isBackward \n\t\t\t\t? property.range(true).start - 1\n\t\t\t\t: property.range(true).end + 1;\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\tfunction findNextCSSItem(editor) {\n\t\treturn findItem(editor, false, require('cssEditTree').extractRule, getRangeForNextItemInCSS);\n\t}\n\t\n\tfunction findPrevCSSItem(editor) {\n\t\treturn findItem(editor, true, require('cssEditTree').extractRule, getRangeForPrevItemInCSS);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS after current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\t// check if selector is matched\n\t\tvar range = tree.nameRange(true);\n\t\tif (selRange.end < range.end) {\n\t\t\treturn range;\n\t\t}\n\t\t\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS before current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\tvar curRange = matchedRangeForCSSProperty(tree, selRange, true);\n\t\t\n\t\tif (!curRange) {\n\t\t\t// no matched property, try to match selector\n\t\t\tvar range = tree.nameRange(true);\n\t\t\tif (selRange.start > range.start) {\n\t\t\t\treturn range;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\t// XXX register actions\n\tvar actions = require('actions');\n\tactions.add('select_next_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findNextCSSItem(editor);\n\t\telse\n\t\t\treturn findNextHTMLItem(editor);\n\t});\n\t\n\tactions.add('select_previous_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findPrevCSSItem(editor);\n\t\telse\n\t\t\treturn findPrevHTMLItem(editor);\n\t});\n});/**\n * HTML pair matching (balancing) actions\n * @constructor\n * @memberOf __matchPairActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\tvar matcher = require('htmlMatcher');\n\tvar lastMatch = null;\n\t\n\t/**\n\t * Find and select HTML tag pair\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \n\t * Default is 'out'\n\t */\n\tfunction matchPair(editor, direction) {\n\t\tdirection = String((direction || 'out').toLowerCase());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\tvar range = require('range');\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\tvar content = info.content;\n\t\t\n\t\t// validate previous match\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\tlastMatch = null;\n\t\t}\n\t\t\n\t\tif (lastMatch && sel.length()) {\n\t\t\tif (direction == 'in') {\n\t\t\t\t// user has previously selected tag and wants to move inward\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\n\t\t\t\t\t// unary tag was selected, can't move inward\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar narrowed = require('utils').narrowToNonSpace(content, lastMatch.innerRange);\n\t\t\t\t\t\tlastMatch = matcher.find(content, narrowed.start + 1);\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \n\t\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \n\t\t\t\t\t\t&& sel.equal(lastMatch.range)) {\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t}\n\t\t\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tlastMatch = null;\n\t\treturn false;\n\t}\n\t\n\tactions.add('match_pair', matchPair, {hidden: true});\n\tactions.add('match_pair_inward', function(editor){\n\t\treturn matchPair(editor, 'in');\n\t}, {label: 'HTML/Match Pair Tag (inward)'});\n\n\tactions.add('match_pair_outward', function(editor){\n\t\treturn matchPair(editor, 'out');\n\t}, {label: 'HTML/Match Pair Tag (outward)'});\n\t\n\t/**\n\t * Moves caret to matching opening or closing tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tactions.add('matching_pair', function(editor) {\n\t\tvar content = String(editor.getContent());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tif (content.charAt(caretPos) == '<') \n\t\t\t// looks like caret is outside of tag pair  \n\t\t\tcaretPos++;\n\t\t\t\n\t\tvar tag = matcher.tag(content, caretPos);\n\t\tif (tag && tag.close) { // exclude unary tags\n\t\t\tif (tag.open.range.inside(caretPos)) {\n\t\t\t\teditor.setCaretPos(tag.close.range.start);\n\t\t\t} else {\n\t\t\t\teditor.setCaretPos(tag.open.range.start);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Go To Matching Tag Pair'});\n});/**\n * Gracefully removes tag under cursor\n * \n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('remove_tag', function(editor) {\n\t\tvar utils = require('utils');\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\t// search for tag\n\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\tif (!tag.close) {\n\t\t\t\t// simply remove unary tag\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\n\t\t\t} else {\n\t\t\t\t// remove tag and its newlines\n\t\t\t\t/** @type Range */\n\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\n\t\t\t\t/** @type Range */\n\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\n\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\n\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\n\t\t\t\t\n\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Remove Tag'});\n});\n/**\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\n * &lt;div&gt;&lt;/div&gt; → &lt;div /&gt; : join<br>\n * &lt;div /&gt; → &lt;div&gt;&lt;/div&gt; : split\n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __splitJoinTagAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {Object} profile\n\t * @param {Object} tag\n\t */\n\tfunction joinTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\t// empty closing slash is a nonsense for this action\n\t\tvar slash = profile.selfClosing() || ' /';\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\n\t\t\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// update caret position\n\t\tif (content.length + tag.outerRange.start < caretPos) {\n\t\t\tcaretPos = content.length + tag.outerRange.start;\n\t\t}\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\tfunction splitTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar nl = utils.getNewline();\n\t\tvar pad = require('resources').getVariable('indentation');\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// define tag content depending on profile\n\t\tvar tagContent = (profile.tag_nl === true) ? nl + pad + nl : '';\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\n\t\tcaretPos = tag.outerRange.start + content.length;\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\trequire('actions').add('split_join_tag', function(editor, profileName) {\n\t\tvar matcher = require('htmlMatcher');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor, null, profileName);\n\t\tvar profile = require('profile').get(info.profile);\n\t\t\n\t\t// find tag at current position\n\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\treturn tag.close \n\t\t\t\t? joinTag(editor, profile, tag) \n\t\t\t\t: splitTag(editor, profile, tag);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Split\\\\Join Tag Declaration'});\n});/**\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \n * rules with vendor prefixes\n * @constructor\n * @memberOf __reflectCSSActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('reflectCSSValue', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\trequire('actions').add('reflect_css_value', function(editor) {\n\t\tif (editor.getSyntax() != 'css') return false;\n\t\t\n\t\treturn require('actionUtils').compoundUpdate(editor, doCSSReflection(editor));\n\t}, {label: 'CSS/Reflect Value'});\n\t\n\tfunction doCSSReflection(editor) {\n\t\t/** @type emmet.cssEditTree */\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar outputInfo = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\n\t\tif (!cssRule) return;\n\t\t\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\n\t\t// no property under cursor, nothing to reflect\n\t\tif (!property) return;\n\t\t\n\t\tvar oldRule = cssRule.source;\n\t\tvar offset = cssRule.options.offset;\n\t\tvar caretDelta = caretPos - offset - property.range().start;\n\t\t\n\t\thandlers.exec(false, [property]);\n\t\t\n\t\tif (oldRule !== cssRule.source) {\n\t\t\treturn {\n\t\t\t\tdata:  cssRule.source,\n\t\t\t\tstart: offset,\n\t\t\t\tend:   offset + oldRule.length,\n\t\t\t\tcaret: offset + property.range().start + caretDelta\n\t\t\t};\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns regexp that should match reflected CSS property names\n\t * @param {String} name Current CSS property name\n\t * @return {RegExp}\n\t */\n\tfunction getReflectedCSSName(name) {\n\t\tname = require('cssEditTree').baseName(name);\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\n\t\t\n\t\tif (name == 'opacity' || name == 'filter') {\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\n\t\t} else if (m = name.match(/^border-radius-(top|bottom)(left|right)/)) {\n\t\t\t// Mozilla-style border radius\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\n\t\t} else if (m = name.match(/^border-(top|bottom)-(left|right)-radius/)) { \n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\n\t\t}\n\t\t\n\t\treturn new RegExp(vendorPrefix + name + '$');\n\t}\n\t\n\t/**\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\n\t * @param {CSSProperty} donor Donor CSS property from which value should\n\t * be reflected\n\t * @param {CSSProperty} receiver Property that should receive reflected \n\t * value from donor\n\t */\n\tfunction reflectValue(donor, receiver) {\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \n\t\t\t\treceiver.name(), receiver.value());\n\t\t\n\t\treceiver.value(value);\n\t}\n\t\n\t/**\n\t * Returns value that should be reflected for <code>refName</code> CSS property\n\t * from <code>curName</code> property. This function is used for special cases,\n\t * when the same result must be achieved with different properties for different\n\t * browsers. For example: opаcity:0.5; → filter:alpha(opacity=50);<br><br>\n\t * \n\t * This function does value conversion between different CSS properties\n\t * \n\t * @param {String} curName Current CSS property name\n\t * @param {String} curValue Current CSS property value\n\t * @param {String} refName Receiver CSS property's name \n\t * @param {String} refValue Receiver CSS property's value\n\t * @return {String} New value for receiver property\n\t */\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar utils = require('utils');\n\t\tcurName = cssEditTree.baseName(curName);\n\t\trefName = cssEditTree.baseName(refName);\n\t\t\n\t\tif (curName == 'opacity' && refName == 'filter') {\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1]) / 100) : refValue;\n\t\t}\n\t\t\n\t\treturn curValue;\n\t}\n\t\n\t// XXX add default handler\n\thandlers.add(function(property) {\n\t\tvar reName = getReflectedCSSName(property.name());\n\t\t_.each(property.parent.list(), function(p) {\n\t\t\tif (reName.test(p.name())) {\n\t\t\t\treflectValue(property, p);\n\t\t\t}\n\t\t});\n\t}, {order: -1});\n\t\n\treturn {\n\t\t/**\n\t\t * Adds custom reflect handler. The passed function will receive matched\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\n\t\t * return <code>true</code> if it was performed successfully (handled \n\t\t * reflection), <code>false</code> otherwise.\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t}\n\t};\n});/**\n * Evaluates simple math expression under caret\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('evaluate_math_expression', function(editor) {\n\t\tvar actionUtils = require('actionUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar content = String(editor.getContent());\n\t\tvar chars = '.+-*/\\\\';\n\t\t\n\t\t/** @type Range */\n\t\tvar sel = require('range').create(editor.getSelectionRange());\n\t\tif (!sel.length()) {\n\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\n\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (sel && sel.length()) {\n\t\t\tvar expr = sel.substring(content);\n\t\t\t\n\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \n\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'Math.round($1/$2)');\n\t\t\t\n\t\t\ttry {\n\t\t\t\tvar result = utils.prettifyNumber(new Function('return ' + expr)());\n\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\n\t\t\t\teditor.setCaretPos(sel.start + result.length);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Numbers/Evaluate Math Expression'});\n});\n/**\n * Increment/decrement number under cursor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Extract number from current caret position of the <code>editor</code> and\n\t * increment it by <code>step</code>\n\t * @param {IEmmetEditor} editor\n\t * @param {Number} step Increment step (may be negative)\n\t */\n\tfunction incrementNumber(editor, step) {\n\t\tvar utils = require('utils');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar hasSign = false;\n\t\tvar hasDecimal = false;\n\t\t\t\n\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\n\t\t\tif (utils.isNumeric(ch))\n\t\t\t\treturn true;\n\t\t\tif (ch == '.') {\n\t\t\t\t// make sure that next character is numeric too\n\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\n\t\t\t}\n\t\t\tif (ch == '-')\n\t\t\t\treturn hasSign ? false : hasSign = true;\n\t\t\t\t\n\t\t\treturn false;\n\t\t});\n\t\t\t\n\t\tif (r && r.length()) {\n\t\t\tvar strNum = r.substring(String(editor.getContent()));\n\t\t\tvar num = parseFloat(strNum);\n\t\t\tif (!_.isNaN(num)) {\n\t\t\t\tnum = utils.prettifyNumber(num + step);\n\t\t\t\t\n\t\t\t\t// do we have zero-padded number?\n\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\n\t\t\t\t\tvar minus = '';\n\t\t\t\t\tif (RegExp.$1) {\n\t\t\t\t\t\tminus = '-';\n\t\t\t\t\t\tnum = num.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tvar parts = num.split('.');\n\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\n\t\t\t\t\tnum = minus + parts.join('.');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(num, r.start, r.end);\n\t\t\t\teditor.createSelection(r.start, r.start + num.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns length of integer part of number\n\t * @param {String} num\n\t */\n\tfunction intLength(num) {\n\t\tnum = num.replace(/^\\-/, '');\n\t\tif (~num.indexOf('.')) {\n\t\t\treturn num.split('.')[0].length;\n\t\t}\n\t\t\n\t\treturn num.length;\n\t}\n\t\n\tvar actions = require('actions');\n\t_.each([1, -1, 10, -10, 0.1, -0.1], function(num) {\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\n\t\t\n\t\tactions.add(prefix + '_number_by_' + String(Math.abs(num)).replace('.', '').substring(0, 2), function(editor) {\n\t\t\treturn incrementNumber(editor, num);\n\t\t}, {label: 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num)});\n\t});\n});/**\n * Actions to insert line breaks. Some simple editors (like browser's \n * &lt;textarea&gt;, for example) do not provide such simple things\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar actions = require('actions');\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\t// setup default preferences\n\tprefs.define('css.closeBraceIndentation', '\\n',\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\n\t\t\t+ 'This preference’s value will be automatically inserted before '\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\n\t\t\t+ '(e.g. when “Insert formatted linebreak” action will be performed ' \n\t\t\t+ 'in CSS file). If you’re such user, you may want to write put a value ' \n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\n\t\n\t/**\n\t * Inserts newline character with proper indentation in specific positions only.\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if line break was inserted \n\t */\n\tactions.add('insert_formatted_line_break_only', function(editor) {\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.resources */\n\t\tvar res = require('resources');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar nl = utils.getNewline();\n\t\t\n\t\tif (_.include(['html', 'xml', 'xsl'], info.syntax)) {\n\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t// let's see if we're breaking newly created tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && !tag.innerRange.length()) {\n\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (info.syntax == 'css') {\n\t\t\t/** @type String */\n\t\t\tvar content = info.content;\n\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\n\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\n\t\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t\t\n\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t// do we really need special formatting here?\n\t\t\t\t\t// check if this is really a newly created rule,\n\t\t\t\t\t// look ahead for a closing brace\n\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\n\t\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\t\tif (ch == '{') {\n\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ch == '}') {\n\t\t\t\t\t\t\t// not a new rule, just add indentation\n\t\t\t\t\t\t\tappend = '';\n\t\t\t\t\t\t\thasCloseBrace = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\tappend += '}';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// defining rule set\n\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\n\t\t\t\teditor.replaceContent(insValue, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn false;\n\t}, {hidden: true});\n\t\n\t/**\n\t * Inserts newline character with proper indentation. This action is used in\n\t * editors that doesn't have indentation control (like textarea element) to \n\t * provide proper indentation\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('insert_formatted_line_break', function(editor) {\n\t\tif (!actions.run('insert_formatted_line_break_only', editor)) {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar curPadding = require('editorUtils').getCurrentLinePadding(editor);\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar len = content.length;\n\t\t\tvar nl = utils.getNewline();\n\t\t\t\t\n\t\t\t// check out next line padding\n\t\t\tvar lineRange = editor.getCurrentLineRange();\n\t\t\tvar nextPadding = '';\n\t\t\t\t\n\t\t\tfor (var i = lineRange.end + 1, ch; i < len; i++) {\n\t\t\t\tch = content.charAt(i);\n\t\t\t\tif (ch == ' ' || ch == '\\t')\n\t\t\t\t\tnextPadding += ch;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPadding.length > curPadding.length)\n\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\n\t\t\telse\n\t\t\t\teditor.replaceContent(nl, caretPos);\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n});/**\n * Merges selected lines or lines between XHTML tag pairs\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('merge_lines', function(editor) {\n\t\tvar matcher = require('htmlMatcher');\n\t\tvar utils = require('utils');\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\n\t\t/** @type Range */\n\t\tvar selection = require('range').create(editor.getSelectionRange());\n\t\tif (!selection.length()) {\n\t\t\t// find matching tag\n\t\t\tvar pair = matcher.find(info.content, editor.getCaretPos());\n\t\t\tif (pair) {\n\t\t\t\tselection = pair.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (selection.length()) {\n\t\t\t// got range, merge lines\n\t\t\tvar text =  selection.substring(info.content);\n\t\t\tvar lines = utils.splitByLines(text);\n\t\t\t\n\t\t\tfor (var i = 1; i < lines.length; i++) {\n\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\n\t\t\t}\n\t\t\t\n\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\n\t\t\tvar textLen = text.length;\n\t\t\ttext = utils.escapeText(text);\n\t\t\teditor.replaceContent(text, selection.start, selection.end);\n\t\t\teditor.createSelection(selection.start, selection.start + textLen);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Encodes/decodes image under cursor to/from base64\n * @param {IEmmetEditor} editor\n * @since 0.65\n * \n * @memberOf __base64ActionDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('encode_decode_data_url', function(editor) {\n\t\tvar data = String(editor.getSelection());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\n\t\tif (!data) {\n\t\t\t// no selection, try to find image bounds from current caret position\n\t\t\tvar text = String(editor.getContent()),  m;\n\t\t\twhile (caretPos-- >= 0) {\n\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (data) {\n\t\t\tif (startsWith('data:', data))\n\t\t\t\treturn decodeFromBase64(editor, data, caretPos);\n\t\t\telse\n\t\t\t\treturn encodeToBase64(editor, data, caretPos);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Encode\\\\Decode data:URL image'});\n\t\n\t/**\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\n\t * position. If <code>pos</code> is omitted, search from beginning of text \n\t * @param {String} token Token to test\n\t * @param {String} text Where to search\n\t * @param {Number} pos Position where to start search\n\t * @return {Boolean}\n\t * @since 0.65\n\t */\n\tfunction startsWith(token, text, pos) {\n\t\tpos = pos || 0;\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\n\t}\n\t\n\t/**\n\t * Encodes image to base64\n\t * \n\t * @param {IEmmetEditor} editor\n\t * @param {String} imgPath Path to image\n\t * @param {Number} pos Caret position where image is located in the editor\n\t * @return {Boolean}\n\t */\n\tfunction encodeToBase64(editor, imgPath, pos) {\n\t\tvar file = require('file');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar editorFile = editor.getFilePath();\n\t\tvar defaultMimeType = 'application/octet-stream';\n\t\t\t\n\t\tif (editorFile === null) {\n\t\t\tthrow \"You should save your file before using this action\";\n\t\t}\n\t\t\n\t\t// locate real image path\n\t\tvar realImgPath = file.locateFile(editorFile, imgPath);\n\t\tif (realImgPath === null) {\n\t\t\tthrow \"Can't find \" + imgPath + ' file';\n\t\t}\n\t\t\n\t\tfile.read(realImgPath, function(err, content) {\n\t\t\tif (err) {\n\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\n\t\t\t}\n\t\t\t\n\t\t\tvar b64 = require('base64').encode(String(content));\n\t\t\tif (!b64) {\n\t\t\t\tthrow \"Can't encode file content to base64\";\n\t\t\t}\n\t\t\t\n\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\n\t\t\t\t';base64,' + b64;\n\t\t\t\t\n\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\n\t\t});\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Decodes base64 string back to file.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} data Base64-encoded file content\n\t * @param {Number} pos Caret position where image is located in the editor\n\t */\n\tfunction decodeFromBase64(editor, data, pos) {\n\t\t// ask user to enter path to file\n\t\tvar filePath = String(editor.prompt('Enter path to file (absolute or relative)'));\n\t\tif (!filePath)\n\t\t\treturn false;\n\t\t\t\n\t\tvar file = require('file');\n\t\tvar absPath = file.createPath(editor.getFilePath(), filePath);\n\t\tif (!absPath) {\n\t\t\tthrow \"Can't save file\";\n\t\t}\n\t\t\n\t\tfile.save(absPath, require('base64').decode( data.replace(/^data\\:.+?;.+?,/, '') ));\n\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\n\t\treturn true;\n\t}\n});\n/**\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\n * CSS rule\n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __updateImageSizeAction\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Updates image size of &lt;img src=\"\"&gt; tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeHTML(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar xmlElem = require('xmlEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\n\t\t\t\tif (size) {\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\n\t\t\t\t\txmlElem.value('width', size.width);\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\n\t\t\t\t\t\n\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\tdata: xmlElem.toString(),\n\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates image size of CSS property\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeCSS(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (cssRule) {\n\t\t\t// check if there is property with image under caret\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\t\tdata: cssRule.toString(),\n\t\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns image dimensions for source\n\t * @param {IEmmetEditor} editor\n\t * @param {String} src Image source (path or data:url)\n\t */\n\tfunction getImageSizeForSource(editor, src, callback) {\n\t\tvar fileContent;\n\t\tvar au = require('actionUtils');\n\t\tif (src) {\n\t\t\t// check if it is data:url\n\t\t\tif (/^data:/.test(src)) {\n\t\t\t\tfileContent = require('base64').decode( src.replace(/^data\\:.+?;.+?,/, '') );\n\t\t\t\treturn callback(au.getImageSize(fileContent));\n\t\t\t}\n\t\t\t\n\t\t\tvar file = require('file');\n\t\t\tvar absPath = file.locateFile(editor.getFilePath(), src);\n\t\t\tif (absPath === null) {\n\t\t\t\tthrow \"Can't find \" + src + ' file';\n\t\t\t}\n\t\t\t\n\t\t\tfile.read(absPath, function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontent = String(content);\n\t\t\t\tcallback(au.getImageSize(content));\n\t\t\t});\n\t\t}\n\t}\n\t\n\trequire('actions').add('update_image_size', function(editor) {\n\t\t// this action will definitely won’t work in SASS dialect,\n\t\t// but may work in SCSS or LESS\n\t\tif (_.include(['css', 'less', 'scss'], String(editor.getSyntax()))) {\n\t\t\tupdateImageSizeCSS(editor);\n\t\t} else {\n\t\t\tupdateImageSizeHTML(editor);\n\t\t}\n\t\t\n\t\treturn true;\n\t});\n});/**\n * Resolver for fast CSS typing. Handles abbreviations with the following \n * notation:<br>\n * \n * <code>(-vendor prefix)?property(value)*(!)?</code>\n * \n * <br><br>\n * <b>Abbreviation handling</b><br>\n * \n * By default, Emmet searches for matching snippet definition for provided abbreviation.\n * If snippet wasn't found, Emmet automatically generates element with \n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\n * <br><br>\n * This module will capture all expanded properties and upgrade them with values, \n * vendor prefixes and !important declarations. All unmatched abbreviations will \n * be automatically transformed into <code>property-name: ${1}</code> snippets. \n * \n * <b>Vendor prefixes<b><br>\n * \n * If CSS-property is preceded with dash, resolver should output property with\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \n * abbreviation generates <code>border-radius: ${value};</code> snippet,\n * the <code>-brad</code> abbreviation should generate:\n * <pre><code>\n * -webkit-border-radius: ${value};\n * -moz-border-radius: ${value};\n * border-radius: ${value};\n * </code></pre>\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \n * supports unprefixed property.<br><br>\n * \n * Users can also provide an explicit list of one-character prefixes for any\n * CSS property. For example, <code>-wm-float</code> will produce\n * \n * <pre><code>\n * -webkit-float: ${1};\n * -moz-float: ${1};\n * float: ${1};\n * </code></pre>\n * \n * Although this example looks pointless, users can use this feature to write\n * cutting-edge properties implemented by browser vendors recently.  \n * \n * @constructor\n * @memberOf __cssResolverDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssResolver', function(require, _) {\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar prefixObj = {\n\t\t/** Real vendor prefix name */\n\t\tprefix: 'emmet',\n\t\t\n\t\t/** \n\t\t * Indicates this prefix is obsolete and should't be used when user \n\t\t * wants to generate all-prefixed properties\n\t\t */\n\t\tobsolete: false,\n\t\t\n\t\t/**\n\t\t * Returns prefixed CSS property name\n\t\t * @param {String} name Unprefixed CSS property\n\t\t */\n\t\ttransformName: function(name) {\n\t\t\treturn '-' + this.prefix + '-' + name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * List of unprefixed CSS properties that supported by \n\t\t * current prefix. This list is used to generate all-prefixed property\n\t\t * @returns {Array} \n\t\t */\n\t\tproperties: function() {\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if given property is supported by current prefix\n\t\t * @param name\n\t\t */\n\t\tsupports: function(name) {\n\t\t\treturn _.include(this.properties(), name);\n\t\t}\n\t};\n\t\n\t\n\t/** \n\t * List of registered one-character prefixes. Key is a one-character prefix, \n\t * value is an <code>prefixObj</code> object\n\t */\n\tvar vendorPrefixes = {};\n\t\n\tvar defaultValue = '${1};';\n\t\n\t// XXX module preferences\n\tvar prefs = require('preferences');\n\tprefs.define('css.valueSeparator', ': ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations.');\n\tprefs.define('css.propertyEnd', ';',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations.');\n\t\n\tprefs.define('stylus.valueSeparator', ' ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\n\tprefs.define('stylus.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\n\t\n\tprefs.define('sass.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\n\t\n\tprefs.define('css.autoInsertVendorPrefixes', true,\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\n\t\t\t+ 'properties only when you put dash before abbreviation ' \n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you don’t ' \n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \n\t\t\t+ 'vendor-prefixed properties for you.');\n\t\n\tvar descTemplate = _.template('A comma-separated list of CSS properties that may have ' \n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \n\t\t+ 'have <code><%= vendor %></code> prefix.');\n\t\n\tvar descAddonTemplate = _.template('A comma-separated list of <em>additional</em> CSS properties ' \n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\n\t\n\t// properties list is created from cssFeatures.html file\n\tvar props = {\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode',\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\n\t};\n\t\n\t_.each(props, function(v, k) {\n\t\tprefs.define('css.' + k + 'Properties', v, descTemplate({vendor: k}));\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\n\t});\n\t\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \n\t\t\t'The list of properties whose values ​​must not contain units.');\n\t\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\n\t\n\tprefs.define('css.keywords', 'auto, inherit', \n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\n\t\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\n\t\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\n\t\n\tprefs.define('css.color.short', true, \n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\n\t\n\tprefs.define('css.color.case', 'keep', \n\t\t\t'Letter case of color values generated by abbreviations with color '\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\n\t\n\tprefs.define('css.fuzzySearch', true, \n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\n\t\t\t+ '<code>oh</code>');\n\t\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\n\t\t\t+ 'higher values may reduce possible matches.');\n\t\n\tprefs.define('css.alignVendor', false, \n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \n\t\t\t+ 'will be aligned by real property name.');\n\t\n\t\n\tfunction isNumeric(ch) {\n\t\tvar code = ch && ch.charCodeAt(0);\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\n\t}\n\t\n\t/**\n\t * Check if provided snippet contains only one CSS property and value.\n\t * @param {String} snippet\n\t * @returns {Boolean}\n\t */\n\tfunction isSingleProperty(snippet) {\n\t\tvar utils = require('utils');\n\t\tsnippet = utils.trim(snippet);\n\t\t\n\t\t// check if it doesn't contain a comment and a newline\n\t\tif (~snippet.indexOf('/*') || /[\\n\\r]/.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// check if it's a valid snippet definition\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tsnippet = require('tabStops').processText(snippet, {\n\t\t\treplaceCarets: true,\n\t\t\ttabstop: function() {\n\t\t\t\treturn 'value';\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn snippet.split(':').length == 2;\n\t}\n\t\n\t/**\n\t * Normalizes abbreviated value to final CSS one\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction normalizeValue(value) {\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\n\t\t\tvalue = value.replace(/^\\-+/, '');\n\t\t}\n\t\t\n\t\tif (value.charAt(0) == '#') {\n\t\t\treturn normalizeHexColor(value);\n\t\t}\n\t\t\n\t\treturn getKeyword(value);\n\t}\n\t\n\tfunction normalizeHexColor(value) {\n\t\tvar hex = value.replace(/^#+/, '') || '0';\n\t\tif (hex.toLowerCase() == 't') {\n\t\t\treturn 'transparent';\n\t\t}\n\t\t\n\t\tvar repeat = require('utils').repeatString;\n\t\tvar color = null;\n\t\tswitch (hex.length) {\n\t\t\tcase 1:\n\t\t\t\tcolor = repeat(hex, 6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolor = repeat(hex, 3);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcolor = hex + hex.substr(0, 2);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = hex + hex.charAt(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcolor = hex.substr(0, 6);\n\t\t}\n\t\t\n\t\t// color must be shortened?\n\t\tif (prefs.get('css.color.short')) {\n\t\t\tvar p = color.split('');\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\n\t\t\t\tcolor = p[0] + p[2] + p[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// should transform case?\n\t\tswitch (prefs.get('css.color.case')) {\n\t\t\tcase 'upper':\n\t\t\t\tcolor = color.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tcolor = color.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn '#' + color;\n\t}\n\t\n\tfunction getKeyword(name) {\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction getUnit(name) {\n\t\tvar aliases = prefs.getDict('css.unitAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction isValidKeyword(keyword) {\n\t\treturn _.include(prefs.getArray('css.keywords'), getKeyword(keyword));\n\t}\n\t\n\t/**\n\t * Check if passed CSS property support specified vendor prefix \n\t * @param {String} property\n\t * @param {String} prefix\n\t */\n\tfunction hasPrefix(property, prefix) {\n\t\tvar info = vendorPrefixes[prefix];\n\t\t\n\t\tif (!info)\n\t\t\tinfo = _.find(vendorPrefixes, function(data) {\n\t\t\t\treturn data.prefix == prefix;\n\t\t\t});\n\t\t\n\t\treturn info && info.supports(property);\n\t}\n\t\n\t/**\n\t * Search for a list of supported prefixes for CSS property. This list\n\t * is used to generate all-prefixed snippet\n\t * @param {String} property CSS property name\n\t * @returns {Array}\n\t */\n\tfunction findPrefixes(property, noAutofill) {\n\t\tvar result = [];\n\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\tif (hasPrefix(property, prefix)) {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (!result.length && !noAutofill) {\n\t\t\t// add all non-obsolete prefixes\n\t\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\t\tif (!obj.obsolete)\n\t\t\t\t\tresult.push(prefix);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tfunction addPrefix(name, obj) {\n\t\tif (_.isString(obj))\n\t\t\tobj = {prefix: obj};\n\t\t\n\t\tvendorPrefixes[name] = _.extend({}, prefixObj, obj);\n\t}\n\t\n\tfunction getSyntaxPreference(name, syntax) {\n\t\tif (syntax) {\n\t\t\tvar val = prefs.get(syntax + '.' + name);\n\t\t\tif (!_.isUndefined(val))\n\t\t\t\treturn val;\n\t\t}\n\t\t\n\t\treturn prefs.get('css.' + name);\n\t}\n\t\n\t/**\n\t * Format CSS property according to current syntax dialect\n\t * @param {String} property\n\t * @param {String} syntax\n\t * @returns {String}\n\t */\n\tfunction formatProperty(property, syntax) {\n\t\tvar ix = property.indexOf(':');\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\n\t\t\t+ require('utils').trim(property.substring(ix + 1));\n\t\t\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\n\t}\n\t\n\t/**\n\t * Transforms snippet value if required. For example, this transformation\n\t * may add <i>!important</i> declaration to CSS property\n\t * @param {String} snippet\n\t * @param {Boolean} isImportant\n\t * @returns {String}\n\t */\n\tfunction transformSnippet(snippet, isImportant, syntax) {\n\t\tif (!_.isString(snippet))\n\t\t\tsnippet = snippet.data;\n\t\t\n\t\tif (!isSingleProperty(snippet))\n\t\t\treturn snippet;\n\t\t\n\t\tif (isImportant) {\n\t\t\tif (~snippet.indexOf(';')) {\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\n\t\t\t} else {\n\t\t\t\tsnippet += ' !important';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn formatProperty(snippet, syntax);\n\t}\n\t\n\t/**\n\t * Helper function that parses comma-separated list of elements into array\n\t * @param {String} list\n\t * @returns {Array}\n\t */\n\tfunction parseList(list) {\n\t\tvar result = _.map((list || '').split(','), require('utils').trim);\n\t\treturn result.length ? result : null;\n\t}\n\t\n\tfunction getProperties(key) {\n\t\tvar list = prefs.getArray(key);\n\t\t_.each(prefs.getArray(key + 'Addon'), function(prop) {\n\t\t\tif (prop.charAt(0) == '-') {\n\t\t\t\tlist = _.without(list, prop.substr(1));\n\t\t\t} else {\n\t\t\t\tif (prop.charAt(0) == '+')\n\t\t\t\t\tprop = prop.substr(1);\n\t\t\t\t\n\t\t\t\tlist.push(prop);\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn list;\n\t}\n\t\n\t\n\t// TODO refactor, this looks awkward now\n\taddPrefix('w', {\n\t\tprefix: 'webkit'\n\t});\n\taddPrefix('m', {\n\t\tprefix: 'moz'\n\t});\n\taddPrefix('s', {\n\t\tprefix: 'ms'\n\t});\n\taddPrefix('o', {\n\t\tprefix: 'o'\n\t});\n\t\n\t// I think nobody uses it\n//\taddPrefix('k', {\n//\t\tprefix: 'khtml',\n//\t\tobsolete: true\n//\t});\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus'];\n\t\n\t/**\n\t * XXX register resolver\n\t * @param {TreeNode} node\n\t * @param {String} syntax\n\t */\n\trequire('resources').addResolver(function(node, syntax) {\n\t\tif (_.include(cssSyntaxes, syntax) && node.isElement()) {\n\t\t\treturn module.expandToSnippet(node.abbreviation, syntax);\n\t\t}\n\t\t\n\t\treturn null;\n\t});\n\t\n\tvar ea = require('expandAbbreviation');\n\t/**\n\t * For CSS-like syntaxes, we need to handle a special use case. Some editors\n\t * (like Sublime Text 2) may insert semicolons automatically when user types\n\t * abbreviation. After expansion, user receives a double semicolon. This\n\t * handler automatically removes semicolon from generated content in such cases.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\tea.addHandler(function(editor, syntax, profile) {\n\t\tif (!_.include(cssSyntaxes, syntax)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = ea.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile);\n\t\t\tif (content) {\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\n\t\t\t\tvar replaceTo = caretPos;\n\t\t\t\tif (editor.getContent().charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\n\t\t\t\t\treplaceTo++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds vendor prefix\n\t\t * @param {String} name One-character prefix name\n\t\t * @param {Object} obj Object describing vendor prefix\n\t\t * @memberOf cssResolver\n\t\t */\n\t\taddPrefix: addPrefix,\n\t\t\n\t\t/**\n\t\t * Check if passed CSS property supports specified vendor prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t */\n\t\tsupportsPrefix: hasPrefix,\n\t\t\n\t\t/**\n\t\t * Returns prefixed version of passed CSS property, only if this\n\t\t * property supports such prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t * @returns\n\t\t */\n\t\tprefixed: function(property, prefix) {\n\t\t\treturn hasPrefix(property, prefix) \n\t\t\t\t? '-' + prefix + '-' + property \n\t\t\t\t: property;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all registered vendor prefixes\n\t\t * @returns {Array}\n\t\t */\n\t\tlistPrefixes: function() {\n\t\t\treturn _.map(vendorPrefixes, function(obj) {\n\t\t\t\treturn obj.prefix;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns object describing vendor prefix\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetPrefix: function(name) {\n\t\t\treturn vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes prefix object\n\t\t * @param {String} name\n\t\t */\n\t\tremovePrefix: function(name) {\n\t\t\tif (name in vendorPrefixes)\n\t\t\t\tdelete vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract vendor prefixes from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of prefixes and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractPrefixes: function(abbr) {\n\t\t\tif (abbr.charAt(0) != '-') {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tprefixes: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\n\t\t\t// or just dash, meaning that user wants to produce all possible\n\t\t\t// prefixed properties\n\t\t\tvar i = 1, il = abbr.length, ch;\n\t\t\tvar prefixes = [];\n\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (ch == '-') {\n\t\t\t\t\t// end-sequence character found, stop searching\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ch in vendorPrefixes) {\n\t\t\t\t\tprefixes.push(ch);\n\t\t\t\t} else {\n\t\t\t\t\t// no prefix found, meaning user want to produce all\n\t\t\t\t\t// vendor-prefixed properties\n\t\t\t\t\tprefixes.length = 0;\n\t\t\t\t\ti = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// reached end of abbreviation and no property name left\n\t\t\tif (i == il -1) {\n\t\t\t\ti = 1;\n\t\t\t\tprefixes.length = 1;\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(i),\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for value substring in abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {String} Value substring\n\t\t */\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\t\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (isNumeric(ch) || ch == '#' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\n\t\t\t\t\tvalue = abbr.substring(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// try to find keywords in abbreviation\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\n\t\t\tvar res = require('resources');\n\t\t\tvar keywords = [];\n\t\t\t// try to extract some commonly-used properties\n\t\t\twhile (~property.indexOf('-') && !res.findSnippet(syntax, property)) {\n\t\t\t\tvar parts = property.split('-');\n\t\t\t\tvar lastPart = parts.pop();\n\t\t\t\tif (!isValidKeyword(lastPart)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkeywords.unshift(lastPart);\n\t\t\t\tproperty = parts.join('-');\n\t\t\t}\n\t\t\t\n\t\t\treturn keywords.join('-') + value;\n\t\t},\n\t\t\n\t\tparseValues: function(str) {\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(str);\n\t\t\tvar values = [];\n\t\t\tvar ch = null;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '#') {\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+/i, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '-') {\n\t\t\t\t\tif (isValidKeyword(_.last(values)) || \n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else {\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn _.map(_.compact(values), normalizeValue);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts values from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of values and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractValues: function(abbr) {\n\t\t\t// search for value start\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\n\t\t\tif (!abbrValues) {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tvalues: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\n\t\t\t\tvalues: this.parseValues(abbrValues)\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes value, defined in abbreviation.\n\t\t * @param {String} value\n\t\t * @param {String} property\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeValue: function(value, property) {\n\t\t\tproperty = (property || '').toLowerCase();\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\n\t\t\t\tif (!unit && (val == '0' || _.include(unitlessProps, property)))\n\t\t\t\t\treturn val;\n\t\t\t\t\n\t\t\t\tif (!unit)\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\n\t\t\t\t\n\t\t\t\treturn val + getUnit(unit);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Expands abbreviation into a snippet\n\t\t * @param {String} abbr Abbreviation name to expand\n\t\t * @param {String} value Abbreviation value\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\n\t\t * @returns {Object} Array of CSS properties and values or predefined\n\t\t * snippet (string or element)\n\t\t */\n\t\texpand: function(abbr, value, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\tvar resources = require('resources');\n\t\t\tvar autoInsertPrefixes = prefs.get('css.autoInsertVendorPrefixes');\n\t\t\t\n\t\t\t// check if snippet should be transformed to !important\n\t\t\tvar isImportant;\n\t\t\tif (isImportant = /^(.+)\\!$/.test(abbr)) {\n\t\t\t\tabbr = RegExp.$1;\n\t\t\t}\n\t\t\t\n\t\t\t// check if we have abbreviated resource\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\n\t\t\tif (snippet && !autoInsertPrefixes) {\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\n\t\t\t}\n\t\t\t\n\t\t\t// no abbreviated resource, parse abbreviation\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\n\t\t\tvar abbrData = _.extend(prefixData, valuesData);\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\n\t\t\t} else {\n\t\t\t\tabbrData.values = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\t\t// let’s try fuzzy search\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\n\t\t\t} else if (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\tif (!isSingleProperty(snippet)) {\n\t\t\t\treturn snippet;\n\t\t\t}\n\t\t\t\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\n\t\t\tvar result = [];\n\t\t\tif (!value && abbrData.values) {\n\t\t\t\tvalue = _.map(abbrData.values, function(val) {\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\n\t\t\t\t}, this).join(' ') + ';';\n\t\t\t}\n\t\t\t\n\t\t\tsnippetObj.value = value || snippetObj.value;\n\t\t\t\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \n\t\t\t\t? findPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\n\t\t\t\t: abbrData.prefixes;\n\t\t\t\t\n\t\t\t\t\n\t\t\tvar names = [], propName;\n\t\t\t_.each(prefixes, function(p) {\n\t\t\t\tif (p in vendorPrefixes) {\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\n\t\t\t\t\tnames.push(propName);\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\n\t\t\t\t\t\t\tisImportant, syntax));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// put the original property\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\n\t\t\tnames.push(snippetObj.name);\n\t\t\t\n\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(names);\n\t\t\t\tresult = _.map(result, function(prop, i) {\n\t\t\t\t\treturn pads[i] + prop;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Same as <code>expand</code> method but transforms output into \n\t\t * Emmet snippet\n\t\t * @param {String} abbr\n\t\t * @param {String} syntax\n\t\t * @returns {String}\n\t\t */\n\t\texpandToSnippet: function(abbr, syntax) {\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\n\t\t\tif (_.isArray(snippet)) {\n\t\t\t\treturn snippet.join('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tif (!_.isString(snippet))\n\t\t\t\treturn snippet.data;\n\t\t\t\n\t\t\treturn String(snippet);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split snippet into a CSS property-value pair\n\t\t * @param {String} snippet\n\t\t */\n\t\tsplitSnippet: function(snippet) {\n\t\t\tvar utils = require('utils');\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar pair = snippet.split(':');\n\t\t\t\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t},\n\t\t\n\t\tgetSyntaxPreference: getSyntaxPreference,\n\t\ttransformSnippet: transformSnippet\n\t};\n});\n/**\n * 'Expand Abbreviation' handler that parses gradient definition from under \n * cursor and updates CSS rule with vendor-prefixed values.\n * \n * @memberOf __cssGradientHandlerDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssGradient', function(require, _) {\n\tvar defaultLinearDirections = ['top', 'to bottom', '0deg'];\n\t/** Back-reference to current module */\n\tvar module = null;\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\n\t\n\tvar reDeg = /\\d+deg/i;\n\tvar reKeyword = /top|bottom|left|right/i;\n\t\n\t// XXX define preferences\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \n\t\t\t+ 'be generated.');\n\t\n\tprefs.define('css.gradient.oldWebkit', true,\n\t\t\t'Generate gradient definition for old Webkit implementations');\n\t\n\tprefs.define('css.gradient.omitDefaultDirection', true,\n\t\t'Do not output default direction definition in generated gradients.');\n\t\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\n\t\t'When gradient expanded outside CSS value context, it will produce '\n\t\t\t+ 'properties with this name.');\n\t\n\tprefs.define('css.gradient.fallback', false,\n\t\t\t'With this option enabled, CSS gradient generator will produce '\n\t\t\t+ '<code>background-color</code> property with gradient first color '\n\t\t\t+ 'as fallback for old browsers.');\n\t\n\tfunction normalizeSpace(str) {\n\t\treturn require('utils').trim(str).replace(/\\s+/g, ' ');\n\t}\n\t\n\t/**\n\t * Parses linear gradient definition\n\t * @param {String}\n\t */\n\tfunction parseLinearGradient(gradient) {\n\t\tvar direction = defaultLinearDirections[0];\n\t\t\n\t\t// extract tokens\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(require('utils').trim(gradient));\n\t\tvar colorStops = [], ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\tcolorStops.push(stream.current());\n\t\t\t\tstream.next();\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\n\t\t\t\tstream.skipTo(')');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add last token\n\t\tcolorStops.push(stream.current());\n\t\tcolorStops = _.compact(_.map(colorStops, normalizeSpace));\n\t\t\n\t\tif (!colorStops.length)\n\t\t\treturn null;\n\t\t\n\t\t// let's see if the first color stop is actually a direction\n\t\tif (reDeg.test(colorStops[0]) || reKeyword.test(colorStops[0])) {\n\t\t\tdirection = colorStops.shift();\n\t\t}\n\t\t\n\t\treturn {\n\t\t\ttype: 'linear',\n\t\t\tdirection: direction,\n\t\t\tcolorStops: _.map(colorStops, parseColorStop)\n\t\t};\n\t}\n\t\n\t/**\n\t * Parses color stop definition\n\t * @param {String} colorStop\n\t * @returns {Object}\n\t */\n\tfunction parseColorStop(colorStop) {\n\t\tcolorStop = normalizeSpace(colorStop);\n\t\t\n\t\t// find color declaration\n\t\t// first, try complex color declaration, like rgb(0,0,0)\n\t\tvar color = null;\n\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\n\t\t\tcolor = c;\n\t\t\treturn '';\n\t\t});\n\t\t\n\t\tif (!color) {\n\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\n\t\t\tvar parts = colorStop.split(' ');\n\t\t\tcolor = parts[0];\n\t\t\tcolorStop = parts[1] || '';\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tcolor: color\n\t\t};\n\t\t\n\t\tif (colorStop) {\n\t\t\t// there's position in color stop definition\n\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\n\t\t\t\tresult.position = pos;\n\t\t\t\tif (~pos.indexOf('.')) {\n\t\t\t\t\tunit = '';\n\t\t\t\t} else if (!unit) {\n\t\t\t\t\tunit = '%';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (unit)\n\t\t\t\t\tresult.unit = unit;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Resolves property name (abbreviation): searches for snippet definition in \n\t * 'resources' and returns new name of matched property\n\t */\n\tfunction resolvePropertyName(name, syntax) {\n\t\tvar res = require('resources');\n\t\tvar prefs = require('preferences');\n\t\tvar snippet = res.findSnippet(syntax, name);\n\t\t\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\tsnippet = res.fuzzyFindSnippet(syntax, name, \n\t\t\t\t\tparseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t}\n\t\t\n\t\tif (snippet) {\n\t\t\tif (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\treturn require('cssResolver').splitSnippet(snippet).name;\n\t\t}\n\t}\n\t\n\t/**\n\t * Fills-out implied positions in color-stops. This function is useful for\n\t * old Webkit gradient definitions\n\t */\n\tfunction fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\t\t\n\t\t_.each(colorStops, function(cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i)\n\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs))\n\t\t\t\tcs.position = 1;\n\t\t\t\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function(cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Returns textual version of direction expressed in degrees\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction textualDirection(direction) {\n\t\tvar angle = parseFloat(direction);\n\t\t\n\t\tif(!_.isNaN(angle)) {\n\t\t\tswitch(angle % 360) {\n\t\t\t\tcase 0:   return 'left';\n\t\t\t\tcase 90:  return 'bottom';\n\t\t\t\tcase 180: return 'right';\n\t\t\t\tcase 240: return 'top';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn direction;\n\t}\n\t\n\t/**\n\t * Creates direction definition for old Webkit gradients\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction oldWebkitDirection(direction) {\n\t\tdirection = textualDirection(direction);\n\t\t\n\t\tif(reDeg.test(direction))\n\t\t\tthrow \"The direction is an angle that can’t be converted.\";\n\t\t\n\t\tvar v = function(pos) {\n\t\t\treturn ~direction.indexOf(pos) ? '100%' : '0';\n\t\t};\n\t\t\n\t\treturn v('right') + ' ' + v('bottom') + ', ' + v('left') + ' ' + v('top');\n\t}\n\t\n\tfunction getPrefixedNames(name) {\n\t\tvar prefixes = prefs.getArray('css.gradient.prefixes');\n\t\tvar names = prefixes \n\t\t\t? _.map(prefixes, function(p) {\n\t\t\t\treturn '-' + p + '-' + name;\n\t\t\t}) \n\t\t\t: [];\n\t\t\n\t\tnames.push(name);\n\t\t\n\t\treturn names;\n\t}\n\t\n\t/**\n\t * Returns list of CSS properties with gradient\n\t * @param {Object} gradient\n\t * @param {String} propertyName Original CSS property name\n\t * @returns {Array}\n\t */\n\tfunction getPropertiesForGradient(gradient, propertyName) {\n\t\tvar props = [];\n\t\tvar css = require('cssResolver');\n\t\t\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\n\t\t\tprops.push({\n\t\t\t\tname: 'background-color',\n\t\t\t\tvalue: '${1:' + gradient.colorStops[0].color + '}'\n\t\t\t});\n\t\t}\n\t\t\n\t\t_.each(prefs.getArray('css.gradient.prefixes'), function(prefix) {\n\t\t\tvar name = css.prefixed(propertyName, prefix);\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\n\t\t\t\ttry {\n\t\t\t\t\tprops.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: module.oldWebkitLinearGradient(gradient)\n\t\t\t\t\t});\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t\t\n\t\t\tprops.push({\n\t\t\t\tname: name,\n\t\t\t\tvalue: module.toString(gradient, prefix)\n\t\t\t});\n\t\t});\n\t\t\n\t\treturn props.sort(function(a, b) {\n\t\t\treturn b.name.length - a.name.length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\n\t * @param {EditElement} property Matched CSS property\n\t * @param {Object} gradient Parsed gradient\n\t * @param {Range} valueRange If passed, only this range within property \n\t * value will be replaced with gradient. Otherwise, full value will be \n\t * replaced\n\t */\n\tfunction pasteGradient(property, gradient, valueRange) {\n\t\tvar rule = property.parent;\n\t\tvar utils = require('utils');\n\t\tvar alignVendor = require('preferences').get('css.alignVendor');\n\t\t\n\t\t// we may have aligned gradient definitions: find the smallest value\n\t\t// separator\n\t\tvar sep = property.styleSeparator;\n\t\tvar before = property.styleBefore;\n\t\t\n\t\t// first, remove all properties within CSS rule with the same name and\n\t\t// gradient definition\n\t\t_.each(rule.getAll(getPrefixedNames(property.name())), function(item) {\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\n\t\t\t\t\tsep = item.styleSeparator;\n\t\t\t\t}\n\t\t\t\tif (item.styleBefore.length < before.length) {\n\t\t\t\t\tbefore = item.styleBefore;\n\t\t\t\t}\n\t\t\t\trule.remove(item);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (alignVendor) {\n\t\t\t// update prefix\n\t\t\tif (before != property.styleBefore) {\n\t\t\t\tvar fullRange = property.fullRange();\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\n\t\t\t\tproperty.styleBefore = before;\n\t\t\t}\n\t\t\t\n\t\t\t// update separator value\n\t\t\tif (sep != property.styleSeparator) {\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\n\t\t\t\tproperty.styleSeparator = sep;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar value = property.value();\n\t\tif (!valueRange)\n\t\t\tvalueRange = require('range').create(0, property.value());\n\t\t\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, valueRange);\n\t\t};\n\t\t\n\t\t// put vanilla-clean gradient definition into current rule\n\t\tproperty.value(val(module.toString(gradient)) + '${2}');\n\t\t\n\t\t// create list of properties to insert\n\t\tvar propsToInsert = getPropertiesForGradient(gradient, property.name());\n\t\t\n\t\t// align prefixed values\n\t\tif (alignVendor) {\n\t\t\tvar values = _.pluck(propsToInsert, 'value');\n\t\t\tvar names = _.pluck(propsToInsert, 'name');\n\t\t\tvalues.push(property.value());\n\t\t\tnames.push(property.name());\n\t\t\t\n\t\t\tvar valuePads = utils.getStringsPads(_.map(values, function(v) {\n\t\t\t\treturn v.substring(0, v.indexOf('('));\n\t\t\t}));\n\t\t\t\n\t\t\tvar namePads = utils.getStringsPads(names);\n\t\t\tproperty.name(_.last(namePads) + property.name());\n\t\t\t\n\t\t\t_.each(propsToInsert, function(prop, i) {\n\t\t\t\tprop.name = namePads[i] + prop.name;\n\t\t\t\tprop.value = valuePads[i] + prop.value;\n\t\t\t});\n\t\t\t\n\t\t\tproperty.value(_.last(valuePads) + property.value());\n\t\t}\n\t\t\n\t\t// put vendor-prefixed definitions before current rule\n\t\t_.each(propsToInsert, function(prop) {\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS property value\n\t */\n\tfunction findGradient(cssProp) {\n\t\tvar value = cssProp.value();\n\t\tvar gradient = null;\n\t\tvar matchedPart = _.find(cssProp.valueParts(), function(part) {\n\t\t\treturn gradient = module.parse(part.substring(value));\n\t\t});\n\t\t\n\t\tif (matchedPart && gradient) {\n\t\t\treturn {\n\t\t\t\tgradient: gradient,\n\t\t\t\tvalueRange: matchedPart\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Tries to expand gradient outside CSS value \n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t */\n\tfunction expandGradientOutsideValue(editor, syntax) {\n\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\n\t\t\n\t\tif (!propertyName)\n\t\t\treturn false;\n\t\t\n\t\t// assuming that gradient definition is written on new line,\n\t\t// do a simplified parsing\n\t\tvar content = String(editor.getContent());\n\t\t/** @type Range */\n\t\tvar lineRange = require('range').create(editor.getCurrentLineRange());\n\t\t\n\t\t// get line content and adjust range with padding\n\t\tvar line = lineRange.substring(content)\n\t\t\t.replace(/^\\s+/, function(pad) {\n\t\t\t\tlineRange.start += pad.length;\n\t\t\t\treturn '';\n\t\t\t})\n\t\t\t.replace(/\\s+$/, function(pad) {\n\t\t\t\tlineRange.end -= pad.length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\n\t\tvar css = require('cssResolver');\n\t\tvar gradient = module.parse(line);\n\t\tif (gradient) {\n\t\t\tvar props = getPropertiesForGradient(gradient, propertyName);\n\t\t\tprops.push({\n\t\t\t\tname: propertyName,\n\t\t\t\tvalue: module.toString(gradient) + '${2}'\n\t\t\t});\n\t\t\t\n\t\t\tvar sep = css.getSyntaxPreference('valueSeparator', syntax);\n\t\t\tvar end = css.getSyntaxPreference('propertyEnd', syntax);\n\t\t\t\n\t\t\tif (require('preferences').get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(_.map(props, function(prop) {\n\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\n\t\t\t\t}));\n\t\t\t\t_.each(props, function(prop, i) {\n\t\t\t\t\tprop.value = pads[i] + prop.value;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tprops = _.map(props, function(item) {\n\t\t\t\treturn item.name + sep + item.value + end;\n\t\t\t});\n\t\t\t\n\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS value under cursor\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @returns {Object}\n\t */\n\tfunction findGradientFromPosition(content, pos) {\n\t\tvar cssProp = null;\n\t\t/** @type EditContainer */\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(content, pos, true);\n\t\t\n\t\tif (cssRule) {\n\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\n\t\t\tif (!cssProp) {\n\t\t\t\t// in case user just started writing CSS property\n\t\t\t\t// and didn't include semicolon–try another approach\n\t\t\t\tcssProp = _.find(cssRule.list(), function(elem) {\n\t\t\t\t\treturn elem.range(true).end == pos;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn {\n\t\t\trule: cssRule,\n\t\t\tproperty: cssProp\n\t\t};\n\t}\n\t\n\t// XXX register expand abbreviation handler\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\trequire('expandAbbreviation').addHandler(function(editor, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tif (!_.include(cssSyntaxes, info.syntax))\n\t\t\treturn false;\n\t\t\n\t\t// let's see if we are expanding gradient definition\n\t\tvar caret = editor.getCaretPos();\n\t\tvar content = info.content;\n\t\tvar css = findGradientFromPosition(content, caret);\n\t\t\n\t\tif (css.property) {\n\t\t\t// make sure that caret is inside property value with gradient \n\t\t\t// definition\n\t\t\tvar g = findGradient(css.property);\n\t\t\tif (g) {\n\t\t\t\tvar ruleStart = css.rule.options.offset || 0;\n\t\t\t\tvar ruleEnd = ruleStart + css.rule.toString().length;\n\t\t\t\t\n\t\t\t\t// Handle special case:\n\t\t\t\t// user wrote gradient definition between existing CSS \n\t\t\t\t// properties and did not finished it with semicolon.\n\t\t\t\t// In this case, we have semicolon right after gradient \n\t\t\t\t// definition and re-parse rule again\n\t\t\t\tif (/[\\n\\r]/.test(css.property.value())) {\n\t\t\t\t\t// insert semicolon at the end of gradient definition\n\t\t\t\t\tvar insertPos = css.property.valueRange(true).start + g.valueRange.end;\n\t\t\t\t\tcontent = require('utils').replaceSubstring(content, ';', insertPos);\n\t\t\t\t\tvar newCss = findGradientFromPosition(content, caret);\n\t\t\t\t\tif (newCss.property) {\n\t\t\t\t\t\tg = findGradient(newCss.property);\n\t\t\t\t\t\tcss = newCss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// make sure current property has terminating semicolon\n\t\t\t\tcss.property.end(';');\n\t\t\t\t\n\t\t\t\t// resolve CSS property name\n\t\t\t\tvar resolvedName = resolvePropertyName(css.property.name(), syntax);\n\t\t\t\tif (resolvedName) {\n\t\t\t\t\tcss.property.name(resolvedName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpasteGradient(css.property, g.gradient, g.valueRange);\n\t\t\t\teditor.replaceContent(css.rule.toString(), ruleStart, ruleEnd, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn expandGradientOutsideValue(editor, syntax);\n\t});\n\t\n\t// XXX register \"Reflect CSS Value\" action delegate\n\t/**\n\t * @param {EditElement} property\n\t */\n\trequire('reflectCSSValue').addHandler(function(property) {\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar g = findGradient(property);\n\t\tif (!g)\n\t\t\treturn false;\n\t\t\n\t\tvar value = property.value();\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, g.valueRange);\n\t\t};\n\t\t\n\t\t// reflect value for properties with the same name\n\t\t_.each(property.parent.getAll(getPrefixedNames(property.name())), function(prop) {\n\t\t\tif (prop === property)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// check if property value starts with gradient definition\n\t\t\tvar m = prop.value().match(/^\\s*(\\-([a-z]+)\\-)?linear\\-gradient/);\n\t\t\tif (m) {\n\t\t\t\tprop.value(val(module.toString(g.gradient, m[2] || '')));\n\t\t\t} else if (m = prop.value().match(/\\s*\\-webkit\\-gradient/)) {\n\t\t\t\t// old webkit gradient definition\n\t\t\t\tprop.value(val(module.oldWebkitLinearGradient(g.gradient)));\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn true;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Parses gradient definition\n\t\t * @param {String} gradient\n\t\t * @returns {Object}\n\t\t */\n\t\tparse: function(gradient) {\n\t\t\tvar result = null;\n\t\t\trequire('utils').trim(gradient).replace(/^([\\w\\-]+)\\((.+?)\\)$/, function(str, type, definition) {\n\t\t\t\t// remove vendor prefix\n\t\t\t\ttype = type.toLowerCase().replace(/^\\-[a-z]+\\-/, '');\n\t\t\t\tif (type == 'linear-gradient' || type == 'lg') {\n\t\t\t\t\tresult = parseLinearGradient(definition);\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn str;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces linear gradient definition used in early Webkit \n\t\t * implementations\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @returns {String}\n\t\t */\n\t\toldWebkitLinearGradient: function(gradient) {\n\t\t\tif (_.isString(gradient))\n\t\t\t\tgradient = this.parse(gradient);\n\t\t\t\n\t\t\tif (!gradient)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tvar colorStops = _.map(gradient.colorStops, _.clone);\n\t\t\t\n\t\t\t// normalize color-stops position\n\t\t\t_.each(colorStops, function(cs) {\n\t\t\t\tif (!('position' in cs)) // implied position\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfillImpliedPositions(colorStops);\n\t\t\t\n\t\t\t// transform color-stops into string representation\n\t\t\tcolorStops = _.map(colorStops, function(cs, i) {\n\t\t\t\tif (!cs.position && !i)\n\t\t\t\t\treturn 'from(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1)\n\t\t\t\t\treturn 'to(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\n\t\t\t});\n\t\t\t\n\t\t\treturn '-webkit-gradient(linear, ' \n\t\t\t\t+ oldWebkitDirection(gradient.direction)\n\t\t\t\t+ ', '\n\t\t\t\t+ colorStops.join(', ')\n\t\t\t\t+ ')';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of parsed gradient\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @param {String} prefix Vendor prefix\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function(gradient, prefix) {\n\t\t\tif (gradient.type == 'linear') {\n\t\t\t\tvar fn = (prefix ? '-' + prefix + '-' : '') + 'linear-gradient';\n\t\t\t\t\n\t\t\t\t// transform color-stops\n\t\t\t\tvar colorStops = _.map(gradient.colorStops, function(cs) {\n\t\t\t\t\treturn cs.color + ('position' in cs \n\t\t\t\t\t\t\t? ' ' + cs.position + (cs.unit || '')\n\t\t\t\t\t\t\t: '');\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (gradient.direction \n\t\t\t\t\t\t&& (!prefs.get('css.gradient.omitDefaultDirection') \n\t\t\t\t\t\t|| !_.include(defaultLinearDirections, gradient.direction))) {\n\t\t\t\t\tcolorStops.unshift(gradient.direction);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn fn + '(' + colorStops.join(', ') + ')';\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Module adds support for generators: a regexp-based abbreviation resolver \n * that can produce custom output.\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type HandlerList */\n\tvar generators = require('handlerList').create();\n\tvar resources = require('resources');\n\t\n\t_.extend(resources, {\n\t\t/**\n\t\t * Add generator. A generator function <code>fn</code> will be called \n\t\t * only if current abbreviation matches <code>regexp</code> regular \n\t\t * expression and this function should return <code>null</code> if\n\t\t * abbreviation cannot be resolved\n\t\t * @param {RegExp} regexp Regular expression for abbreviation element name\n\t\t * @param {Function} fn Resolver function\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddGenerator: function(regexp, fn, options) {\n\t\t\tif (_.isString(regexp))\n\t\t\t\tregexp = new RegExp(regexp);\n\t\t\t\n\t\t\tgenerators.add(function(node, syntax) {\n\t\t\t\tvar m;\n\t\t\t\tif ((m = regexp.exec(node.name()))) {\n\t\t\t\t\treturn fn(m, node, syntax);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}, options);\n\t\t}\n\t});\n\t\n\tresources.addResolver(function(node, syntax) {\n\t\treturn generators.exec(null, _.toArray(arguments));\n\t});\n});/**\n * Module for resolving tag names: returns best matched tag name for child\n * element based on passed parent's tag name. Also provides utility function\n * for element type detection (inline, block-level, empty)\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('tagName', function(require, _) {\n\tvar elementTypes = {\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\n\t\tempty: [],\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\n\t};\n\t\n\tvar elementMap = {\n\t\t'p': 'span',\n\t\t'ul': 'li',\n\t\t'ol': 'li',\n\t\t'table': 'tr',\n\t\t'tr': 'td',\n\t\t'tbody': 'tr',\n\t\t'thead': 'tr',\n\t\t'tfoot': 'tr',\n\t\t'colgroup': 'col',\n\t\t'select': 'option',\n\t\t'optgroup': 'option',\n\t\t'audio': 'source',\n\t\t'video': 'source',\n\t\t'object': 'param',\n\t\t'map': 'area'\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Returns best matched child element name for passed parent's\n\t\t * tag name\n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t * @memberOf tagName\n\t\t */\n\t\tresolve: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\t\n\t\t\tif (name in elementMap)\n\t\t\t\treturn this.getMapping(name);\n\t\t\t\n\t\t\tif (this.isInlineLevel(name))\n\t\t\t\treturn 'span';\n\t\t\t\n\t\t\treturn 'div';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns mapped child element name for passed parent's name \n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\treturn elementMap[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element name belongs to inline-level element\n\t\t * @param {String} name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element belongs to block-level element.\n\t\t * For better matching of unknown elements (for XML, for example), \n\t\t * you should use <code>!this.isInlineLevel(name)</code>\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisBlockLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is void (i.e. should not have closing tag).\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisEmptyElement: function(name) {\n\t\t\treturn this.isTypeOf(name, 'empty');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Generic function for testing if element name belongs to specified\n\t\t * elements collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} type Collection name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisTypeOf: function(name, type) {\n\t\t\treturn _.include(elementTypes[type], name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new parent–child mapping\n\t\t * @param {String} parent\n\t\t * @param {String} child\n\t\t */\n\t\taddMapping: function(parent, child) {\n\t\t\telementMap[parent] = child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes parent-child mapping\n\t\t */\n\t\tremoveMapping: function(parent) {\n\t\t\tif (parent in elementMap)\n\t\t\t\tdelete elementMap[parent];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new element into collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t */\n\t\taddElementToCollection: function(name, collection) {\n\t\t\tif (!elementTypes[collection])\n\t\t\t\telementTypes[collection] = [];\n\t\t\t\n\t\t\tvar col = this.getCollection(collection);\n\t\t\tif (!_.include(col, name))\n\t\t\t\tcol.push(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes element name from specified collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t * @returns\n\t\t */\n\t\tremoveElementFromCollection: function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns elements name collection\n\t\t * @param {String} name Collection name\n\t\t * @returns {Array}\n\t\t */\n\t\tgetCollection: function(name) {\n\t\t\treturn elementTypes[name];\n\t\t}\n\t};\n});/**\n * Filter for aiding of writing elements with complex class names as described\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\n * automatically inherit block and element names from parent elements and insert\n * them into child element classes\n * @memberOf __bemFilterDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar prefs = require('preferences');\n\tprefs.define('bem.elementSeparator', '__', 'Class name’s element separator.');\n\tprefs.define('bem.modifierSeparator', '_', 'Class name’s modifier separator.');\n\tprefs.define('bem.shortElementPrefix', '-', \n\t\t\t'Symbol for describing short “block-element” notation. Class names '\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parent‘s '\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\n\t\n\tvar shouldRunHtmlFilter = false;\n\t\n\tfunction getSeparators() {\n\t\treturn {\n\t\t\telement: prefs.get('bem.elementSeparator'),\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\n\t\t};\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction bemParse(item) {\n\t\tif (require('abbreviationUtils').isSnippet(item))\n\t\t\treturn item;\n\t\t\n\t\t// save BEM stuff in cache for faster lookups\n\t\titem.__bem = {\n\t\t\tblock: '',\n\t\t\telement: '',\n\t\t\tmodifier: ''\n\t\t};\n\t\t\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\n\t\t\n\t\t// guess best match for block name\n\t\tvar reBlockName = /^[a-z]\\-/i;\n\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\treturn reBlockName.test(name);\n\t\t});\n\t\t\n\t\t// guessing doesn't worked, pick first class name as block name\n\t\tif (!item.__bem.block) {\n\t\t\treBlockName = /^[a-z]/i;\n\t\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\t\treturn reBlockName.test(name);\n\t\t\t}) || '';\n\t\t}\n\t\t\n\t\tclassNames = _.chain(classNames)\n\t\t\t.map(function(name) {return processClassName(name, item);})\n\t\t\t.flatten()\n\t\t\t.uniq()\n\t\t\t.value()\n\t\t\t.join(' ');\n\t\t\n\t\tif (classNames)\n\t\t\titem.attribute('class', classNames);\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * @param {String} className\n\t * @returns {String}\n\t */\n\tfunction normalizeClassName(className) {\n\t\tvar utils = require('utils');\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\n\t\t\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\n\t\tif (shortSymbol) {\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\n\t\t\tclassName = className.replace(re, function(str, p1) {\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn utils.trim(className);\n\t}\n\t\n\t/**\n\t * Processes class name\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @returns Processed class name. May return <code>Array</code> of\n\t * class names \n\t */\n\tfunction processClassName(name, item) {\n\t\tname = transformClassName(name, item, 'element');\n\t\tname = transformClassName(name, item, 'modifier');\n\t\t\n\t\t// expand class name\n\t\t// possible values:\n\t\t// * block__element\n\t\t// * block__element_modifier\n\t\t// * block__element_modifier1_modifier2\n\t\t// * block_modifier\n\t\tvar block = '', element = '', modifier = '';\n\t\tvar separators = getSeparators();\n\t\tif (~name.indexOf(separators.element)) {\n\t\t\tvar blockElem = name.split(separators.element);\n\t\t\tvar elemModifiers = blockElem[1].split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockElem[0];\n\t\t\telement = elemModifiers.shift();\n\t\t\tmodifier = elemModifiers.join(separators.modifier);\n\t\t} else if (~name.indexOf(separators.modifier)) {\n\t\t\tvar blockModifiers = name.split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockModifiers.shift();\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\n\t\t}\n\t\t\n\t\tif (block || element || modifier) {\n\t\t\tif (!block) {\n\t\t\t\tblock = item.__bem.block;\n\t\t\t}\n\t\t\t\n\t\t\t// inherit parent bem element, if exists\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\n\t\t\t\n\t\t\t// produce multiple classes\n\t\t\tvar prefix = block;\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tif (element) {\n\t\t\t\tprefix += separators.element + element;\n\t\t\t\tresult.push(prefix);\n\t\t\t} else {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t\t\n\t\t\tif (modifier) {\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\n\t\t\t}\n\t\t\t\n\t\t\titem.__bem.block = block;\n\t\t\titem.__bem.element = element;\n\t\t\titem.__bem.modifier = modifier;\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t// ...otherwise, return processed or original class name\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Low-level function to transform user-typed class name into full BEM class\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @param {String} entityType Type of entity to be tried to transform \n\t * ('element' or 'modifier')\n\t * @returns {String} Processed class name or original one if it can't be\n\t * transformed\n\t */\n\tfunction transformClassName(name, item, entityType) {\n\t\tvar separators = getSeparators();\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\n\t\tif (reSep.test(name)) {\n\t\t\tvar depth = 0; // parent lookup depth\n\t\t\tvar cleanName = name.replace(reSep, function(str, p1) {\n\t\t\t\tdepth = str.length / separators[entityType].length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\t// find donor element\n\t\t\tvar donor = item;\n\t\t\twhile (donor.parent && depth--) {\n\t\t\t\tdonor = donor.parent;\n\t\t\t}\n\t\t\t\n\t\t\tif (!donor || !donor.__bem)\n\t\t\t\tdonor = item;\n\t\t\t\n\t\t\tif (donor && donor.__bem) {\n\t\t\t\tvar prefix = donor.__bem.block;\n\t\t\t\t\n\t\t\t\t// decide if we should inherit element name\n//\t\t\t\tif (entityType == 'element') {\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n\t\t\t\t\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Recursive function for processing tags, which extends class names \n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\n\t * <br><br>\n\t * It does several things:<br>\n\t * <ul>\n\t * <li>Expands complex class name (according to BEM symbol semantics):\n\t * .block__elem_modifier → .block.block__elem.block__elem_modifier\n\t * </li>\n\t * <li>Inherits block name on child elements: \n\t * .b-block > .__el > .__el → .b-block > .b-block__el > .b-block__el__el\n\t * </li>\n\t * <li>Treats first dash symbol as '__'</li>\n\t * <li>Double underscore (or typographic '–') is also treated as an element \n\t * level lookup, e.g. ____el will search for element definition in parent’s \n\t * parent element:\n\t * .b-block > .__el1 > .____el2 → .b-block > .b-block__el1 > .b-block__el2\n\t * </li>\n\t * </ul>\n\t * \n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t */\n\tfunction process(tree, profile) {\n\t\tif (tree.name)\n\t\t\tbemParse(tree, profile);\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tprocess(item, profile);\n\t\t\tif (!abbrUtils.isSnippet(item) && item.start)\n\t\t\t\tshouldRunHtmlFilter = true;\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n\t\n\trequire('filters').add('bem', function(tree, profile) {\n\t\tshouldRunHtmlFilter = false;\n\t\ttree = process(tree, profile);\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\n\t\t// to update output\n\t\tif (shouldRunHtmlFilter) {\n\t\t\ttree = require('filters').apply(tree, 'html', profile);\n\t\t}\n\t\t\n\t\treturn tree;\n\t});\n});\n\n/**\n * Comment important tags (with 'id' and 'class' attributes)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __commentFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t// define some preferences\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\tprefs.define('filter.commentAfter', \n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\n\t\t\t+ 'the following properties and functions are availabe:\\n'\n\t\t\t+ '<ul>'\n\t\t\t\n\t\t\t+ '<li><code>attr(name, before, after)</code> – a function that outputs' \n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \n\t\t\t+ 'empty string will be returned.</li>'\n\t\t\t\n\t\t\t+ '<li><code>node</code> – current node (instance of <code>AbbreviationNode</code>)</li>'\n\t\t\t\n\t\t\t+ '<li><code>name</code> – name of current tag</li>'\n\t\t\t\n\t\t\t+ '<li><code>padding</code> – current string padding, can be used ' \n\t\t\t+ 'for formatting</li>'\n\t\t\t\n\t\t\t+'</ul>');\n\t\n\tprefs.define('filter.commentBefore', \n\t\t\t'',\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\n\t\t\t+ 'property');\n\t\n\tprefs.define('filter.commentTrigger', 'id, class',\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\n\t\t\t+ 'every element, set this option to <code>*</code>');\n\t\n\t/**\n\t * Add comments to tag\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction addComments(node, templateBefore, templateAfter) {\n\t\tvar utils = require('utils');\n\t\t\n\t\t// check if comments should be added\n\t\tvar trigger = prefs.get('filter.commentTrigger');\n\t\tif (trigger != '*') {\n\t\t\tvar shouldAdd = _.find(trigger.split(','), function(name) {\n\t\t\t\treturn !!node.attribute(utils.trim(name));\n\t\t\t});\n\t\t\tif (!shouldAdd) return;\n\t\t}\n\t\t\n\t\tvar ctx = {\n\t\t\tnode: node,\n\t\t\tname: node.name(),\n\t\t\tpadding: node.parent ? node.parent.padding : '',\n\t\t\tattr: function(name, before, after) {\n\t\t\t\tvar attr = node.attribute(name);\n\t\t\t\tif (attr) {\n\t\t\t\t\treturn (before || '') + attr + (after || '');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar nodeBefore = utils.normalizeNewline(templateBefore ? templateBefore(ctx) : '');\n\t\tvar nodeAfter = utils.normalizeNewline(templateAfter ? templateAfter(ctx) : '');\n\t\t\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\n\t}\n\t\n\tfunction process(tree, before, after) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isBlock(item))\n\t\t\t\taddComments(item, before, after);\n\t\t\t\n\t\t\tprocess(item, before, after);\n\t\t});\n\t\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('c', function(tree) {\n\t\tvar templateBefore = _.template(prefs.get('filter.commentBefore'));\n\t\tvar templateAfter = _.template(prefs.get('filter.commentAfter'));\n\t\t\n\t\treturn process(tree, templateBefore, templateAfter);\n\t});\n});\n/**\n * Filter for escaping unsafe XML characters: <, >, &\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.exec(function(require, _) {\n\tvar charMap = {\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'&': '&amp;'\n\t};\n\t\n\tfunction escapeChars(str) {\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\n\t\t\treturn charMap[p1];\n\t\t});\n\t}\n\t\n\trequire('filters').add('e', function process(tree) {\n\t\t_.each(tree.children, function(item) {\n\t\t\titem.start = escapeChars(item.start);\n\t\t\titem.end = escapeChars(item.end);\n\t\t\titem.content = escapeChars(item.content);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Generic formatting filter: creates proper indentation for each tree node,\n * placing \"%s\" placeholder where the actual output should be. You can use\n * this filter to preformat tree and then replace %s placeholder to whatever you\n * need. This filter should't be called directly from editor as a part \n * of abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __formatFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _){\n\tvar placeholder = '%s';\n\t\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('format.noIndentTags', 'html', \n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\n\t\n\tprefs.define('format.forceIndentationForTags', 'body', \n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\n\t\n\t/**\n\t * Get indentation for given node\n\t * @param {AbbreviationNode} node\n\t * @returns {String}\n\t */\n\tfunction getIndentation(node) {\n\t\tif (_.include(prefs.getArray('format.noIndentTags') || [], node.name())) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\treturn require('resources').getVariable('indentation');\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && require('abbreviationUtils').hasBlockChildren(item.parent);\n\t}\n\t\n\t/**\n\t * Test if passed item is very first child in parsed tree\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\t\n\t/**\n\t * Check if a newline should be added before element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldAddLineBreak(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\n\t\t\treturn true;\n\t\t\n\t\tif (!node.parent || !profile.inline_break)\n\t\t\treturn false;\n\t\t\n\t\t// check if there are required amount of adjacent inline element\n\t\treturn shouldFormatInline(node.parent, profile);\n}\n\t\n\t/**\n\t * Need to add newline because <code>item</code> has too many inline children\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction shouldBreakChild(node, profile) {\n\t\t// we need to test only one child element, because \n\t\t// hasBlockChildren() method will do the rest\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\n\t}\n\t\n\tfunction shouldFormatInline(node, profile) {\n\t\tvar nodeCount = 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\treturn !!_.find(node.children, function(child) {\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\n\t\t\t\tnodeCount = 0;\n\t\t\telse if (abbrUtils.isInline(child))\n\t\t\t\tnodeCount++;\n\t\t\t\n\t\t\tif (nodeCount >= profile.inline_break)\n\t\t\t\treturn true;\n\t\t});\n\t}\n\t\n\tfunction isRoot(item) {\n\t\treturn !item.parent;\n\t}\n\t\n\t/**\n\t * Processes element with matched resource of type <code>snippet</code>\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processSnippet(item, profile, level) {\n\t\titem.start = item.end = '';\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\n\t\t\t// check if we’re not inside inline element\n\t\t\tif (isRoot(item.parent) || !require('abbreviationUtils').isInline(item.parent)) {\n\t\t\t\titem.start = require('utils').getNewline() + item.start;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Check if we should add line breaks inside inline element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldBreakInsideInline(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar hasBlockElems = _.any(node.children, function(child) {\n\t\t\tif (abbrUtils.isSnippet(child))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\t\t\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\titem.start = item.end = placeholder;\n\t\tvar utils = require('utils');\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar nl = utils.getNewline();\n\t\tvar indent = getIndentation(item);\n\t\t\t\n\t\t// formatting output\n\t\tif (profile.tag_nl !== false) {\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\n\t\t\tif (!forceNl) {\n\t\t\t\tforceNl = _.include(prefs.getArray('format.forceIndentationForTags') || [], item.name());\n\t\t\t}\n\t\t\t\n\t\t\t// formatting block-level elements\n\t\t\tif (!item.isTextNode()) {\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\n\t\t\t\t\t// - do not indent the very first element\n\t\t\t\t\t// - do not indent first child of a snippet\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\n\t\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\n\t\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\n\t\t\t\t\t\titem.start += nl + indent;\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\n\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\n\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.padding = indent;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('_format', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isSnippet(item))\n\t\t\t\tprocessSnippet(item, profile, level);\n\t\t\telse\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter for producing HAML code from abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __hamlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar childToken = '${child}';\n\t\n\tfunction transformClassName(className) {\n\t\treturn require('utils').trim(className).replace(/\\s+/g, '.');\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\t_.each(tag.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push(':' +attrName + ' => ' + attrQuote + (a.value || cursor) + attrQuote);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length)\n\t\t\tattrs += '{' + otherAttrs.join(', ') + '}';\n\t\t\n\t\treturn attrs;\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && item.parent.hasBlockChildren();\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\tvar start= '';\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = '%' + profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tstart = tagName + attrs + selfClosing + ' ';\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('haml', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter that produces HTML tree\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __htmlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Creates HTML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction makeAttributesString(node, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\treturn _.map(node.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (a.value || cursor) + attrQuote;\n\t\t}).join('');\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent) // looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile); \n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar start= '';\n\t\tvar end = '';\n\t\t\t\n\t\t// define opening and closing tags\n\t\tif (!item.isTextNode()) {\n\t\t\tvar tagName = profile.tagName(item.name());\n\t\t\tif (isUnary) {\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\n\t\t\t\titem.end = '';\n\t\t\t} else {\n\t\t\t\tstart = '<' + tagName + attrs + '>';\n\t\t\t\tend = '</' + tagName + '>';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\n\t\t\n\t\t// should we put caret placeholder after opening tag?\n\t\tif (\n\t\t\t\t!item.children.length \n\t\t\t\t&& !isUnary \n\t\t\t\t&& !~item.content.indexOf(cursor)\n\t\t\t\t&& !require('tabStops').extract(item.content).tabstops.length\n\t\t\t) {\n\t\t\titem.start += cursor;\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('html', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Output abbreviation on a single line (i.e. no line breaks)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __singleLineFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar rePad = /^\\s+/;\n\tvar reNl = /[\\n\\r]/g;\n\t\n\trequire('filters').add('s', function process(tree, profile, level) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\t// remove padding from item \n\t\t\t\titem.start = item.start.replace(rePad, '');\n\t\t\t\titem.end = item.end.replace(rePad, '');\n\t\t\t}\n\t\t\t\n\t\t\t// remove newlines \n\t\t\titem.start = item.start.replace(reNl, '');\n\t\t\titem.end = item.end.replace(reNl, '');\n\t\t\titem.content = item.content.replace(reNl, '');\n\t\t\t\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});\n/**\n * Trim filter: removes characters at the beginning of the text\n * content that indicates lists: numbers, #, *, -, etc.\n * \n * Useful for wrapping lists with abbreviation.\n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __trimFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('preferences').define('filter.trimRegexp', '[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\n\t\t\t'Regular expression used to remove list markers (numbers, dashes, ' \n\t\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\n\t\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \n\t\t\t+ 'documents (for example, Word documents).');\n\t\n\tfunction process(tree, re) {\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (item.content)\n\t\t\t\titem.content = item.content.replace(re, '');\n\t\t\t\n\t\t\tprocess(item, re);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('t', function(tree) {\n\t\tvar re = new RegExp(require('preferences').get('filter.trimRegexp'));\n\t\treturn process(tree, re);\n\t});\n});\n/**\n * Filter for trimming \"select\" attributes from some tags that contains\n * child elements\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __xslFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar tags = {\n\t\t'xsl:variable': 1,\n\t\t'xsl:with-param': 1\n\t};\n\t\n\t/**\n\t * Removes \"select\" attribute from node\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction trimAttribute(node) {\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\n\t}\n\t\n\trequire('filters').add('xsl', function process(tree) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \n\t\t\t\t\t&& item.children.length)\n\t\t\t\ttrimAttribute(item);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \n * <code>lorem(num)?</code> abbreviation.\n * This code is based on Django's contribution: \n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\n * <br><br>\n * Examples to test:<br>\n * <code>lipsum</code> – generates 30 words text.<br>\n * <code>lipsum*6</code> – generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\n * <code>ol>lipsum10*5</code> — generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\n * with text of 10 words on each line<br>\n * <code>span*3>lipsum20</code> – generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element .\n * Each paragraph phrase is unique   \n * @param {Function} require\n * @param {Underscore} _ \n * @constructor\n * @memberOf __loremIpsumGeneratorDefine\n */\nemmet.define('lorem', function(require, _) {\n\tvar langs = {\n\t\ten: {\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\n\t             'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\n\t             'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\n\t             'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\n\t             'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\n\t             'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\n\t             'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\n\t             'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\n\t             'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\n\t             'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\n\t             'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\n\t             'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\n\t             'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\n\t             'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\n\t             'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\n\t             'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\n\t             'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\n\t             'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\n\t             'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\n\t             'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\n\t             'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\n\t             'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\n\t             'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\n\t             'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\n\t             'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\n\t             'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\n\t             'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\n\t             'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\n\t             'maxime', 'corrupti']\n\t\t},\n\t\tru: {\n\t\t\tcommon: ['далеко-далеко', 'за', 'словесными', 'горами', 'в стране', 'гласных', 'и согласных', 'живут', 'рыбные', 'тексты'],\n\t\t\twords: ['вдали', 'от всех', 'они', 'буквенных', 'домах', 'на берегу', 'семантика', \n\t\t            'большого', 'языкового', 'океана', 'маленький', 'ручеек', 'даль', \n\t\t            'журчит', 'по всей', 'обеспечивает', 'ее','всеми', 'необходимыми', \n\t\t            'правилами', 'эта', 'парадигматическая', 'страна', 'которой', 'жаренные', \n\t\t            'предложения', 'залетают', 'прямо', 'рот', 'даже', 'всемогущая', \n\t\t            'пунктуация', 'не', 'имеет', 'власти', 'над', 'рыбными', 'текстами', \n\t\t            'ведущими', 'безорфографичный', 'образ', 'жизни', 'однажды', 'одна', \n\t\t            'маленькая', 'строчка','рыбного', 'текста', 'имени', 'lorem', 'ipsum', \n\t\t            'решила', 'выйти', 'большой', 'мир', 'грамматики', 'великий', 'оксмокс', \n\t\t            'предупреждал', 'о', 'злых', 'запятых', 'диких', 'знаках', 'вопроса', \n\t\t            'коварных', 'точках', 'запятой', 'но', 'текст', 'дал', 'сбить', \n\t\t            'себя', 'толку', 'он', 'собрал', 'семь', 'своих', 'заглавных', 'букв', \n\t\t            'подпоясал', 'инициал', 'за', 'пояс', 'пустился', 'дорогу', \n\t\t            'взобравшись', 'первую', 'вершину', 'курсивных', 'гор', 'бросил', \n\t\t            'последний', 'взгляд', 'назад', 'силуэт', 'своего', 'родного', 'города', \n\t\t            'буквоград', 'заголовок', 'деревни', 'алфавит', 'подзаголовок', 'своего', \n\t\t            'переулка', 'грустный', 'реторический', 'вопрос', 'скатился', 'его', \n\t\t            'щеке', 'продолжил', 'свой', 'путь', 'дороге', 'встретил', 'рукопись', \n\t\t            'она', 'предупредила',  'моей', 'все', 'переписывается', 'несколько', \n\t\t            'раз', 'единственное', 'что', 'меня', 'осталось', 'это', 'приставка', \n\t\t            'возвращайся', 'ты', 'лучше', 'свою', 'безопасную', 'страну', 'послушавшись', \n\t\t            'рукописи', 'наш', 'продолжил', 'свой', 'путь', 'вскоре', 'ему', \n\t\t            'повстречался', 'коварный', 'составитель', 'рекламных', 'текстов', \n\t\t            'напоивший', 'языком', 'речью', 'заманивший', 'свое', 'агенство', \n\t\t            'которое', 'использовало', 'снова', 'снова', 'своих', 'проектах', \n\t\t            'если', 'переписали', 'то', 'живет', 'там', 'до', 'сих', 'пор']\n\t\t}\n\t};\n\n\tvar prefs = require('preferences');\n\tprefs.define('lorem.defaultLang', 'en');\n\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\n\t\t\n\t\t/** @param {AbbreviationNode} node */\n\t\ttree.findAll(function(node) {\n\t\t\tif (node._name && (match = node._name.match(re))) {\n\t\t\t\tvar wordCound = match[2] || 30;\n\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\n\t\t\t\t\n\t\t\t\t// force node name resolving if node should be repeated\n\t\t\t\t// or contains attributes. In this case, node should be outputed\n\t\t\t\t// as tag, otherwise as text-only node\n\t\t\t\tnode._name = '';\n\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\n\t\t\t\tnode.data('pasteOverwrites', true);\n\t\t\t\tnode.data('paste', function(i, content) {\n\t\t\t\t\treturn paragraph(lang, wordCound, !i);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\t\n\t/**\n\t * Returns random integer between <code>from</code> and <code>to</code> values\n\t * @param {Number} from\n\t * @param {Number} to\n\t * @returns {Number}\n\t */\n\tfunction randint(from, to) {\n\t\treturn Math.round(Math.random() * (to - from) + from);\n\t}\n\t\n\t/**\n\t * @param {Array} arr\n\t * @param {Number} count\n\t * @returns {Array}\n\t */\n\tfunction sample(arr, count) {\n\t\tvar len = arr.length;\n\t\tvar iterations = Math.min(len, count);\n\t\tvar result = [];\n\t\twhile (result.length < iterations) {\n\t\t\tvar randIx = randint(0, len - 1);\n\t\t\tif (!_.include(result, randIx))\n\t\t\t\tresult.push(randIx);\n\t\t}\n\t\t\n\t\treturn _.map(result, function(ix) {\n\t\t\treturn arr[ix];\n\t\t});\n\t}\n\t\n\tfunction choice(val) {\n\t\tif (_.isString(val))\n\t\t\treturn val.charAt(randint(0, val.length - 1));\n\t\t\n\t\treturn val[randint(0, val.length - 1)];\n\t}\n\t\n\tfunction sentence(words, end) {\n\t\tif (words.length) {\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\n\t\t}\n\t\t\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots that question marks\n\t}\n\t\n\t/**\n\t * Insert commas at randomly selected words. This function modifies values\n\t * inside <code>words</code> array \n\t * @param {Array} words\n\t */\n\tfunction insertCommas(words) {\n\t\tvar len = words.length;\n\t\tvar totalCommas = 0;\n\t\t\n\t\tif (len > 3 && len <= 6) {\n\t\t\ttotalCommas = randint(0, 1);\n\t\t} else if (len > 6 && len <= 12) {\n\t\t\ttotalCommas = randint(0, 2);\n\t\t} else {\n\t\t\ttotalCommas = randint(1, 4);\n\t\t}\n\n\t\t_.each(_.range(totalCommas), function(ix) {\n\t\t\tif (ix < words.length - 1) {\n\t\t\t\twords[ix] += ',';\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Generate a paragraph of \"Lorem ipsum\" text\n\t * @param {Number} wordCount Words count in paragraph\n\t * @param {Boolean} startWithCommon Should paragraph start with common \n\t * \"lorem ipsum\" sentence.\n\t * @returns {String}\n\t */\n\tfunction paragraph(lang, wordCount, startWithCommon) {\n\t\tvar data = langs[lang];\n\t\tif (!data) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar result = [];\n\t\tvar totalWords = 0;\n\t\tvar words;\n\t\t\n\t\twordCount = parseInt(wordCount, 10);\n\t\t\n\t\tif (startWithCommon && data.common) {\n\t\t\twords = data.common.slice(0, wordCount);\n\t\t\tif (words.length > 5)\n\t\t\t\twords[4] += ',';\n\t\t\ttotalWords += words.length;\n\t\t\tresult.push(sentence(words, '.'));\n\t\t}\n\t\t\n\t\twhile (totalWords < wordCount) {\n\t\t\twords = sample(data.words, Math.min(randint(3, 12) * randint(1, 5), wordCount - totalWords));\n\t\t\ttotalWords += words.length;\n\t\t\tinsertCommas(words);\n\t\t\tresult.push(sentence(words));\n\t\t}\n\t\t\n\t\treturn result.join(' ');\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Adds new language words for Lorem Ipsum generator\n\t\t * @param {String} lang Two-letter lang definition\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \n\t\t * list of words (String), Array of words or object with <code>text</code> and\n\t\t * <code>common</code> properties\n\t\t */\n\t\taddLang: function(lang, data) {\n\t\t\tif (_.isString(data)) {\n\t\t\t\tdata = {words: _.compact(data.split(' '))};\n\t\t\t} else if (_.isArray(data)) {\n\t\t\t\tdata = {words: data};\n\t\t\t}\n\n\t\t\tlangs[lang] = data;\n\t\t}\n\t}\n});/**\n * A back-end bootstrap module with commonly used methods for loading user data\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('bootstrap', function(require, _) {\nvar snippets = {\n\t\"variables\": {\n\t\t\"lang\": \"en\",\n\t\t\"locale\": \"en-US\",\n\t\t\"charset\": \"UTF-8\",\n\t\t\"indentation\": \"\\t\",\n\t\t\"newline\": \"\\n\"\n\t},\n\t\n\t\"css\": {\n\t\t\"filters\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"@i\": \"@import url(|);\",\n\t\t\t\"@import\": \"@import url(|);\",\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\n\n\n\t\t\t\"anim\": \"animation:|;\",\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\n\t\t\t\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\n\t\t\t\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\n\t\t\t\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\n\t\t\t\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\n\t\t\t\n\t\t\t\"animn\": \"animation-name:${1:none};\",\n\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\n\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\n\t\t\t\n\t\t\t\"ap\": \"appearance:${none};\",\n\n\t\t\t\"!\": \"!important\",\n\t\t\t\"pos\": \"position:${1:relative};\",\n\t\t\t\"pos:s\": \"position:static;\",\n\t\t\t\"pos:a\": \"position:absolute;\",\n\t\t\t\"pos:r\": \"position:relative;\",\n\t\t\t\"pos:f\": \"position:fixed;\",\n\t\t\t\"t\": \"top:|;\",\n\t\t\t\"t:a\": \"top:auto;\",\n\t\t\t\"r\": \"right:|;\",\n\t\t\t\"r:a\": \"right:auto;\",\n\t\t\t\"b\": \"bottom:|;\",\n\t\t\t\"b:a\": \"bottom:auto;\",\n\t\t\t\"l\": \"left:|;\",\n\t\t\t\"l:a\": \"left:auto;\",\n\t\t\t\"z\": \"z-index:|;\",\n\t\t\t\"z:a\": \"z-index:auto;\",\n\t\t\t\"fl\": \"float:${1:left};\",\n\t\t\t\"fl:n\": \"float:none;\",\n\t\t\t\"fl:l\": \"float:left;\",\n\t\t\t\"fl:r\": \"float:right;\",\n\t\t\t\"cl\": \"clear:${1:both};\",\n\t\t\t\"cl:n\": \"clear:none;\",\n\t\t\t\"cl:l\": \"clear:left;\",\n\t\t\t\"cl:r\": \"clear:right;\",\n\t\t\t\"cl:b\": \"clear:both;\",\n\n\t\t\t\"colm\": \"columns:|;\",\n\t\t\t\"colmc\": \"column-count:|;\",\n\t\t\t\"colmf\": \"column-fill:|;\",\n\t\t\t\"colmg\": \"column-gap:|;\",\n\t\t\t\"colmr\": \"column-rule:|;\",\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\n\t\t\t\"colms\": \"column-span:|;\",\n\t\t\t\"colmw\": \"column-width:|;\",\n\n\t\t\t\"d\": \"display:${1:block};\",\n\t\t\t\"d:n\": \"display:none;\",\n\t\t\t\"d:b\": \"display:block;\",\n\t\t\t\"d:i\": \"display:inline;\",\n\t\t\t\"d:ib\": \"display:inline-block;\",\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\n\t\t\t\"d:li\": \"display:list-item;\",\n\t\t\t\"d:ri\": \"display:run-in;\",\n\t\t\t\"d:cp\": \"display:compact;\",\n\t\t\t\"d:tb\": \"display:table;\",\n\t\t\t\"d:itb\": \"display:inline-table;\",\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\n\t\t\t\"d:tbcl\": \"display:table-column;\",\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\n\t\t\t\"d:tbr\": \"display:table-row;\",\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\n\t\t\t\"d:tbc\": \"display:table-cell;\",\n\t\t\t\"d:rb\": \"display:ruby;\",\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\n\t\t\t\"v\": \"visibility:${1:hidden};\",\n\t\t\t\"v:v\": \"visibility:visible;\",\n\t\t\t\"v:h\": \"visibility:hidden;\",\n\t\t\t\"v:c\": \"visibility:collapse;\",\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\n\t\t\t\"ov:v\": \"overflow:visible;\",\n\t\t\t\"ov:h\": \"overflow:hidden;\",\n\t\t\t\"ov:s\": \"overflow:scroll;\",\n\t\t\t\"ov:a\": \"overflow:auto;\",\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\n\t\t\t\"zoo\": \"zoom:1;\",\n\t\t\t\"zm\": \"zoom:1;\",\n\t\t\t\"cp\": \"clip:|;\",\n\t\t\t\"cp:a\": \"clip:auto;\",\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\n\t\t\t\"m\": \"margin:|;\",\n\t\t\t\"m:a\": \"margin:auto;\",\n\t\t\t\"mt\": \"margin-top:|;\",\n\t\t\t\"mt:a\": \"margin-top:auto;\",\n\t\t\t\"mr\": \"margin-right:|;\",\n\t\t\t\"mr:a\": \"margin-right:auto;\",\n\t\t\t\"mb\": \"margin-bottom:|;\",\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\n\t\t\t\"ml\": \"margin-left:|;\",\n\t\t\t\"ml:a\": \"margin-left:auto;\",\n\t\t\t\"p\": \"padding:|;\",\n\t\t\t\"pt\": \"padding-top:|;\",\n\t\t\t\"pr\": \"padding-right:|;\",\n\t\t\t\"pb\": \"padding-bottom:|;\",\n\t\t\t\"pl\": \"padding-left:|;\",\n\t\t\t\"w\": \"width:|;\",\n\t\t\t\"w:a\": \"width:auto;\",\n\t\t\t\"h\": \"height:|;\",\n\t\t\t\"h:a\": \"height:auto;\",\n\t\t\t\"maw\": \"max-width:|;\",\n\t\t\t\"maw:n\": \"max-width:none;\",\n\t\t\t\"mah\": \"max-height:|;\",\n\t\t\t\"mah:n\": \"max-height:none;\",\n\t\t\t\"miw\": \"min-width:|;\",\n\t\t\t\"mih\": \"min-height:|;\",\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\n\t\t\t\"ori\": \"orientation:|;\",\n\t\t\t\"ori:l\": \"orientation:landscape;\",\n\t\t\t\"ori:p\": \"orientation:portrait;\",\n\t\t\t\"ol\": \"outline:|;\",\n\t\t\t\"ol:n\": \"outline:none;\",\n\t\t\t\"olo\": \"outline-offset:|;\",\n\t\t\t\"olw\": \"outline-width:|;\",\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\n\t\t\t\"olw:m\": \"outline-width:medium;\",\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\n\t\t\t\"ols\": \"outline-style:|;\",\n\t\t\t\"ols:n\": \"outline-style:none;\",\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\n\t\t\t\"ols:s\": \"outline-style:solid;\",\n\t\t\t\"ols:db\": \"outline-style:double;\",\n\t\t\t\"ols:g\": \"outline-style:groove;\",\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\n\t\t\t\"ols:i\": \"outline-style:inset;\",\n\t\t\t\"ols:o\": \"outline-style:outset;\",\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\n\t\t\t\"olc:i\": \"outline-color:invert;\",\n\t\t\t\"bd\": \"border:|;\",\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bd:n\": \"border:none;\",\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\n\t\t\t\"bdbk:c\": \"border-break:close;\",\n\t\t\t\"bdcl\": \"border-collapse:|;\",\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\n\t\t\t\"bdi\": \"border-image:url(|);\",\n\t\t\t\"bdi:n\": \"border-image:none;\",\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\n\t\t\t\"bdlen\": \"border-length:|;\",\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\n\t\t\t\"bdsp\": \"border-spacing:|;\",\n\t\t\t\"bds\": \"border-style:|;\",\n\t\t\t\"bds:n\": \"border-style:none;\",\n\t\t\t\"bds:h\": \"border-style:hidden;\",\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\n\t\t\t\"bds:s\": \"border-style:solid;\",\n\t\t\t\"bds:db\": \"border-style:double;\",\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\n\t\t\t\"bds:w\": \"border-style:wave;\",\n\t\t\t\"bds:g\": \"border-style:groove;\",\n\t\t\t\"bds:r\": \"border-style:ridge;\",\n\t\t\t\"bds:i\": \"border-style:inset;\",\n\t\t\t\"bds:o\": \"border-style:outset;\",\n\t\t\t\"bdw\": \"border-width:|;\",\n\t\t\t\"bdtw\": \"border-top-width:|;\",\n\t\t\t\"bdrw\": \"border-right-width:|;\",\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\n\t\t\t\"bdlw\": \"border-left-width:|;\",\n\t\t\t\"bdt\": \"border-top:|;\",\n\t\t\t\"bt\": \"border-top:|;\",\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdt:n\": \"border-top:none;\",\n\t\t\t\"bdts\": \"border-top-style:|;\",\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\n\t\t\t\"bdr\": \"border-right:|;\",\n\t\t\t\"br\": \"border-right:|;\",\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdr:n\": \"border-right:none;\",\n\t\t\t\"bdrst\": \"border-right-style:|;\",\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\n\t\t\t\"bdb\": \"border-bottom:|;\",\n\t\t\t\"bb\": \"border-bottom:|;\",\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\n\t\t\t\"bdl\": \"border-left:|;\",\n\t\t\t\"bl\": \"border-left:|;\",\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdl:n\": \"border-left:none;\",\n\t\t\t\"bdls\": \"border-left-style:|;\",\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\n\t\t\t\"bdrs\": \"border-radius:|;\",\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\n\t\t\t\"bg\": \"background:#${1:000};\",\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\n\t\t\t\"bg:n\": \"background:none;\",\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\n\t\t\t\"bgi\": \"background-image:url(|);\",\n\t\t\t\"bgi:n\": \"background-image:none;\",\n\t\t\t\"bgr\": \"background-repeat:|;\",\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\n\t\t\t\"bga\": \"background-attachment:|;\",\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\n\t\t\t\"bgpx\": \"background-position-x:|;\",\n\t\t\t\"bgpy\": \"background-position-y:|;\",\n\t\t\t\"bgbk\": \"background-break:|;\",\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\n\t\t\t\"bgo\": \"background-origin:|;\",\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\n\t\t\t\"bgsz\": \"background-size:|;\",\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\n\t\t\t\"c\": \"color:#${1:000};\",\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\n\t\t\t\"cm\": \"/* |${child} */\",\n\t\t\t\"cnt\": \"content:'|';\",\n\t\t\t\"cnt:n\": \"content:normal;\",\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\n\t\t\t\"cnt:a\": \"content:attr(|);\",\n\t\t\t\"cnt:c\": \"content:counter(|);\",\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\n\n\n\t\t\t\"tbl\": \"table-layout:|;\",\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\n\t\t\t\"cps\": \"caption-side:|;\",\n\t\t\t\"cps:t\": \"caption-side:top;\",\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\n\t\t\t\"ec\": \"empty-cells:|;\",\n\t\t\t\"ec:s\": \"empty-cells:show;\",\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\n\t\t\t\"lis\": \"list-style:|;\",\n\t\t\t\"lis:n\": \"list-style:none;\",\n\t\t\t\"lisp\": \"list-style-position:|;\",\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\n\t\t\t\"list\": \"list-style-type:|;\",\n\t\t\t\"list:n\": \"list-style-type:none;\",\n\t\t\t\"list:d\": \"list-style-type:disc;\",\n\t\t\t\"list:c\": \"list-style-type:circle;\",\n\t\t\t\"list:s\": \"list-style-type:square;\",\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\n\t\t\t\"lisi\": \"list-style-image:|;\",\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\n\t\t\t\"q\": \"quotes:|;\",\n\t\t\t\"q:n\": \"quotes:none;\",\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\n\t\t\t\"ct\": \"content:|;\",\n\t\t\t\"ct:n\": \"content:normal;\",\n\t\t\t\"ct:oq\": \"content:open-quote;\",\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\n\t\t\t\"ct:cq\": \"content:close-quote;\",\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\n\t\t\t\"ct:a\": \"content:attr(|);\",\n\t\t\t\"ct:c\": \"content:counter(|);\",\n\t\t\t\"ct:cs\": \"content:counters(|);\",\n\t\t\t\"coi\": \"counter-increment:|;\",\n\t\t\t\"cor\": \"counter-reset:|;\",\n\t\t\t\"va\": \"vertical-align:${1:top};\",\n\t\t\t\"va:sup\": \"vertical-align:super;\",\n\t\t\t\"va:t\": \"vertical-align:top;\",\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\n\t\t\t\"va:m\": \"vertical-align:middle;\",\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\n\t\t\t\"ta\": \"text-align:${1:left};\",\n\t\t\t\"ta:l\": \"text-align:left;\",\n\t\t\t\"ta:c\": \"text-align:center;\",\n\t\t\t\"ta:r\": \"text-align:right;\",\n\t\t\t\"ta:j\": \"text-align:justify;\",\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\n\t\t\t\"tal:l\": \"text-align-last:left;\",\n\t\t\t\"tal:c\": \"text-align-last:center;\",\n\t\t\t\"tal:r\": \"text-align-last:right;\",\n\t\t\t\"td\": \"text-decoration:${1:none};\",\n\t\t\t\"td:n\": \"text-decoration:none;\",\n\t\t\t\"td:u\": \"text-decoration:underline;\",\n\t\t\t\"td:o\": \"text-decoration:overline;\",\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\n\t\t\t\"te\": \"text-emphasis:|;\",\n\t\t\t\"te:n\": \"text-emphasis:none;\",\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\n\t\t\t\"te:b\": \"text-emphasis:before;\",\n\t\t\t\"te:a\": \"text-emphasis:after;\",\n\t\t\t\"th\": \"text-height:|;\",\n\t\t\t\"th:a\": \"text-height:auto;\",\n\t\t\t\"th:f\": \"text-height:font-size;\",\n\t\t\t\"th:t\": \"text-height:text-size;\",\n\t\t\t\"th:m\": \"text-height:max-size;\",\n\t\t\t\"ti\": \"text-indent:|;\",\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\n\t\t\t\"tj\": \"text-justify:|;\",\n\t\t\t\"tj:a\": \"text-justify:auto;\",\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\n\t\t\t\"to\": \"text-outline:|;\",\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\n\t\t\t\"to:n\": \"text-outline:none;\",\n\t\t\t\"tr\": \"text-replace:|;\",\n\t\t\t\"tr:n\": \"text-replace:none;\",\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\n\t\t\t\"tt:n\": \"text-transform:none;\",\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\n\t\t\t\"tw\": \"text-wrap:|;\",\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\n\t\t\t\"tw:no\": \"text-wrap:none;\",\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\n\t\t\t\"trf\": \"transform:|;\",\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\n\t\t\t\"trfo\": \"transform-origin:|;\",\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\n\t\t\t\"lh\": \"line-height:|;\",\n\t\t\t\"whs\": \"white-space:|;\",\n\t\t\t\"whs:n\": \"white-space:normal;\",\n\t\t\t\"whs:p\": \"white-space:pre;\",\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\n\t\t\t\"wob\": \"word-break:|;\",\n\t\t\t\"wob:n\": \"word-break:normal;\",\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\n\t\t\t\"wos\": \"word-spacing:|;\",\n\t\t\t\"wow\": \"word-wrap:|;\",\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\n\t\t\t\"wow:n\": \"word-wrap:none;\",\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\n\t\t\t\"lts\": \"letter-spacing:|;\",\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\n\t\t\t\"f\": \"font:|;\",\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\n\t\t\t\"fw\": \"font-weight:|;\",\n\t\t\t\"fw:n\": \"font-weight:normal;\",\n\t\t\t\"fw:b\": \"font-weight:bold;\",\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\n\t\t\t\"fs\": \"font-style:${italic};\",\n\t\t\t\"fs:n\": \"font-style:normal;\",\n\t\t\t\"fs:i\": \"font-style:italic;\",\n\t\t\t\"fs:o\": \"font-style:oblique;\",\n\t\t\t\"fv\": \"font-variant:|;\",\n\t\t\t\"fv:n\": \"font-variant:normal;\",\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\n\t\t\t\"fz\": \"font-size:|;\",\n\t\t\t\"fza\": \"font-size-adjust:|;\",\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\n\t\t\t\"ff\": \"font-family:|;\",\n\t\t\t\"ff:s\": \"font-family:serif;\",\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\n\t\t\t\"ff:c\": \"font-family:cursive;\",\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\n\t\t\t\"ff:m\": \"font-family:monospace;\",\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\n\t\t\t\"fef\": \"font-effect:|;\",\n\t\t\t\"fef:n\": \"font-effect:none;\",\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\n\t\t\t\"fef:o\": \"font-effect:outline;\",\n\t\t\t\"fem\": \"font-emphasize:|;\",\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\n\t\t\t\"fsm\": \"font-smooth:|;\",\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\n\t\t\t\"fst\": \"font-stretch:|;\",\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\n\t\t\t\"op\": \"opacity:|;\",\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\n\t\t\t\"rsz\": \"resize:|;\",\n\t\t\t\"rsz:n\": \"resize:none;\",\n\t\t\t\"rsz:b\": \"resize:both;\",\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\n\t\t\t\"rsz:v\": \"resize:vertical;\",\n\t\t\t\"cur\": \"cursor:${pointer};\",\n\t\t\t\"cur:a\": \"cursor:auto;\",\n\t\t\t\"cur:d\": \"cursor:default;\",\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\n\t\t\t\"cur:ha\": \"cursor:hand;\",\n\t\t\t\"cur:he\": \"cursor:help;\",\n\t\t\t\"cur:m\": \"cursor:move;\",\n\t\t\t\"cur:p\": \"cursor:pointer;\",\n\t\t\t\"cur:t\": \"cursor:text;\",\n\t\t\t\"pgbb\": \"page-break-before:|;\",\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\n\t\t\t\"pgba\": \"page-break-after:|;\",\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\n\t\t\t\"orp\": \"orphans:|;\",\n\t\t\t\"us\": \"user-select:${none};\",\n\t\t\t\"wid\": \"widows:|;\",\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\n\t\t}\n\t},\n\t\n\t\"html\": {\n\t\t\"filters\": \"html\",\n\t\t\"profile\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"!!!\":    \"<!doctype html>\",\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\n\n\t\t\t\"c\": \"<!-- |${child} -->\",\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\n\t\t},\n\t\t\n\t\t\"abbreviations\": {\n\t\t\t\"!\": \"html:5\",\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\n\t\t\t\"acronym\": \"<acronym title=\\\"\\\">\",\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\n\t\t\t\"basefont\": \"<basefont/>\",\n\t\t\t\"br\": \"<br/>\",\n\t\t\t\"frame\": \"<frame/>\",\n\t\t\t\"hr\": \"<hr/>\",\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\n\t\t\t\"col\": \"<col/>\",\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\n\t\t\t\"meta\": \"<meta/>\",\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}\\\" />\",\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\n\t\t\t\"style\": \"<style>\",\n\t\t\t\"script\": \"<script>\",\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\n\t\t\t\"input:hidden\": \"input[type=hidden name]\",\n\t\t\t\"input:h\": \"input:hidden\",\n\t\t\t\"input:text\": \"inp\",\n\t\t\t\"input:t\": \"inp\",\n\t\t\t\"input:search\": \"inp[type=search]\",\n\t\t\t\"input:email\": \"inp[type=email]\",\n\t\t\t\"input:url\": \"inp[type=url]\",\n\t\t\t\"input:password\": \"inp[type=password]\",\n\t\t\t\"input:p\": \"input:password\",\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\n\t\t\t\"input:date\": \"inp[type=date]\",\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\t\t\"input:month\": \"inp[type=month]\",\n\t\t\t\"input:week\": \"inp[type=week]\",\n\t\t\t\"input:time\": \"inp[type=time]\",\n\t\t\t\"input:number\": \"inp[type=number]\",\n\t\t\t\"input:color\": \"inp[type=color]\",\n\t\t\t\"input:checkbox\": \"inp[type=checkbox]\",\n\t\t\t\"input:c\": \"input:checkbox\",\n\t\t\t\"input:radio\": \"inp[type=radio]\",\n\t\t\t\"input:r\": \"input:radio\",\n\t\t\t\"input:range\": \"inp[type=range]\",\n\t\t\t\"input:file\": \"inp[type=file]\",\n\t\t\t\"input:f\": \"input:file\",\n\t\t\t\"input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\n\t\t\t\"input:s\": \"input:submit\",\n\t\t\t\"input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"input:i\": \"input:image\",\n\t\t\t\"input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\n\t\t\t\"input:b\": \"input:button\",\n\t\t\t\"isindex\": \"<isindex/>\",\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\n\t\t\t\"select:disabled\": \"select[disabled]\",\n\t\t\t\"select:d\": \"select[disabled]\",\n\t\t\t\"option\": \"<option value=\\\"\\\">\",\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\n\t\t\t\"menu:context\": \"menu[type=context]>\",\n\t\t\t\"menu:c\": \"menu:context\",\n\t\t\t\"menu:toolbar\": \"menu[type=toolbar]>\",\n\t\t\t\"menu:t\": \"menu:toolbar\",\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\n\t\t\t\"keygen\": \"<keygen/>\",\n\t\t\t\"command\": \"<command/>\",\n\t\t\t\"button:submit\" : \"button[type=submit]\",\n\t\t\t\"button:s\" : \"button[type=submit]\",\n\t\t\t\"button:reset\" : \"button[type=reset]\",\n\t\t\t\"button:r\" : \"button[type=reset]\",\n\t\t\t\"button:disabled\" : \"button[disabled]\",\n\t\t\t\"button:d\" : \"button[disabled]\",\n\t\t\t\"fieldset:disabled\" : \"fieldset[disabled]\",\n\t\t\t\"fieldset:d\" : \"fieldset[disabled]\",\n\t\t\t\n\t\t\t\"bq\": \"blockquote\",\n\t\t\t\"acr\": \"acronym\",\n\t\t\t\"fig\": \"figure\",\n\t\t\t\"figc\": \"figcaption\",\n\t\t\t\"ifr\": \"iframe\",\n\t\t\t\"emb\": \"embed\",\n\t\t\t\"obj\": \"object\",\n\t\t\t\"src\": \"source\",\n\t\t\t\"cap\": \"caption\",\n\t\t\t\"colg\": \"colgroup\",\n\t\t\t\"fst\": \"fieldset\",\n\t\t\t\"fst:d\": \"fieldset[disabled]\",\n\t\t\t\"btn\": \"button\",\n\t\t\t\"btn:b\": \"button[type=button]\",\n\t\t\t\"btn:r\": \"button[type=reset]\",\n\t\t\t\"btn:s\": \"button[type=submit]\",\n\t\t\t\"btn:d\": \"button[disabled]\",\n\t\t\t\"optg\": \"optgroup\",\n\t\t\t\"opt\": \"option\",\n\t\t\t\"tarea\": \"textarea\",\n\t\t\t\"leg\": \"legend\",\n\t\t\t\"sect\": \"section\",\n\t\t\t\"art\": \"article\",\n\t\t\t\"hdr\": \"header\",\n\t\t\t\"ftr\": \"footer\",\n\t\t\t\"adr\": \"address\",\n\t\t\t\"dlg\": \"dialog\",\n\t\t\t\"str\": \"strong\",\n\t\t\t\"prog\": \"progress\",\n\t\t\t\"fset\": \"fieldset\",\n\t\t\t\"fset:d\": \"fieldset[disabled]\",\n\t\t\t\"datag\": \"datagrid\",\n\t\t\t\"datal\": \"datalist\",\n\t\t\t\"kg\": \"keygen\",\n\t\t\t\"out\": \"output\",\n\t\t\t\"det\": \"details\",\n\t\t\t\"cmd\": \"command\",\n\t\t\t\"doc\": \"html>(head>meta[charset=UTF-8]+title{${1:Document}})+body\",\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\n\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\n\t\t\t\n\t\t\t\"ol+\": \"ol>li\",\n\t\t\t\"ul+\": \"ul>li\",\n\t\t\t\"dl+\": \"dl>dt+dd\",\n\t\t\t\"map+\": \"map>area\",\n\t\t\t\"table+\": \"table>tr>td\",\n\t\t\t\"colgroup+\": \"colgroup>col\",\n\t\t\t\"colg+\": \"colgroup>col\",\n\t\t\t\"tr+\": \"tr>td\",\n\t\t\t\"select+\": \"select>option\",\n\t\t\t\"optgroup+\": \"optgroup>option\",\n\t\t\t\"optg+\": \"optgroup>option\"\n\t\t}\n\t},\n\t\n\t\"xml\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html\"\n\t},\n\t\n\t\"xsl\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html, xsl\",\n\t\t\"abbreviations\": {\n\t\t\t\"tm\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\n\t\t\t\"tmatch\": \"tm\",\n\t\t\t\"tn\": \"<xsl:template name=\\\"\\\">\",\n\t\t\t\"tname\": \"tn\",\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\n\n\t\t\t\"ch\": \"<xsl:choose>\",\n\t\t\t\"xsl:when\": \"<xsl:when test=\\\"\\\">\",\n\t\t\t\"wh\": \"xsl:when\",\n\t\t\t\"ot\": \"<xsl:otherwise>\",\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\n\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\n\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\n\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\n\t\t\t\"each\": \"<xsl:for-each select=\\\"\\\">\",\n\t\t\t\"for\": \"each\",\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\n\n\t\t\t\"com\": \"<xsl:comment>\",\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\n\t\t\t\"fall\": \"<xsl:fallback>\",\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\n\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\n\t\t}, \n\t\t\"snippets\": {\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n\t\t}\n\t},\n\t\n\t\"haml\": {\n\t\t\"filters\": \"haml\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\t\n\t\"scss\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"sass\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"less\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"stylus\": {\n\t\t\"extends\": \"css\"\n\t},\n\n\t\"styl\": {\n\t\t\"extends\": \"stylus\"\n\t}\n}\n;\nvar res = require('resources');\nvar userData = res.getVocabulary('user') || {};\nres.setVocabulary(require('utils').deepMerge(userData, snippets), 'user');\n});\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(58)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMi1hY2UtZWRpdG9yL25vZGVfbW9kdWxlcy9lbW1ldC9lbW1ldC5qcz8zMTQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIrQ0FBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIseUJBQXlCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixFQUFFO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwrQ0FBK0MsbUNBQW1DO0FBQ2xGLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCLEVBQUU7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0MsRUFBRTtBQUM3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEIsRUFBRTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0IsRUFBRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJCQUEyQixFQUFFO0FBQ3RFO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCLHNCQUFzQix3QkFBd0Isd0JBQXdCLHdCQUF3QjtBQUMvSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDLE9BQU8sT0FBTzs7QUFFZDtBQUNBLGtEQUFrRCxFQUFFLGlCQUFpQjs7QUFFckUseUJBQXlCO0FBQ3pCLDRCQUE0QiwrQ0FBK0M7QUFDM0UsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFELHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQsV0FBVztBQUNYO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTTs7QUFFQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QjtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLCtCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7QUFDQSxhO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUzs7QUFFQTtBQUNBLGlDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsS0FBSztBQUNMLGtEQUFrRDtBQUNsRDtBQUNBLElBQUk7QUFDSixzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkM7QUFDQSxnQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFO0FBQ0YsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSyxZQUFZLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUUsWUFBWTtBQUM5RCw0RUFBNEUsVUFBVSxRQUFRLFVBQVUsRUFBRSxZQUFZOztBQUV0SCxrQ0FBa0MsS0FBSztBQUN2QyxrQ0FBa0MsS0FBSztBQUN2Qyx5RUFBeUUsS0FBSztBQUM5RSx5RUFBeUUsS0FBSztBQUM5RSwwRUFBMEUsS0FBSztBQUMvRSwrQkFBK0IsS0FBSzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixJQUFJO0FBQy9GLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI0NzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjMuM1xuLy8gICAgIChjKSAyMDA5LTIwMTIgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbi8vICAgICBVbmRlcnNjb3JlIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vICAgICBQb3J0aW9ucyBvZiBVbmRlcnNjb3JlIGFyZSBpbnNwaXJlZCBvciBib3Jyb3dlZCBmcm9tIFByb3RvdHlwZSxcbi8vICAgICBPbGl2ZXIgU3RlZWxlJ3MgRnVuY3Rpb25hbCwgYW5kIEpvaG4gUmVzaWcncyBNaWNyby1UZW1wbGF0aW5nLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmVcblxudmFyIF8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIHRvIGJyZWFrIG91dCBvZiBhIGxvb3AgaXRlcmF0aW9uLlxuICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdW5zaGlmdCAgICAgICAgICA9IEFycmF5UHJvdG8udW5zaGlmdCxcbiAgICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUZvckVhY2ggICAgICA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVNYXAgICAgICAgICAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVSZWR1Y2UgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZSxcbiAgICBuYXRpdmVSZWR1Y2VSaWdodCAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxuICAgIG5hdGl2ZUZpbHRlciAgICAgICA9IEFycmF5UHJvdG8uZmlsdGVyLFxuICAgIG5hdGl2ZUV2ZXJ5ICAgICAgICA9IEFycmF5UHJvdG8uZXZlcnksXG4gICAgbmF0aXZlU29tZSAgICAgICAgID0gQXJyYXlQcm90by5zb21lLFxuICAgIG5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVMYXN0SW5kZXhPZiAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7IHJldHVybiBuZXcgd3JhcHBlcihvYmopOyB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290WydfJ10gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS4zLjMnO1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZm9yRWFjaGAgaWYgYXZhaWxhYmxlLlxuICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaSBpbiBvYmogJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0b3IgdG8gZWFjaCBlbGVtZW50LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0pO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmVzdWx0cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlUmlnaHQgJiYgb2JqLnJlZHVjZVJpZ2h0ID09PSBuYXRpdmVSZWR1Y2VSaWdodCkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgfVxuICAgIHZhciByZXZlcnNlZCA9IF8udG9BcnJheShvYmopLnJldmVyc2UoKTtcbiAgICBpZiAoY29udGV4dCAmJiAhaW5pdGlhbCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIHJldHVybiBpbml0aWFsID8gXy5yZWR1Y2UocmV2ZXJzZWQsIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSA6IF8ucmVkdWNlKHJldmVyc2VkLCBpdGVyYXRvcik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBldmVyeWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KSByZXR1cm4gb2JqLmV2ZXJ5KGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICB2YXIgYW55ID0gXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocmVzdWx0IHx8IChyZXN1bHQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5IG9yIG9iamVjdCB1c2luZyBgPT09YC5cbiAgLy8gQWxpYXNlZCBhcyBgY29udGFpbnNgLlxuICBfLmluY2x1ZGUgPSBfLmNvbnRhaW5zID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmb3VuZDtcbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgZm91bmQgPSBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoXy5pc0Z1bmN0aW9uKG1ldGhvZCkgPyBtZXRob2QgfHwgdmFsdWUgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgb3IgKGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSkgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogLUluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPj0gcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSkgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIEluZmluaXR5O1xuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiBJbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNodWZmbGVkID0gW10sIHJhbmQ7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpbmRleCArIDEpKTtcbiAgICAgIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9ialt2YWxdOyB9O1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICBjcml0ZXJpYSA6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgaWYgKGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBmdW5jdGlvbihvYmosIHZhbCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gb2JqW3ZhbF07IH07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yKHZhbHVlLCBpbmRleCk7XG4gICAgICAocmVzdWx0W2tleV0gfHwgKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBhdCB3aGF0IGluZGV4IGFuIG9iamVjdCBzaG91bGRcbiAgLy8gYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yKSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgIGl0ZXJhdG9yKGFycmF5W21pZF0pIDwgaXRlcmF0b3Iob2JqKSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjb252ZXJ0IGFueXRoaW5nIGl0ZXJhYmxlIGludG8gYSByZWFsLCBsaXZlIGFycmF5LlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChfLmlzQXJndW1lbnRzKG9iaikpICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoudG9BcnJheSAmJiBfLmlzRnVuY3Rpb24ob2JqLnRvQXJyYXkpKSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiAobiAhPSBudWxsKSAmJiAhZ3VhcmQgPyBzbGljZS5jYWxsKGFycmF5LCAwLCBuKSA6IGFycmF5WzBdO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2NpYWx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKChuICE9IG51bGwpICYmICFndWFyZCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKmluZGV4Kiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3Qgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgZnJvbSB0aGF0IGluZGV4IG9ud2FyZC4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IGZ1bmN0aW9uKGFycmF5LCBpbmRleCwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgKGluZGV4ID09IG51bGwpIHx8IGd1YXJkID8gMSA6IGluZGV4KTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhIXZhbHVlOyB9KTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb21wbGV0ZWx5IGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFuIGFycmF5LlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBfLnJlZHVjZShhcnJheSwgZnVuY3Rpb24obWVtbywgdmFsdWUpIHtcbiAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSByZXR1cm4gbWVtby5jb25jYXQoc2hhbGxvdyA/IHZhbHVlIDogXy5mbGF0dGVuKHZhbHVlKSk7XG4gICAgICBtZW1vW21lbW8ubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgW10pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0b3IpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yKSA6IGFycmF5O1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgLy8gVGhlIGBpc1NvcnRlZGAgZmxhZyBpcyBpcnJlbGV2YW50IGlmIHRoZSBhcnJheSBvbmx5IGNvbnRhaW5zIHR3byBlbGVtZW50cy5cbiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgMykgaXNTb3J0ZWQgPSB0cnVlO1xuICAgIF8ucmVkdWNlKGluaXRpYWwsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/IF8ubGFzdChtZW1vKSAhPT0gdmFsdWUgfHwgIW1lbW8ubGVuZ3RoIDogIV8uaW5jbHVkZShtZW1vLCB2YWx1ZSkpIHtcbiAgICAgICAgbWVtby5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShfLmZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLiAoQWxpYXNlZCBhcyBcImludGVyc2VjdFwiIGZvciBiYWNrLWNvbXBhdC4pXG4gIF8uaW50ZXJzZWN0aW9uID0gXy5pbnRlcnNlY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihfLnVuaXEoYXJyYXkpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICByZXR1cm4gXy5pbmRleE9mKG90aGVyLCBpdGVtKSA+PSAwO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gXy5mbGF0dGVuKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhXy5pbmNsdWRlKHJlc3QsIHZhbHVlKTsgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgbGVuZ3RoID0gXy5tYXgoXy5wbHVjayhhcmdzLCAnbGVuZ3RoJykpO1xuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJncywgXCJcIiArIGkpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gIC8vIHdlIG5lZWQgdGhpcyBmdW5jdGlvbi4gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhblxuICAvLyBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgZm9yIChpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykgaWYgKGkgaW4gYXJyYXkgJiYgYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbGFzdEluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSByZXR1cm4gYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgaWYgKGkgaW4gYXJyYXkgJiYgYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgd2hpbGUoaWR4IDwgbGVuKSB7XG4gICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxuICB2YXIgY3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIEJpbmRpbmcgd2l0aCBhcmd1bWVudHMgaXMgYWxzbyBrbm93biBhcyBgY3VycnlgLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWYgYXZhaWxhYmxlLlxuICAvLyBXZSBjaGVjayBmb3IgYGZ1bmMuYmluZGAgZmlyc3QsIHRvIGZhaWwgZmFzdCB3aGVuIGBmdW5jYCBpcyB1bmRlZmluZWQuXG4gIF8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICAgIHZhciBib3VuZCwgYXJncztcbiAgICBpZiAoZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kICYmIG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgIHZhciBzZWxmID0gbmV3IGN0b3I7XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGFsbCBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXRcbiAgLy8gYWxsIGNhbGxiYWNrcyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09IDApIGZ1bmNzID0gXy5mdW5jdGlvbnMob2JqKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHRpbWVvdXQsIHRocm90dGxpbmcsIG1vcmUsIHJlc3VsdDtcbiAgICB2YXIgd2hlbkRvbmUgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCl7IG1vcmUgPSB0aHJvdHRsaW5nID0gZmFsc2U7IH0sIHdhaXQpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzOyBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAobW9yZSkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgd2hlbkRvbmUoKTtcbiAgICAgIH07XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmICh0aHJvdHRsaW5nKSB7XG4gICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHdoZW5Eb25lKCk7XG4gICAgICB0aHJvdHRsaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGlmIChpbW1lZGlhdGUgJiYgIXRpbWVvdXQpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICByZXR1cm4gbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtmdW5jXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGZ1bmNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIGlmICh0aW1lcyA8PSAwKSByZXR1cm4gZnVuYygpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkgeyByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogIT09IE9iamVjdChvYmopKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBlYWNoKF8uZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT0gbnVsbCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBlcShhLCBiLCBzdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIEhhcm1vbnkgYGVnYWxgIHByb3Bvc2FsOiBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEuX2NoYWluKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYi5fY2hhaW4pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIEludm9rZSBhIGN1c3RvbSBgaXNFcXVhbGAgbWV0aG9kIGlmIG9uZSBpcyBwcm92aWRlZC5cbiAgICBpZiAoYS5pc0VxdWFsICYmIF8uaXNGdW5jdGlvbihhLmlzRXF1YWwpKSByZXR1cm4gYS5pc0VxdWFsKGIpO1xuICAgIGlmIChiLmlzRXF1YWwgJiYgXy5pc0Z1bmN0aW9uKGIuaXNFcXVhbCkpIHJldHVybiBiLmlzRXF1YWwoYSk7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IHN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT0gYSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHZhciBzaXplID0gMCwgcmVzdWx0ID0gdHJ1ZTtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIC8vIEVuc3VyZSBjb21tdXRhdGl2ZSBlcXVhbGl0eSBmb3Igc3BhcnNlIGFycmF5cy5cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBzaXplIGluIGEgPT0gc2l6ZSBpbiBiICYmIGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIHN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIGlmICgnY29uc3RydWN0b3InIGluIGEgIT0gJ2NvbnN0cnVjdG9yJyBpbiBiIHx8IGEuY29uc3RydWN0b3IgIT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIHN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gYXJndW1lbnRzIG9iamVjdD9cbiAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gIH07XG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBfLmhhcyhvYmosICdjYWxsZWUnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBmdW5jdGlvbj9cbiAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBzdHJpbmc/XG4gIF8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBudW1iZXI/XG4gIF8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgaXNGaW5pdGUob2JqKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/XG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICAvLyBgTmFOYCBpcyB0aGUgb25seSB2YWx1ZSBmb3Igd2hpY2ggYD09PWAgaXMgbm90IHJlZmxleGl2ZS5cbiAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGRhdGU/XG4gIF8uaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGEgcmVndWxhciBleHByZXNzaW9uP1xuICBfLmlzUmVnRXhwID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBSZWdFeHBdJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBIYXMgb3duIHByb3BlcnR5P1xuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbiAobiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBpKTtcbiAgfTtcblxuICAvLyBFc2NhcGUgYSBzdHJpbmcgZm9yIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gKCcnK3N0cmluZykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmI3gyNzsnKS5yZXBsYWNlKC9cXC8vZywnJiN4MkY7Jyk7XG4gIH07XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0O1xuICAvLyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LCBlbnN1cmluZyB0aGF0XG4gIC8vIHRoZXkncmUgY29ycmVjdGx5IGFkZGVkIHRvIHRoZSBPT1Agd3JhcHBlciBhcyB3ZWxsLlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICAgIGFkZFRvV3JhcHBlcihuYW1lLCBfW25hbWVdID0gb2JqW25hbWVdKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9IGlkQ291bnRlcisrO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8uXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAncic6ICdcXHInLFxuICAgICduJzogJ1xcbicsXG4gICAgJ3QnOiAnXFx0JyxcbiAgICAndTIwMjgnOiAnXFx1MjAyOCcsXG4gICAgJ3UyMDI5JzogJ1xcdTIwMjknXG4gIH07XG5cbiAgZm9yICh2YXIgcCBpbiBlc2NhcGVzKSBlc2NhcGVzW2VzY2FwZXNbcF1dID0gcDtcbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xuICB2YXIgdW5lc2NhcGVyID0gL1xcXFwoXFxcXHwnfHJ8bnx0fHUyMDI4fHUyMDI5KS9nO1xuXG4gIC8vIFdpdGhpbiBhbiBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uLCBvciBlc2NhcGluZywgcmVtb3ZlIEhUTUwgZXNjYXBpbmdcbiAgLy8gdGhhdCBoYWQgYmVlbiBwcmV2aW91c2x5IGFkZGVkLlxuICB2YXIgdW5lc2NhcGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUucmVwbGFjZSh1bmVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUpIHtcbiAgICAgIHJldHVybiBlc2NhcGVzW2VzY2FwZV07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHNldHRpbmdzIHx8IHt9LCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCB0YWtpbmcgY2FyZSB0byBlc2NhcGUgY2hhcmFjdGVycyB0aGF0XG4gICAgLy8gY2Fubm90IGJlIGluY2x1ZGVkIGluIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBpbiBjb2RlXG4gICAgLy8gYmxvY2tzLlxuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiICsgdGV4dFxuICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkge1xuICAgICAgICByZXR1cm4gXCInK1xcbl8uZXNjYXBlKFwiICsgdW5lc2NhcGUoY29kZSkgKyBcIikrXFxuJ1wiO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBcIicrXFxuKFwiICsgdW5lc2NhcGUoY29kZSkgKyBcIikrXFxuJ1wiO1xuICAgICAgfSlcbiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgIHJldHVybiBcIic7XFxuXCIgKyB1bmVzY2FwZShjb2RlKSArIFwiXFxuO19fcCs9J1wiO1xuICAgICAgfSkgKyBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3A9Jyc7XCIgK1xuICAgICAgXCJ2YXIgcHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPUFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnJyl9O1xcblwiICtcbiAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcblxuICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBidWlsZCB0aW1lXG4gICAgLy8gcHJlY29tcGlsYXRpb24uXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAoc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicpICsgJyl7XFxuJyArXG4gICAgICBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIFRoZSBPT1AgV3JhcHBlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKG9iaikgeyB0aGlzLl93cmFwcGVkID0gb2JqOyB9O1xuXG4gIC8vIEV4cG9zZSBgd3JhcHBlci5wcm90b3R5cGVgIGFzIGBfLnByb3RvdHlwZWBcbiAgXy5wcm90b3R5cGUgPSB3cmFwcGVyLnByb3RvdHlwZTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmosIGNoYWluKSB7XG4gICAgcmV0dXJuIGNoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQSBtZXRob2QgdG8gZWFzaWx5IGFkZCBmdW5jdGlvbnMgdG8gdGhlIE9PUCB3cmFwcGVyLlxuICB2YXIgYWRkVG9XcmFwcGVyID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHVuc2hpZnQuY2FsbChhcmdzLCB0aGlzLl93cmFwcGVkKTtcbiAgICAgIHJldHVybiByZXN1bHQoZnVuYy5hcHBseShfLCBhcmdzKSwgdGhpcy5fY2hhaW4pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkod3JhcHBlZCwgYXJndW1lbnRzKTtcbiAgICAgIHZhciBsZW5ndGggPSB3cmFwcGVkLmxlbmd0aDtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIGxlbmd0aCA9PT0gMCkgZGVsZXRlIHdyYXBwZWRbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHdyYXBwZWQsIHRoaXMuX2NoYWluKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICB3cmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdChtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSwgdGhpcy5fY2hhaW4pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgd3JhcHBlci5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIHdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG4gIHJldHVybiBfO1xufSkuY2FsbCh7fSk7XG4vKipcbiAqIENvcmUgRW1tZXQgb2JqZWN0LCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlXG4gKi9cbnZhciBlbW1ldCA9IChmdW5jdGlvbihnbG9iYWwpIHtcblx0dmFyIGRlZmF1bHRTeW50YXggPSAnaHRtbCc7XG5cdHZhciBkZWZhdWx0UHJvZmlsZSA9ICdwbGFpbic7XG5cdFxuXHRpZiAodHlwZW9mIF8gPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIFJlcXVpcmVKUyBsb2FkZXJcblx0XHRcdC8vIGFsc28sIEpTIG9iZnVzY2F0b3JzIHRlbmRzIHRvIHRyYW5zbGF0ZVxuXHRcdFx0Ly8gYVtcIm5hbWVcIl0gdG8gYS5uYW1lLCB3aGljaCBhbHNvIGJyZWFrcyBSZXF1aXJlSlNcblx0XHRcdF8gPSBnbG9iYWxbWydyZXF1aXJlJ11bMF1dKCd1bmRlcnNjb3JlJyk7IC8vIG5vZGUuanNcblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0aWYgKHR5cGVvZiBfID09ICd1bmRlZmluZWQnKSB7XG5cdFx0dGhyb3cgJ0Nhbm5vdCBhY2Nlc3MgdG8gVW5kZXJzY29yZS5qcyBsaWInO1xuXHR9XG5cblx0LyoqIExpc3Qgb2YgcmVnaXN0ZXJlZCBtb2R1bGVzICovXG5cdHZhciBtb2R1bGVzID0ge1xuXHRcdF8gOiBfXG5cdH07XG5cdFxuXHQvKipcblx0ICogU2hhcmVkIGVtcHR5IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGFpZCBpbiBwcm90b3R5cGUtY2hhaW4gY3JlYXRpb24uXG5cdCAqL1xuXHR2YXIgY3RvciA9IGZ1bmN0aW9uKCl7fTtcblx0XG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29ycmVjdGx5IHNldCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLCBmb3Igc3ViY2xhc3Nlcy5cblx0ICogU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcblx0ICogY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cblx0ICogVG9vayBpdCBmcm9tIEJhY2tib25lLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0aWNQcm9wc1xuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5oZXJpdHMocGFyZW50LCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXHRcdHZhciBjaGlsZDtcblxuXHRcdC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieVxuXHRcdC8vIHlvdSAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvclxuXHRcdC8vIGRlZmF1bHRlZCBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG5cdFx0aWYgKHByb3RvUHJvcHMgJiYgcHJvdG9Qcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xuXHRcdFx0Y2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSW5oZXJpdCBjbGFzcyAoc3RhdGljKSBwcm9wZXJ0aWVzIGZyb20gcGFyZW50LlxuXHRcdF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQpO1xuXG5cdFx0Ly8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcblx0XHQvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuXHRcdGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcblx0XHRjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xuXG5cdFx0Ly8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG5cdFx0Ly8gaWYgc3VwcGxpZWQuXG5cdFx0aWYgKHByb3RvUHJvcHMpXG5cdFx0XHRfLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG5cdFx0Ly8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG5cdFx0aWYgKHN0YXRpY1Byb3BzKVxuXHRcdFx0Xy5leHRlbmQoY2hpbGQsIHN0YXRpY1Byb3BzKTtcblxuXHRcdC8vIENvcnJlY3RseSBzZXQgY2hpbGQncyBgcHJvdG90eXBlLmNvbnN0cnVjdG9yYC5cblx0XHRjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblxuXHRcdC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcblx0XHQvLyBsYXRlci5cblx0XHRjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEB0eXBlIEZ1bmN0aW9uIEZ1bmN0aW9uIHRoYXQgbG9hZHMgbW9kdWxlIGRlZmluaXRpb24gaWYgaXQncyBub3QgZGVmaW5lZFxuXHQgKi9cblx0dmFyIG1vZHVsZUxvYWRlciA9IG51bGw7XG5cdFxuXHQvKipcblx0ICogR2VuZXJpYyBFbW1ldCBtb2R1bGUgbG9hZGVyIChhY3R1YWxseSwgaXQgZG9lc27igJl0IGxvYWQgYW55dGhpbmcsIGp1c3QgXG5cdCAqIHJldHVybnMgbW9kdWxlIHJlZmVyZW5jZSkuIE5vdCB1c2luZyBgcmVxdWlyZWAgbmFtZSB0byBhdm9pZCBjb25mbGljdHNcblx0ICogd2l0aCBOb2RlLmpzIGFuZCBSZXF1aXJlSlNcblx0ICovXG5cdGZ1bmN0aW9uIHIobmFtZSkge1xuXHRcdGlmICghKG5hbWUgaW4gbW9kdWxlcykgJiYgbW9kdWxlTG9hZGVyKVxuXHRcdFx0bW9kdWxlTG9hZGVyKG5hbWUpO1xuXHRcdFxuXHRcdHJldHVybiBtb2R1bGVzW25hbWVdO1xuXHR9XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFNpbXBsZSwgQU1ELWxpa2UgbW9kdWxlIGRlZmluaXRpb24uIFRoZSBtb2R1bGUgd2lsbCBiZSBhZGRlZCBpbnRvXG5cdFx0ICogPGNvZGU+ZW1tZXQ8L2NvZGU+IG9iamVjdCBhbmQgd2lsbCBiZSBhdmFpbGFibGUgdmlhXG5cdFx0ICogPGNvZGU+ZW1tZXQucmVxdWlyZShuYW1lKTwvY29kZT4gb3IgPGNvZGU+ZW1tZXRbbmFtZV08L2NvZGU+XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmYWN0b3J5XG5cdFx0ICogQG1lbWJlck9mIGVtbWV0XG5cdFx0ICovXG5cdFx0ZGVmaW5lOiBmdW5jdGlvbihuYW1lLCBmYWN0b3J5KSB7XG5cdFx0XHQvLyBkbyBub3QgbGV0IHJlZGVmaW5lIGV4aXN0aW5nIHByb3BlcnRpZXNcblx0XHRcdGlmICghKG5hbWUgaW4gbW9kdWxlcykpIHtcblx0XHRcdFx0bW9kdWxlc1tuYW1lXSA9IF8uaXNGdW5jdGlvbihmYWN0b3J5KSBcblx0XHRcdFx0XHQ/IHRoaXMuZXhlYyhmYWN0b3J5KVxuXHRcdFx0XHRcdDogZmFjdG9yeTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcmVmZXJlbmNlIHRvIEVtbWV0IG1vZHVsZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1vZHVsZSBuYW1lXG5cdFx0ICovXG5cdFx0cmVxdWlyZTogcixcblx0XHRcblx0XHQvKipcblx0XHQgKiBIZWxwZXIgbWV0aG9kIHRoYXQganVzdCBleGVjdXRlcyBwYXNzZWQgZnVuY3Rpb24gYnV0IHdpdGggYWxsIFxuXHRcdCAqIGltcG9ydGFudCBhcmd1bWVudHMgbGlrZSAncmVxdWlyZScgYW5kICdfJ1xuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgRXhlY3V0aW9uIGNvbnRleHRcblx0XHQgKi9cblx0XHRleGVjOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBnbG9iYWwsIF8uYmluZChyLCB0aGlzKSwgXywgdGhpcyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2VsZi1wcm9wYWdhdGluZyBleHRlbmQgZnVuY3Rpb24gZm9yIGNsYXNzZXMuXG5cdFx0ICogVG9vayBpdCBmcm9tIEJhY2tib25lIFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNsYXNzUHJvcHNcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGV4dGVuZDogZnVuY3Rpb24ocHJvdG9Qcm9wcywgY2xhc3NQcm9wcykge1xuXHRcdFx0dmFyIGNoaWxkID0gaW5oZXJpdHModGhpcywgcHJvdG9Qcm9wcywgY2xhc3NQcm9wcyk7XG5cdFx0XHRjaGlsZC5leHRlbmQgPSB0aGlzLmV4dGVuZDtcblx0XHRcdC8vIGEgaGFjayByZXF1aXJlZCB0byBXU0ggaW5oZXJpdCBgdG9TdHJpbmdgIG1ldGhvZFxuXHRcdFx0aWYgKHByb3RvUHJvcHMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpXG5cdFx0XHRcdGNoaWxkLnByb3RvdHlwZS50b1N0cmluZyA9IHByb3RvUHJvcHMudG9TdHJpbmc7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXNzZW50aWFsIGZ1bmN0aW9uIHRoYXQgZXhwYW5kcyBFbW1ldCBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiciBBYmJyZXZpYXRpb24gdG8gcGFyc2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IEFiYnJldmlhdGlvbidzIGNvbnRleHQgc3ludGF4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUgKG9yIGl0cyBuYW1lKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0Tm9kZSBDb250ZXh0dWFsIG5vZGUgd2hlcmUgYWJicmV2aWF0aW9uIGlzXG5cdFx0ICogd3JpdHRlblxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRleHBhbmRBYmJyZXZpYXRpb246IGZ1bmN0aW9uKGFiYnIsIHN5bnRheCwgcHJvZmlsZSwgY29udGV4dE5vZGUpIHtcblx0XHRcdGlmICghYWJicikgcmV0dXJuICcnO1xuXHRcdFx0XG5cdFx0XHRzeW50YXggPSBzeW50YXggfHwgZGVmYXVsdFN5bnRheDtcbi8vXHRcdFx0cHJvZmlsZSA9IHByb2ZpbGUgfHwgZGVmYXVsdFByb2ZpbGU7XG5cdFx0XHRcblx0XHRcdHZhciBmaWx0ZXJzID0gcignZmlsdGVycycpO1xuXHRcdFx0dmFyIHBhcnNlciA9IHIoJ2FiYnJldmlhdGlvblBhcnNlcicpO1xuXHRcdFx0XG5cdFx0XHRwcm9maWxlID0gcigncHJvZmlsZScpLmdldChwcm9maWxlLCBzeW50YXgpO1xuXHRcdFx0cigndGFiU3RvcHMnKS5yZXNldFRhYnN0b3BJbmRleCgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgZGF0YSA9IGZpbHRlcnMuZXh0cmFjdEZyb21BYmJyZXZpYXRpb24oYWJicik7XG5cdFx0XHR2YXIgb3V0cHV0VHJlZSA9IHBhcnNlci5wYXJzZShkYXRhWzBdLCB7XG5cdFx0XHRcdHN5bnRheDogc3ludGF4LCBcblx0XHRcdFx0Y29udGV4dE5vZGU6IGNvbnRleHROb2RlXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dmFyIGZpbHRlcnNMaXN0ID0gZmlsdGVycy5jb21wb3NlTGlzdChzeW50YXgsIHByb2ZpbGUsIGRhdGFbMV0pO1xuXHRcdFx0ZmlsdGVycy5hcHBseShvdXRwdXRUcmVlLCBmaWx0ZXJzTGlzdCwgcHJvZmlsZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0VHJlZS50b1N0cmluZygpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBkZWZhdWx0IHN5bnRheCBuYW1lIHVzZWQgaW4gYWJicmV2aWF0aW9uIGVuZ2luZVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZGVmYXVsdFN5bnRheDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFN5bnRheDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZGVmYXVsdCBwcm9maWxlIG5hbWUgdXNlZCBpbiBhYmJyZXZpYXRpb24gZW5naW5lXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRkZWZhdWx0UHJvZmlsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFByb2ZpbGU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBMb2cgbWVzc2FnZSBpbnRvIGNvbnNvbGUgaWYgaXQgZXhpc3RzXG5cdFx0ICovXG5cdFx0bG9nOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZS5sb2cpXG5cdFx0XHRcdGdsb2JhbC5jb25zb2xlLmxvZy5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHVwcyBmdW5jdGlvbiB0aGF0IHNob3VsZCBzeW5jaHJvbm91c2x5IGxvYWQgdW5kZWZpbmVkIG1vZHVsZXNcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdCAqL1xuXHRcdHNldE1vZHVsZUxvYWRlcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdG1vZHVsZUxvYWRlciA9IGZuO1xuXHRcdH1cblx0fTtcbn0pKHRoaXMpO1xuXG4vLyBleHBvcnQgY29yZSBmb3IgTm9kZS5KU1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlbW1ldDtcblx0fVxuXHRleHBvcnRzLmVtbWV0ID0gZW1tZXQ7XG59XG5cbi8vIGV4cG9ydCBhcyBSZXF1aXJlLmpzIG1vZHVsZVxuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnKSB7XG5cdGRlZmluZSgnZW1tZXQnLCBbXSwgZW1tZXQpO1xufS8qKlxuICogRW1tZXQgYWJicmV2aWF0aW9uIHBhcnNlci5cbiAqIFRha2VzIHN0cmluZyBhYmJyZXZpYXRpb24gYW5kIHJlY3Vyc2l2ZWx5IHBhcnNlcyBpdCBpbnRvIGEgdHJlZS4gVGhlIHBhcnNlZCBcbiAqIHRyZWUgY2FuIGJlIHRyYW5zZm9ybWVkIGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gd2l0aCBcbiAqIDxjb2RlPnRvU3RyaW5nKCk8L2NvZGU+IG1ldGhvZC4gTm90ZSB0aGF0IHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBkZWZpbmVkXG4gKiBieSBjdXN0b20gcHJvY2Vzc29ycyAoY2FsbGVkIDxpPmZpbHRlcnM8L2k+KSwgbm90IGJ5IGFiYnJldmlhdGlvbiBwYXJzZXIgXG4gKiBpdHNlbGYuXG4gKiBcbiAqIFRoaXMgbW9kdWxlIGNhbiBiZSBleHRlbmRlZCB3aXRoIGN1c3RvbSBwcmUtL3Bvc3QtcHJvY2Vzc29ycyB0byBzaGFwZS11cFxuICogZmluYWwgdHJlZSBvciBpdHMgcmVwcmVzZW50YXRpb24uIEFjdHVhbGx5LCBtYW55IGZlYXR1cmVzIG9mIGFiYnJldmlhdGlvbiBcbiAqIGVuZ2luZSBhcmUgZGVmaW5lZCBpbiBvdGhlciBtb2R1bGVzIGFzIHRyZWUgcHJvY2Vzc29yc1xuICogXG4gKiBcbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pXG4gKiBAbGluayBodHRwOi8vY2hpa3V5b25vay5ydVxuICogQG1lbWJlck9mIF9fYWJicmV2aWF0aW9uUGFyc2VyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5kZWZpbmUoJ2FiYnJldmlhdGlvblBhcnNlcicsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIHJlVmFsaWROYW1lID0gL15bXFx3XFwtXFwkXFw6QFxcISVdK1xcKz8kL2k7XG5cdHZhciByZVdvcmQgPSAvW1xcd1xcLTpcXCRAXS87XG5cdFxuXHR2YXIgcGFpcnMgPSB7XG5cdFx0J1snOiAnXScsXG5cdFx0JygnOiAnKScsXG5cdFx0J3snOiAnfSdcblx0fTtcblx0XG5cdHZhciBzcGxpY2VGbiA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG5cdFxuXHR2YXIgcHJlcHJvY2Vzc29ycyA9IFtdO1xuXHR2YXIgcG9zdHByb2Nlc3NvcnMgPSBbXTtcblx0dmFyIG91dHB1dFByb2Nlc3NvcnMgPSBbXTtcblx0XG5cdC8qKlxuXHQgKiBAdHlwZSBBYmJyZXZpYXRpb25Ob2RlXG5cdCAqL1xuXHRmdW5jdGlvbiBBYmJyZXZpYXRpb25Ob2RlKHBhcmVudCkge1xuXHRcdC8qKiBAdHlwZSBBYmJyZXZpYXRpb25Ob2RlICovXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9hdHRyaWJ1dGVzID0gW107XG5cdFx0XG5cdFx0LyoqIEB0eXBlIFN0cmluZyBSYXcgYWJicmV2aWF0aW9uIGZvciBjdXJyZW50IG5vZGUgKi9cblx0XHR0aGlzLmFiYnJldmlhdGlvbiA9ICcnO1xuXHRcdHRoaXMuY291bnRlciA9IDE7XG5cdFx0dGhpcy5fbmFtZSA9IG51bGw7XG5cdFx0dGhpcy5fdGV4dCA9ICcnO1xuXHRcdHRoaXMucmVwZWF0Q291bnQgPSAxO1xuXHRcdHRoaXMuaGFzSW1wbGljaXRSZXBlYXQgPSBmYWxzZTtcblx0XHRcblx0XHQvKiogQ3VzdG9tIGRhdGEgZGljdGlvbmFyeSAqL1xuXHRcdHRoaXMuX2RhdGEgPSB7fTtcblx0XHRcblx0XHQvLyBvdXRwdXQgcHJvcGVydGllc1xuXHRcdHRoaXMuc3RhcnQgPSAnJztcblx0XHR0aGlzLmVuZCA9ICcnO1xuXHRcdHRoaXMuY29udGVudCA9ICcnO1xuXHRcdHRoaXMucGFkZGluZyA9ICcnO1xuXHR9XG5cdFxuXHRBYmJyZXZpYXRpb25Ob2RlLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBBZGRzIHBhc3NlZCBub2RlIGFzIGNoaWxkIG9yIGNyZWF0ZXMgbmV3IGNoaWxkXG5cdFx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBjaGlsZFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiBJbmRleCBpbiBjaGlsZHJlbiBhcnJheSB3aGVyZSBjaGlsZCBzaG91bGQgXG5cdFx0ICogYmUgaW5zZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtBYmJyZXZpYXRpb25Ob2RlfVxuXHRcdCAqL1xuXHRcdGFkZENoaWxkOiBmdW5jdGlvbihjaGlsZCwgcG9zaXRpb24pIHtcblx0XHRcdGNoaWxkID0gY2hpbGQgfHwgbmV3IEFiYnJldmlhdGlvbk5vZGU7XG5cdFx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRpZiAoXy5pc1VuZGVmaW5lZChwb3NpdGlvbikpIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKHBvc2l0aW9uLCAwLCBjaGlsZCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgY3VycmVudCBub2RlXG5cdFx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9XG5cdFx0ICovXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5vZGUgPSBuZXcgQWJicmV2aWF0aW9uTm9kZSgpO1xuXHRcdFx0dmFyIGF0dHJzID0gWydhYmJyZXZpYXRpb24nLCAnY291bnRlcicsICdfbmFtZScsICdfdGV4dCcsICdyZXBlYXRDb3VudCcsICdoYXNJbXBsaWNpdFJlcGVhdCcsICdzdGFydCcsICdlbmQnLCAnY29udGVudCcsICdwYWRkaW5nJ107XG5cdFx0XHRfLmVhY2goYXR0cnMsIGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0bm9kZVthXSA9IHRoaXNbYV07XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0Ly8gY2xvbmUgYXR0cmlidXRlc1xuXHRcdFx0bm9kZS5fYXR0cmlidXRlcyA9IF8ubWFwKHRoaXMuX2F0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIF8uY2xvbmUoYXR0cik7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0bm9kZS5fZGF0YSA9IF8uY2xvbmUodGhpcy5fZGF0YSk7XG5cdFx0XHRcblx0XHRcdC8vIGNsb25lIGNoaWxkcmVuXG5cdFx0XHRub2RlLmNoaWxkcmVuID0gXy5tYXAodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5jbG9uZSgpO1xuXHRcdFx0XHRjaGlsZC5wYXJlbnQgPSBub2RlO1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIGN1cnJlbnQgbm9kZSBmcm9tIHBhcmVudOKAmHMgY2hpbGQgbGlzdFxuXHRcdCAqIEByZXR1cm5zIHtBYmJyZXZpYXRpb25Ob2RlfSBDdXJyZW50IG5vZGUgaXRzZWxmXG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnBhcmVudCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5jaGlsZHJlbiA9IF8ud2l0aG91dCh0aGlzLnBhcmVudC5jaGlsZHJlbiwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZXMgY3VycmVudCBub2RlIGluIHBhcmVudOKAmHMgY2hpbGRyZW4gbGlzdCB3aXRoIHBhc3NlZCBub2Rlc1xuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZSBSZXBsYWNlbWVudCBub2RlIG9yIGFycmF5IG9mIG5vZGVzXG5cdFx0ICovXG5cdFx0cmVwbGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cdFx0XHR2YXIgaXggPSBfLmluZGV4T2YocGFyZW50LmNoaWxkcmVuLCB0aGlzKTtcblx0XHRcdHZhciBpdGVtcyA9IF8uZmxhdHRlbihhcmd1bWVudHMpO1xuXHRcdFx0c3BsaWNlRm4uYXBwbHkocGFyZW50LmNoaWxkcmVuLCBbaXgsIDFdLmNvbmNhdChpdGVtcykpO1xuXHRcdFx0XG5cdFx0XHQvLyB1cGRhdGUgcGFyZW50XG5cdFx0XHRfLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0aXRlbS5wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IHNldHMgPGNvZGU+cHJvcGVydHk8L2NvZGU+IHRvIDxjb2RlPnZhbHVlPC9jb2RlPiBvZiBjdXJyZW50XG5cdFx0ICogbm9kZSBhbmQgaXRzIGNoaWxkcmVuIFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByb3BlcnR5IHRvIHVwZGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcblx0XHQgKi9cblx0XHR1cGRhdGVQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdF8uZWFjaCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRjaGlsZC51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kcyBmaXJzdCBjaGlsZCBub2RlIHRoYXQgbWF0Y2hlcyB0cnV0aCB0ZXN0IGZvciBwYXNzZWQgXG5cdFx0ICogPGNvZGU+Zm48L2NvZGU+IGZ1bmN0aW9uXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKiBAcmV0dXJucyB7QWJicmV2aWF0aW9uTm9kZX1cblx0XHQgKi9cblx0XHRmaW5kOiBmdW5jdGlvbihmbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmluZEFsbChmbilbMF07XG4vL1x0XHRcdGlmICghXy5pc0Z1bmN0aW9uKGZuKSkge1xuLy9cdFx0XHRcdHZhciBlbGVtTmFtZSA9IGZuLnRvTG93ZXJDYXNlKCk7XG4vL1x0XHRcdFx0Zm4gPSBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0ubmFtZSgpLnRvTG93ZXJDYXNlKCkgPT0gZWxlbU5hbWU7fTtcbi8vXHRcdFx0fVxuLy9cdFx0XHRcbi8vXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG4vL1x0XHRcdF8uZmluZCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuLy9cdFx0XHRcdGlmIChmbihjaGlsZCkpIHtcbi8vXHRcdFx0XHRcdHJldHVybiByZXN1bHQgPSBjaGlsZDtcbi8vXHRcdFx0XHR9XG4vL1x0XHRcdFx0XG4vL1x0XHRcdFx0cmV0dXJuIHJlc3VsdCA9IGNoaWxkLmZpbmQoZm4pO1xuLy9cdFx0XHR9KTtcbi8vXHRcdFx0XG4vL1x0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kcyBhbGwgY2hpbGQgbm9kZXMgdGhhdCBtYXRjaGVzIHRydXRoIHRlc3QgZm9yIHBhc3NlZCBcblx0XHQgKiA8Y29kZT5mbjwvY29kZT4gZnVuY3Rpb25cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKi9cblx0XHRmaW5kQWxsOiBmdW5jdGlvbihmbikge1xuXHRcdFx0aWYgKCFfLmlzRnVuY3Rpb24oZm4pKSB7XG5cdFx0XHRcdHZhciBlbGVtTmFtZSA9IGZuLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLm5hbWUoKS50b0xvd2VyQ2FzZSgpID09IGVsZW1OYW1lO307XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0Xy5lYWNoKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0XHRcdGlmIChmbihjaGlsZCkpXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjaGlsZC5maW5kQWxsKGZuKSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIF8uY29tcGFjdChyZXN1bHQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cy9nZXRzIGN1c3RvbSBkYXRhXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGRhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGFbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuYW1lID09ICdyZXNvdXJjZScgJiYgcmVxdWlyZSgnZWxlbWVudHMnKS5pcyh2YWx1ZSwgJ3NuaXBwZXQnKSkge1xuXHRcdFx0XHRcdC8vIHNldHRpbmcgc25pcHBldCBhcyBtYXRjaGVkIHJlc291cmNlOiB1cGRhdGUgYGNvbnRlbnRgXG5cdFx0XHRcdFx0Ly8gcHJvcGVydHkgd2l0aCBzbmlwcGV0IHZhbHVlXG5cdFx0XHRcdFx0dGhpcy5jb250ZW50ID0gdmFsdWUuZGF0YTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGV4dCkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb250ZW50ID0gcmVxdWlyZSgnYWJicmV2aWF0aW9uVXRpbHMnKVxuXHRcdFx0XHRcdFx0XHQuaW5zZXJ0Q2hpbGRDb250ZW50KHZhbHVlLmRhdGEsIHRoaXMuX3RleHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbmFtZSBvZiBjdXJyZW50IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdG5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IHRoaXMubWF0Y2hlZFJlc291cmNlKCk7XG5cdFx0XHRpZiAocmVxdWlyZSgnZWxlbWVudHMnKS5pcyhyZXMsICdlbGVtZW50JykpIHtcblx0XHRcdFx0cmV0dXJuIHJlcy5uYW1lO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBhdHRyaWJ1dGVzIGZvciBjdXJyZW50IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0YXR0cmlidXRlTGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXR0cnMgPSBbXTtcblx0XHRcdFxuXHRcdFx0dmFyIHJlcyA9IHRoaXMubWF0Y2hlZFJlc291cmNlKCk7XG5cdFx0XHRpZiAocmVxdWlyZSgnZWxlbWVudHMnKS5pcyhyZXMsICdlbGVtZW50JykgJiYgXy5pc0FycmF5KHJlcy5hdHRyaWJ1dGVzKSkge1xuXHRcdFx0XHRhdHRycyA9IGF0dHJzLmNvbmNhdChyZXMuYXR0cmlidXRlcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBvcHRpbWl6ZUF0dHJpYnV0ZXMoYXR0cnMuY29uY2F0KHRoaXMuX2F0dHJpYnV0ZXMpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgb3Igc2V0cyBhdHRyaWJ1dGUgdmFsdWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRhdHRyaWJ1dGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdC8vIG1vZGlmeWluZyBhdHRyaWJ1dGVcblx0XHRcdFx0dmFyIGl4ID0gXy5pbmRleE9mKF8ucGx1Y2sodGhpcy5fYXR0cmlidXRlcywgJ25hbWUnKSwgbmFtZS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0aWYgKH5peCkge1xuXHRcdFx0XHRcdHRoaXMuX2F0dHJpYnV0ZXNbaXhdLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYXR0cmlidXRlcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gKF8uZmluZCh0aGlzLmF0dHJpYnV0ZUxpc3QoKSwgZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gYXR0ci5uYW1lID09IG5hbWU7XG5cdFx0XHR9KSB8fCB7fSkudmFsdWU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHJlZmVyZW5jZSB0byB0aGUgbWF0Y2hlZCA8Y29kZT5lbGVtZW50PC9jb2RlPiwgaWYgYW55LlxuXHRcdCAqIFNlZSB7QGxpbmsgZWxlbWVudHN9IG1vZHVsZSBmb3IgYSBsaXN0IG9mIGF2YWlsYWJsZSBlbGVtZW50c1xuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0bWF0Y2hlZFJlc291cmNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEoJ3Jlc291cmNlJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGluZGV4IG9mIGN1cnJlbnQgbm9kZSBpbiBwYXJlbnTigJhzIGNoaWxkcmVuIGxpc3Rcblx0XHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdGluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcmVudCA/IF8uaW5kZXhPZih0aGlzLnBhcmVudC5jaGlsZHJlbiwgdGhpcykgOiAtMTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgaG93IG1hbnkgdGltZXMgY3VycmVudCBlbGVtZW50IHNob3VsZCBiZSByZXBlYXRlZFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3NldFJlcGVhdDogZnVuY3Rpb24oY291bnQpIHtcblx0XHRcdGlmIChjb3VudCkge1xuXHRcdFx0XHR0aGlzLnJlcGVhdENvdW50ID0gcGFyc2VJbnQoY291bnQsIDEwKSB8fCAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oYXNJbXBsaWNpdFJlcGVhdCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTZXRzIGFiYnJldmlhdGlvbiB0aGF0IGJlbG9uZ3MgdG8gY3VycmVudCBub2RlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0XHQgKi9cblx0XHRzZXRBYmJyZXZpYXRpb246IGZ1bmN0aW9uKGFiYnIpIHtcblx0XHRcdGFiYnIgPSBhYmJyIHx8ICcnO1xuXHRcdFx0XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdC8vIGZpbmQgbXVsdGlwbGllclxuXHRcdFx0YWJiciA9IGFiYnIucmVwbGFjZSgvXFwqKFxcZCspPyQvLCBmdW5jdGlvbihzdHIsIHJlcGVhdENvdW50KSB7XG5cdFx0XHRcdHRoYXQuX3NldFJlcGVhdChyZXBlYXRDb3VudCk7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFiYnJldmlhdGlvbiA9IGFiYnI7XG5cdFx0XHRcblx0XHRcdHZhciBhYmJyVGV4dCA9IGV4dHJhY3RUZXh0KGFiYnIpO1xuXHRcdFx0aWYgKGFiYnJUZXh0KSB7XG5cdFx0XHRcdGFiYnIgPSBhYmJyVGV4dC5lbGVtZW50O1xuXHRcdFx0XHR0aGlzLmNvbnRlbnQgPSB0aGlzLl90ZXh0ID0gYWJiclRleHQudGV4dDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGFiYnJBdHRycyA9IHBhcnNlQXR0cmlidXRlcyhhYmJyKTtcblx0XHRcdGlmIChhYmJyQXR0cnMpIHtcblx0XHRcdFx0YWJiciA9IGFiYnJBdHRycy5lbGVtZW50O1xuXHRcdFx0XHR0aGlzLl9hdHRyaWJ1dGVzID0gYWJickF0dHJzLmF0dHJpYnV0ZXM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX25hbWUgPSBhYmJyO1xuXHRcdFx0XG5cdFx0XHQvLyB2YWxpZGF0ZSBuYW1lXG5cdFx0XHRpZiAodGhpcy5fbmFtZSAmJiAhcmVWYWxpZE5hbWUudGVzdCh0aGlzLl9uYW1lKSkge1xuXHRcdFx0XHR0aHJvdyAnSW52YWxpZCBhYmJyZXZpYXRpb24nO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY3VycmVudCBub2RlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0XHRcblx0XHRcdHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG5cdFx0XHR2YXIgZW5kID0gdGhpcy5lbmQ7XG5cdFx0XHR2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcblx0XHRcdFxuXHRcdFx0Ly8gYXBwbHkgb3V0cHV0IHByb2Nlc3NvcnNcblx0XHRcdHZhciBub2RlID0gdGhpcztcblx0XHRcdF8uZWFjaChvdXRwdXRQcm9jZXNzb3JzLCBmdW5jdGlvbihmbikge1xuXHRcdFx0XHRzdGFydCA9IGZuKHN0YXJ0LCBub2RlLCAnc3RhcnQnKTtcblx0XHRcdFx0Y29udGVudCA9IGZuKGNvbnRlbnQsIG5vZGUsICdjb250ZW50Jyk7XG5cdFx0XHRcdGVuZCA9IGZuKGVuZCwgbm9kZSwgJ2VuZCcpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGlubmVyQ29udGVudCA9IF8ubWFwKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZC50b1N0cmluZygpO1xuXHRcdFx0fSkuam9pbignJyk7XG5cdFx0XHRcblx0XHRcdGNvbnRlbnQgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpLmluc2VydENoaWxkQ29udGVudChjb250ZW50LCBpbm5lckNvbnRlbnQsIHtcblx0XHRcdFx0a2VlcFZhcmlhYmxlOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdGFydCArIHV0aWxzLnBhZFN0cmluZyhjb250ZW50LCB0aGlzLnBhZGRpbmcpICsgZW5kO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3VycmVudCBub2RlIGNvbnRhaW5zIGNoaWxkcmVuIHdpdGggZW1wdHkgPGNvZGU+ZXhwcjwvY29kZT5cblx0XHQgKiBwcm9wZXJ0eVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aGFzRW1wdHlDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gISFfLmZpbmQodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkLmlzRW1wdHkoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3VycmVudCBub2RlIGhhcyBpbXBsaWVkIG5hbWUgdGhhdCBzaG91bGQgYmUgcmVzb2x2ZWRcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNJbXBsaWNpdE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLl9uYW1lICYmICF0aGlzLmlzVGV4dE5vZGUoKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IGN1cnJlbnQgZWxlbWVudCBpcyBhIGdyb3VwaW5nIG9uZSwgZS5nLiBoYXMgbm8gXG5cdFx0ICogcmVwcmVzZW50YXRpb24gYnV0IHNlcnZlcyBhcyBhIGNvbnRhaW5lciBmb3Igb3RoZXIgbm9kZXNcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0dyb3VwOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5hYmJyZXZpYXRpb247XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgZW1wdHkgbm9kZSAoaS5lLiB3aXRob3V0IGFiYnJldmlhdGlvbikuIEl0IG1heSBiZSBhIFxuXHRcdCAqIGdyb3VwaW5nIG5vZGUgYW5kIHNob3VsZCBub3QgYmUgb3V0cHV0dGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5hYmJyZXZpYXRpb24gJiYgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgY3VycmVudCBub2RlIHNob3VsZCBiZSByZXBlYXRlZFxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzUmVwZWF0aW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlcGVhdENvdW50ID4gMSB8fCB0aGlzLmhhc0ltcGxpY2l0UmVwZWF0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3VycmVudCBub2RlIGlzIGEgdGV4dC1vbmx5IG5vZGVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzVGV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLm5hbWUoKSAmJiAhdGhpcy5hdHRyaWJ1dGVMaXN0KCkubGVuZ3RoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIG1heSBiZSB1c2VkIHRvIGJ1aWxkIGVsZW1lbnRzIG9yIHNuaXBwZXRzXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5pc0VtcHR5KCkgJiYgIXRoaXMuaXNUZXh0Tm9kZSgpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBsYXRlc3QgYW5kIGRlZXBlc3QgY2hpbGQgb2YgY3VycmVudCB0cmVlXG5cdFx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9XG5cdFx0ICovXG5cdFx0ZGVlcGVzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdHZhciBkZWVwZXN0Q2hpbGQgPSB0aGlzO1xuXHRcdFx0d2hpbGUgKGRlZXBlc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0ZGVlcGVzdENoaWxkID0gXy5sYXN0KGRlZXBlc3RDaGlsZC5jaGlsZHJlbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBkZWVwZXN0Q2hpbGQ7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgc3RyaXBwZWQgc3RyaW5nOiBhIHN0cmluZyB3aXRob3V0IGZpcnN0IGFuZCBsYXN0IGNoYXJhY3Rlci5cblx0ICogVXNlZCBmb3Ig4oCcdW5xdW90aW5n4oCdIHN0cmluZ3Ncblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3RyaXBwZWQoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjb25zdW1lUXVvdGVkVmFsdWUoc3RyZWFtLCBxdW90ZSkge1xuXHRcdHZhciBjaDtcblx0XHR3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG5cdFx0XHRpZiAoY2ggPT09IHF1b3RlKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0aWYgKGNoID09ICdcXFxcJylcblx0XHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyBhYmJyZXZpYXRpb24gaW50byBhIHRyZWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZUFiYnJldmlhdGlvbihhYmJyKSB7XG5cdFx0YWJiciA9IHJlcXVpcmUoJ3V0aWxzJykudHJpbShhYmJyKTtcblx0XHRcblx0XHR2YXIgcm9vdCA9IG5ldyBBYmJyZXZpYXRpb25Ob2RlO1xuXHRcdHZhciBjb250ZXh0ID0gcm9vdC5hZGRDaGlsZCgpLCBjaDtcblx0XHRcblx0XHQvKiogQHR5cGUgU3RyaW5nU3RyZWFtICovXG5cdFx0dmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmluZ1N0cmVhbScpLmNyZWF0ZShhYmJyKTtcblx0XHR2YXIgbG9vcFByb3RlY3RvciA9IDEwMDAsIG11bHRpcGxpZXI7XG5cdFx0XG5cdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkgJiYgLS1sb29wUHJvdGVjdG9yID4gMCkge1xuXHRcdFx0Y2ggPSBzdHJlYW0ucGVlaygpO1xuXHRcdFx0XG5cdFx0XHRzd2l0Y2ggKGNoKSB7XG5cdFx0XHRcdGNhc2UgJygnOiAvLyBhYmJyZXZpYXRpb24gZ3JvdXBcblx0XHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRcdGlmIChzdHJlYW0uc2tpcFRvUGFpcignKCcsICcpJykpIHtcblx0XHRcdFx0XHRcdHZhciBpbm5lciA9IHBhcnNlQWJicmV2aWF0aW9uKHN0cmlwcGVkKHN0cmVhbS5jdXJyZW50KCkpKTtcblx0XHRcdFx0XHRcdGlmIChtdWx0aXBsaWVyID0gc3RyZWFtLm1hdGNoKC9eXFwqKFxcZCspPy8sIHRydWUpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuX3NldFJlcGVhdChtdWx0aXBsaWVyWzFdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Xy5lYWNoKGlubmVyLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LmFkZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnSW52YWxpZCBhYmJyZXZpYXRpb246IG1vIG1hdGNoaW5nIFwiKVwiIGZvdW5kIGZvciBjaGFyYWN0ZXIgYXQgJyArIHN0cmVhbS5wb3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRjYXNlICc+JzogLy8gY2hpbGQgb3BlcmF0b3Jcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5hZGRDaGlsZCgpO1xuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJysnOiAvLyBzaWJsaW5nIG9wZXJhdG9yXG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50LmFkZENoaWxkKCk7XG5cdFx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnXic6IC8vIGNsaW1iIHVwIG9wZXJhdG9yXG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9IGNvbnRleHQucGFyZW50IHx8IGNvbnRleHQ7XG5cdFx0XHRcdFx0Y29udGV4dCA9IChwYXJlbnQucGFyZW50IHx8IHBhcmVudCkuYWRkQ2hpbGQoKTtcblx0XHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRkZWZhdWx0OiAvLyBjb25zdW1lIGFiYnJldmlhdGlvblxuXHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHRcdFx0c3RyZWFtLmVhdFdoaWxlKGZ1bmN0aW9uKGMpIHtcblx0XHRcdFx0XHRcdGlmIChjID09ICdbJyB8fCBjID09ICd7Jykge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RyZWFtLnNraXBUb1BhaXIoYywgcGFpcnNbY10pKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyZWFtLmJhY2tVcCgxKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgYWJicmV2aWF0aW9uOiBtbyBtYXRjaGluZyBcIicgKyBwYWlyc1tjXSArICdcIiBmb3VuZCBmb3IgY2hhcmFjdGVyIGF0ICcgKyBzdHJlYW0ucG9zO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoYyA9PSAnKycpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbGV0J3Mgc2VlIGlmIHRoaXMgaXMgYW4gZXhwYW5kbyBtYXJrZXJcblx0XHRcdFx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0XHRcdFx0dmFyIGlzTWFya2VyID0gc3RyZWFtLmVvbCgpIHx8ICB+Jys+XionLmluZGV4T2Yoc3RyZWFtLnBlZWsoKSk7XG5cdFx0XHRcdFx0XHRcdHN0cmVhbS5iYWNrVXAoMSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpc01hcmtlcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIGMgIT0gJygnICYmIGlzQWxsb3dlZENoYXIoYyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRBYmJyZXZpYXRpb24oc3RyZWFtLmN1cnJlbnQoKSk7XG5cdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGxvb3BQcm90ZWN0b3IgPCAxKVxuXHRcdFx0dGhyb3cgJ0VuZGxlc3MgbG9vcCBkZXRlY3RlZCc7XG5cdFx0XG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIHRoZWlyIHZhbHVlcyBmcm9tIGF0dHJpYnV0ZSBzZXQ6IFxuXHQgKiA8Y29kZT5bYXR0ciBjb2w9MyB0aXRsZT1cIlF1b3RlZCBzdHJpbmdcIl08L2NvZGU+XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyU2V0XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIGV4dHJhY3RBdHRyaWJ1dGVzKGF0dHJTZXQsIGF0dHJzKSB7XG5cdFx0YXR0clNldCA9IHJlcXVpcmUoJ3V0aWxzJykudHJpbShhdHRyU2V0KTtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XG5cdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdHZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJpbmdTdHJlYW0nKS5jcmVhdGUoYXR0clNldCk7XG5cdFx0c3RyZWFtLmVhdFNwYWNlKCk7XG5cdFx0XG5cdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHRpZiAoc3RyZWFtLmVhdFdoaWxlKHJlV29yZCkpIHtcblx0XHRcdFx0dmFyIGF0dHJOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcblx0XHRcdFx0dmFyIGF0dHJWYWx1ZSA9ICcnO1xuXHRcdFx0XHRpZiAoc3RyZWFtLnBlZWsoKSA9PSAnPScpIHtcblx0XHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHRcdFx0dmFyIHF1b3RlID0gc3RyZWFtLnBlZWsoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocXVvdGUgPT0gJ1wiJyB8fCBxdW90ZSA9PSBcIidcIikge1xuXHRcdFx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0XHRcdGlmIChjb25zdW1lUXVvdGVkVmFsdWUoc3RyZWFtLCBxdW90ZSkpIHtcblx0XHRcdFx0XHRcdFx0YXR0clZhbHVlID0gc3RyZWFtLmN1cnJlbnQoKTtcblx0XHRcdFx0XHRcdFx0Ly8gc3RyaXAgcXVvdGVzXG5cdFx0XHRcdFx0XHRcdGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5zdWJzdHJpbmcoMSwgYXR0clZhbHVlLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgYXR0cmlidXRlIHZhbHVlJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXF1dLykpIHtcblx0XHRcdFx0XHRcdGF0dHJWYWx1ZSA9IHN0cmVhbS5jdXJyZW50KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93ICdJbnZhbGlkIGF0dHJpYnV0ZSB2YWx1ZSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdFx0bmFtZTogYXR0ck5hbWUsIFxuXHRcdFx0XHRcdHZhbHVlOiBhdHRyVmFsdWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHN0cmVhbS5lYXRTcGFjZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQYXJzZXMgdGFnIGF0dHJpYnV0ZXMgZXh0cmFjdGVkIGZyb20gYWJicmV2aWF0aW9uLiBJZiBhdHRyaWJ1dGVzIGZvdW5kLCBcblx0ICogcmV0dXJucyBvYmplY3Qgd2l0aCA8Y29kZT5lbGVtZW50PC9jb2RlPiBhbmQgPGNvZGU+YXR0cmlidXRlczwvY29kZT5cblx0ICogcHJvcGVydGllc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIDxjb2RlPm51bGw8L2NvZGU+IGlmIG5vIGF0dHJpYnV0ZXMgZm91bmQgaW4gXG5cdCAqIGFiYnJldmlhdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGFiYnIpIHtcblx0XHQvKlxuXHRcdCAqIEV4YW1wbGUgb2YgaW5jb21pbmcgZGF0YTpcblx0XHQgKiAjaGVhZGVyXG5cdFx0ICogLnNvbWUuZGF0YVxuXHRcdCAqIC5zb21lLmRhdGEjaGVhZGVyXG5cdFx0ICogW2F0dHJdXG5cdFx0ICogI2l0ZW1bYXR0cj1IZWxsbyBvdGhlcj1cIldvcmxkXCJdLmNsYXNzXG5cdFx0ICovXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBhdHRyTWFwID0geycjJzogJ2lkJywgJy4nOiAnY2xhc3MnfTtcblx0XHR2YXIgbmFtZUVuZCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdHZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJpbmdTdHJlYW0nKS5jcmVhdGUoYWJicik7XG5cdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdHN3aXRjaCAoc3RyZWFtLnBlZWsoKSkge1xuXHRcdFx0XHRjYXNlICcjJzogLy8gaWRcblx0XHRcdFx0Y2FzZSAnLic6IC8vIGNsYXNzXG5cdFx0XHRcdFx0aWYgKG5hbWVFbmQgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRuYW1lRW5kID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgYXR0ck5hbWUgPSBhdHRyTWFwW3N0cmVhbS5wZWVrKCldO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRzdHJlYW0uZWF0V2hpbGUocmVXb3JkKTtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRyTmFtZSwgXG5cdFx0XHRcdFx0XHR2YWx1ZTogc3RyZWFtLmN1cnJlbnQoKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdbJzogLy9iZWdpbiBhdHRyaWJ1dGUgc2V0XG5cdFx0XHRcdFx0aWYgKG5hbWVFbmQgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRuYW1lRW5kID0gc3RyZWFtLnBvcztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRcdGlmICghc3RyZWFtLnNraXBUb1BhaXIoJ1snLCAnXScpKSBcblx0XHRcdFx0XHRcdHRocm93ICdJbnZhbGlkIGF0dHJpYnV0ZSBzZXQgZGVmaW5pdGlvbic7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNvbmNhdChcblx0XHRcdFx0XHRcdGV4dHJhY3RBdHRyaWJ1dGVzKHN0cmlwcGVkKHN0cmVhbS5jdXJyZW50KCkpKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFyZXN1bHQubGVuZ3RoKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVsZW1lbnQ6IGFiYnIuc3Vic3RyaW5nKDAsIG5hbWVFbmQpLFxuXHRcdFx0YXR0cmlidXRlczogb3B0aW1pemVBdHRyaWJ1dGVzKHJlc3VsdClcblx0XHR9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogT3B0aW1pemUgYXR0cmlidXRlIHNldDogcmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIG1lcmdlIGNsYXNzIGF0dHJpYnV0ZXNcblx0ICogQHBhcmFtIGF0dHJzXG5cdCAqL1xuXHRmdW5jdGlvbiBvcHRpbWl6ZUF0dHJpYnV0ZXMoYXR0cnMpIHtcblx0XHQvLyBjbG9uZSBhbGwgYXR0cmlidXRlcyB0byBtYWtlIHN1cmUgdGhhdCBvcmlnaW5hbCBvYmplY3RzIGFyZSBcblx0XHQvLyBub3QgbW9kaWZpZWRcblx0XHRhdHRycyAgPSBfLm1hcChhdHRycywgZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0cmV0dXJuIF8uY2xvbmUoYXR0cik7XG5cdFx0fSk7XG5cdFx0XG5cdFx0dmFyIGxvb2t1cCA9IHt9O1xuXHRcdHJldHVybiBfLmZpbHRlcihhdHRycywgZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0aWYgKCEoYXR0ci5uYW1lIGluIGxvb2t1cCkpIHtcblx0XHRcdFx0cmV0dXJuIGxvb2t1cFthdHRyLm5hbWVdID0gYXR0cjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGxhID0gbG9va3VwW2F0dHIubmFtZV07XG5cdFx0XHRcblx0XHRcdGlmIChhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSA9PSAnY2xhc3MnKSB7XG5cdFx0XHRcdGxhLnZhbHVlICs9IChsYS52YWx1ZS5sZW5ndGggPyAnICcgOiAnJykgKyBhdHRyLnZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGEudmFsdWUgPSBhdHRyLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFeHRyYWN0IHRleHQgZGF0YSBmcm9tIGFiYnJldmlhdGlvbjogaWYgPGNvZGU+YXtoZWxsb308L2NvZGU+IGFiYnJldmlhdGlvblxuXHQgKiBpcyBwYXNzZWQsIHJldHVybnMgb2JqZWN0IDxjb2RlPntlbGVtZW50OiAnYScsIHRleHQ6ICdoZWxsbyd9PC9jb2RlPi5cblx0ICogSWYgbm90aGluZyBmb3VuZCwgcmV0dXJucyA8Y29kZT5udWxsPC9jb2RlPlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHQgKiBcblx0ICovXG5cdGZ1bmN0aW9uIGV4dHJhY3RUZXh0KGFiYnIpIHtcblx0XHRpZiAoIX5hYmJyLmluZGV4T2YoJ3snKSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdFxuXHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHR2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyaW5nU3RyZWFtJykuY3JlYXRlKGFiYnIpO1xuXHRcdHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG5cdFx0XHRzd2l0Y2ggKHN0cmVhbS5wZWVrKCkpIHtcblx0XHRcdFx0Y2FzZSAnWyc6XG5cdFx0XHRcdGNhc2UgJygnOlxuXHRcdFx0XHRcdHN0cmVhbS5za2lwVG9QYWlyKHN0cmVhbS5wZWVrKCksIHBhaXJzW3N0cmVhbS5wZWVrKCldKTsgYnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHRcdFx0c3RyZWFtLnNraXBUb1BhaXIoJ3snLCAnfScpO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBhYmJyLnN1YnN0cmluZygwLCBzdHJlYW0uc3RhcnQpLFxuXHRcdFx0XHRcdFx0dGV4dDogc3RyaXBwZWQoc3RyZWFtLmN1cnJlbnQoKSlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHN0cmVhbS5uZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICog4oCcVW4tcm9sbHPigJwgY29udGVudHMgb2YgY3VycmVudCBub2RlOiByZWN1cnNpdmVseSByZXBsYWNlcyBhbGwgcmVwZWF0aW5nIFxuXHQgKiBjaGlsZHJlbiB3aXRoIHRoZWlyIHJlcGVhdGVkIGNsb25lc1xuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICogQHJldHVybnMge0FiYnJldmlhdGlvbk5vZGV9XG5cdCAqL1xuXHRmdW5jdGlvbiB1bnJvbGwobm9kZSkge1xuXHRcdGZvciAodmFyIGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIGosIGNoaWxkLCBtYXhDb3VudDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNoaWxkLmlzUmVwZWF0aW5nKCkpIHtcblx0XHRcdFx0bWF4Q291bnQgPSBqID0gY2hpbGQucmVwZWF0Q291bnQ7XG5cdFx0XHRcdGNoaWxkLnJlcGVhdENvdW50ID0gMTtcblx0XHRcdFx0Y2hpbGQudXBkYXRlUHJvcGVydHkoJ2NvdW50ZXInLCAxKTtcblx0XHRcdFx0Y2hpbGQudXBkYXRlUHJvcGVydHkoJ21heENvdW50JywgbWF4Q291bnQpO1xuXHRcdFx0XHR3aGlsZSAoLS1qID4gMCkge1xuXHRcdFx0XHRcdGNoaWxkLnBhcmVudC5hZGRDaGlsZChjaGlsZC5jbG9uZSgpLCBpICsgMSlcblx0XHRcdFx0XHRcdC51cGRhdGVQcm9wZXJ0eSgnY291bnRlcicsIGogKyAxKVxuXHRcdFx0XHRcdFx0LnVwZGF0ZVByb3BlcnR5KCdtYXhDb3VudCcsIG1heENvdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyB0byBrZWVwIHByb3BlciAnY291bnRlcicgcHJvcGVydHksIHdlIG5lZWQgdG8gd2Fsa1xuXHRcdC8vIG9uIGNoaWxkcmVuIG9uY2UgYWdhaW5cblx0XHRfLmVhY2gobm9kZS5jaGlsZHJlbiwgdW5yb2xsKTtcblx0XHRcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIE9wdGltaXplcyB0cmVlIG5vZGU6IHJlcGxhY2VzIGVtcHR5IG5vZGVzIHdpdGggdGhlaXIgY2hpbGRyZW5cblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEByZXR1cm4ge0FiYnJldmlhdGlvbk5vZGV9XG5cdCAqL1xuXHRmdW5jdGlvbiBzcXVhc2gobm9kZSkge1xuXHRcdGZvciAodmFyIGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHQvKiogQHR5cGUgQWJicmV2aWF0aW9uTm9kZSAqL1xuXHRcdFx0dmFyIG4gPSBub2RlLmNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKG4uaXNHcm91cCgpKSB7XG5cdFx0XHRcdG4ucmVwbGFjZShzcXVhc2gobikuY2hpbGRyZW4pO1xuXHRcdFx0fSBlbHNlIGlmIChuLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRuLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRfLmVhY2gobm9kZS5jaGlsZHJlbiwgc3F1YXNoKTtcblx0XHRcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNBbGxvd2VkQ2hhcihjaCkge1xuXHRcdHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cdFx0dmFyIHNwZWNpYWxDaGFycyA9ICcjLio6JC1fIUB8JSc7XG5cdFx0XG5cdFx0cmV0dXJuIChjaGFyQ29kZSA+IDY0ICYmIGNoYXJDb2RlIDwgOTEpICAgICAgIC8vIHVwcGVyY2FzZSBsZXR0ZXJcblx0XHRcdFx0fHwgKGNoYXJDb2RlID4gOTYgJiYgY2hhckNvZGUgPCAxMjMpICAvLyBsb3dlcmNhc2UgbGV0dGVyXG5cdFx0XHRcdHx8IChjaGFyQ29kZSA+IDQ3ICYmIGNoYXJDb2RlIDwgNTgpICAgLy8gbnVtYmVyXG5cdFx0XHRcdHx8IHNwZWNpYWxDaGFycy5pbmRleE9mKGNoKSAhPSAtMTsgICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJcblx0fVxuXHRcblx0Ly8gWFhYIGFkZCBjb3VudGVyIHJlcGxhY2VyIGZ1bmN0aW9uIGFzIG91dHB1dCBwcm9jZXNzb3Jcblx0b3V0cHV0UHJvY2Vzc29ycy5wdXNoKGZ1bmN0aW9uKHRleHQsIG5vZGUpIHtcblx0XHRyZXR1cm4gcmVxdWlyZSgndXRpbHMnKS5yZXBsYWNlQ291bnRlcih0ZXh0LCBub2RlLmNvdW50ZXIsIG5vZGUubWF4Q291bnQpO1xuXHR9KTtcblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogUGFyc2VzIGFiYnJldmlhdGlvbiBpbnRvIHRyZWUgd2l0aCByZXNwZWN0IG9mIGdyb3VwcywgXG5cdFx0ICogdGV4dCBub2RlcyBhbmQgYXR0cmlidXRlcy4gRWFjaCBub2RlIG9mIHRoZSB0cmVlIGlzIGEgc2luZ2xlIFxuXHRcdCAqIGFiYnJldmlhdGlvbi4gVHJlZSByZXByZXNlbnRzIGFjdHVhbCBzdHJ1Y3R1cmUgb2YgdGhlIG91dHB1dHRlZCBcblx0XHQgKiByZXN1bHRcblx0XHQgKiBAbWVtYmVyT2YgYWJicmV2aWF0aW9uUGFyc2VyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnIgQWJicmV2aWF0aW9uIHRvIHBhcnNlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBwYXJzZXIgYW5kIHByb2Nlc3NvcnNcblx0XHQgKiBcblx0XHQgKiBAcmV0dXJuIHtBYmJyZXZpYXRpb25Ob2RlfVxuXHRcdCAqL1xuXHRcdHBhcnNlOiBmdW5jdGlvbihhYmJyLCBvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFxuXHRcdFx0dmFyIHRyZWUgPSBwYXJzZUFiYnJldmlhdGlvbihhYmJyKTtcblx0XHRcdFxuXHRcdFx0aWYgKG9wdGlvbnMuY29udGV4dE5vZGUpIHtcblx0XHRcdFx0Ly8gYWRkIGluZm8gYWJvdXQgY29udGV4dCBub2RlIOKAk1xuXHRcdFx0XHQvLyBhIHBhcmVudCBYSFRNTCBub2RlIGluIGVkaXRvciBpbnNpZGUgd2hpY2ggYWJicmV2aWF0aW9uIGlzIFxuXHRcdFx0XHQvLyBleHBhbmRlZFxuXHRcdFx0XHR0cmVlLl9uYW1lID0gb3B0aW9ucy5jb250ZXh0Tm9kZS5uYW1lO1xuXHRcdFx0XHR2YXIgYXR0ckxvb2t1cCA9IHt9O1xuXHRcdFx0XHRfLmVhY2godHJlZS5fYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRcdGF0dHJMb29rdXBbYXR0ci5uYW1lXSA9IGF0dHI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Xy5lYWNoKG9wdGlvbnMuY29udGV4dE5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRcdGlmIChhdHRyLm5hbWUgaW4gYXR0ckxvb2t1cCkge1xuXHRcdFx0XHRcdFx0YXR0ckxvb2t1cFthdHRyLm5hbWVdLnZhbHVlID0gYXR0ci52YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXR0ciA9IF8uY2xvbmUoYXR0cik7XG5cdFx0XHRcdFx0XHR0cmVlLl9hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG5cdFx0XHRcdFx0XHRhdHRyTG9va3VwW2F0dHIubmFtZV0gPSBhdHRyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gYXBwbHkgcHJlcHJvY2Vzc29yc1xuXHRcdFx0Xy5lYWNoKHByZXByb2Nlc3NvcnMsIGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRcdGZuKHRyZWUsIG9wdGlvbnMpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRyZWUgPSBzcXVhc2godW5yb2xsKHRyZWUpKTtcblx0XHRcdFxuXHRcdFx0Ly8gYXBwbHkgcG9zdHByb2Nlc3NvcnNcblx0XHRcdF8uZWFjaChwb3N0cHJvY2Vzc29ycywgZnVuY3Rpb24oZm4pIHtcblx0XHRcdFx0Zm4odHJlZSwgb3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRyZWU7XG5cdFx0fSxcblx0XHRcblx0XHRBYmJyZXZpYXRpb25Ob2RlOiBBYmJyZXZpYXRpb25Ob2RlLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBuZXcgYWJicmV2aWF0aW9uIHByZXByb2Nlc3Nvci4gPGk+UHJlcHJvY2Vzc29yPC9pPiBpcyBhIGZ1bmN0aW9uXG5cdFx0ICogdGhhdCBhcHBsaWVzIHRvIGEgcGFyc2VkIGFiYnJldmlhdGlvbiB0cmVlIHJpZ2h0IGFmdGVyIGl0IGdldCBwYXJzZWQuXG5cdFx0ICogVGhlIHBhc3NlZCB0cmVlIGlzIGluIHVub3B0aW1pemVkIHN0YXRlLlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFByZXByb2Nlc3NvciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiByZWNlaXZlc1xuXHRcdCAqIHR3byBhcmd1bWVudHM6IHBhcnNlZCBhYmJyZXZpYXRpb24gdHJlZSAoPGNvZGU+QWJicmV2aWF0aW9uTm9kZTwvY29kZT4pXG5cdFx0ICogYW5kIDxjb2RlPm9wdGlvbnM8L2NvZGU+IGhhc2ggdGhhdCB3YXMgcGFzc2VkIHRvIDxjb2RlPnBhcnNlPC9jb2RlPlxuXHRcdCAqIG1ldGhvZFxuXHRcdCAqL1xuXHRcdGFkZFByZXByb2Nlc3NvcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdGlmICghXy5pbmNsdWRlKHByZXByb2Nlc3NvcnMsIGZuKSlcblx0XHRcdFx0cHJlcHJvY2Vzc29ycy5wdXNoKGZuKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBwcmVwcm9jZXNzb3Jcblx0XHQgKi9cblx0XHRyZW1vdmVGaWx0ZXI6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRwcmVwcm9jZXNzb3IgPSBfLndpdGhvdXQocHJlcHJvY2Vzc29ycywgZm4pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBuZXcgYWJicmV2aWF0aW9uIHBvc3Rwcm9jZXNzb3IuIDxpPlBvc3Rwcm9jZXNzb3I8L2k+IGlzIGEgXG5cdFx0ICogZnVuY3Rpbm9uIHRoYXQgYXBwbGllcyB0byA8aT5vcHRpbWl6ZWQ8L2k+IHBhcnNlZCBhYmJyZXZpYXRpb24gdHJlZVxuXHRcdCAqIHJpZ2h0IGJlZm9yZSBpdCByZXR1cm5zIGZyb20gPGNvZGU+cGFyc2UoKTwvY29kZT4gbWV0aG9kXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUG9zdHByb2Nlc3NvciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiByZWNlaXZlc1xuXHRcdCAqIHR3byBhcmd1bWVudHM6IHBhcnNlZCBhYmJyZXZpYXRpb24gdHJlZSAoPGNvZGU+QWJicmV2aWF0aW9uTm9kZTwvY29kZT4pXG5cdFx0ICogYW5kIDxjb2RlPm9wdGlvbnM8L2NvZGU+IGhhc2ggdGhhdCB3YXMgcGFzc2VkIHRvIDxjb2RlPnBhcnNlPC9jb2RlPlxuXHRcdCAqIG1ldGhvZFxuXHRcdCAqL1xuXHRcdGFkZFBvc3Rwcm9jZXNzb3I6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRpZiAoIV8uaW5jbHVkZShwb3N0cHJvY2Vzc29ycywgZm4pKVxuXHRcdFx0XHRwb3N0cHJvY2Vzc29ycy5wdXNoKGZuKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBwb3N0cHJvY2Vzc29yIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0cmVtb3ZlUG9zdHByb2Nlc3NvcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdHBvc3Rwcm9jZXNzb3JzID0gXy53aXRob3V0KHBvc3Rwcm9jZXNzb3JzLCBmbik7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgb3V0cHV0IHBvc3Rwcm9jZXNzb3IuIDxpPk91dHB1dCBwcm9jZXNzb3I8L2k+IGlzIGEgXG5cdFx0ICogZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHRvIG91dHB1dCBwYXJ0ICg8Y29kZT5zdGFydDwvY29kZT4sIFxuXHRcdCAqIDxjb2RlPmVuZDwvY29kZT4gYW5kIDxjb2RlPmNvbnRlbnQ8L2NvZGU+KSB3aGVuIFxuXHRcdCAqIDxjb2RlPkFiYnJldmlhdGlvbk5vZGUudG9TdHJpbmcoKTwvY29kZT4gbWV0aG9kIGlzIGNhbGxlZFxuXHRcdCAqL1xuXHRcdGFkZE91dHB1dFByb2Nlc3NvcjogZnVuY3Rpb24oZm4pIHtcblx0XHRcdGlmICghXy5pbmNsdWRlKG91dHB1dFByb2Nlc3NvcnMsIGZuKSlcblx0XHRcdFx0b3V0cHV0UHJvY2Vzc29ycy5wdXNoKGZuKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBvdXRwdXQgcHJvY2Vzc29yXG5cdFx0ICovXG5cdFx0cmVtb3ZlT3V0cHV0UHJvY2Vzc29yOiBmdW5jdGlvbihmbikge1xuXHRcdFx0b3V0cHV0UHJvY2Vzc29ycyA9IF8ud2l0aG91dChvdXRwdXRQcm9jZXNzb3JzLCBmbik7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBwYXNzZWQgc3ltYm9sIGlzIHZhbGlkIHN5bWJvbCBmb3IgYWJicmV2aWF0aW9uIGV4cHJlc3Npb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY2hcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzQWxsb3dlZENoYXI6IGZ1bmN0aW9uKGNoKSB7XG5cdFx0XHRjaCA9IFN0cmluZyhjaCk7IC8vIGNvbnZlcnQgSmF2YSBvYmplY3QgdG8gSlNcblx0XHRcdHJldHVybiBpc0FsbG93ZWRDaGFyKGNoKSB8fCB+Jz4rXltdKCl7fScuaW5kZXhPZihjaCk7XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBQcm9jZXNzb3IgZnVuY3Rpb24gdGhhdCBtYXRjaGVzIHBhcnNlZCA8Y29kZT5BYmJyZXZpYXRpb25Ob2RlPC9jb2RlPlxuICogYWdhaW5zdCByZXNvdXJjZXMgZGVmaW5lZCBpbiA8Y29kZT5yZXNvdXJjZTwvY29kZT4gbW9kdWxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqLyBcbmVtbWV0LmV4ZWMoZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKipcblx0ICogRmluZHMgbWF0Y2hlZCByZXNvdXJjZXMgZm9yIGNoaWxkIG5vZGVzIG9mIHBhc3NlZCA8Y29kZT5ub2RlPC9jb2RlPiBcblx0ICogZWxlbWVudC4gQSBtYXRjaGVkIHJlc291cmNlIGlzIGEgcmVmZXJlbmNlIHRvIDxpPnNuaXBwZXRzLmpzb248L2k+IGVudHJ5XG5cdCAqIHRoYXQgZGVzY3JpYmVzIG91dHB1dCBvZiBwYXJzZWQgbm9kZSBcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoUmVzb3VyY2VzKG5vZGUsIHN5bnRheCkge1xuXHRcdHZhciByZXNvdXJjZXMgPSByZXF1aXJlKCdyZXNvdXJjZXMnKTtcblx0XHR2YXIgZWxlbWVudHMgPSByZXF1aXJlKCdlbGVtZW50cycpO1xuXHRcdHZhciBwYXJzZXIgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25QYXJzZXInKTtcblx0XHRcblx0XHQvLyBkbyBhIHNoYWxsb3cgY29weSBiZWNhdXNlIHRoZSBjaGlsZHJlbiBsaXN0IGNhbiBiZSBtb2RpZmllZCBkdXJpbmdcblx0XHQvLyByZXNvdXJjZSBtYXRjaGluZ1xuXHRcdF8uZWFjaChfLmNsb25lKG5vZGUuY2hpbGRyZW4pLCAvKiogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBjaGlsZCAqLyBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0dmFyIHIgPSByZXNvdXJjZXMuZ2V0TWF0Y2hlZFJlc291cmNlKGNoaWxkLCBzeW50YXgpO1xuXHRcdFx0aWYgKF8uaXNTdHJpbmcocikpIHtcblx0XHRcdFx0Y2hpbGQuZGF0YSgncmVzb3VyY2UnLCBlbGVtZW50cy5jcmVhdGUoJ3NuaXBwZXQnLCByKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnRzLmlzKHIsICdyZWZlcmVuY2UnKSkge1xuXHRcdFx0XHQvLyBpdOKAmXMgYSByZWZlcmVuY2UgdG8gYW5vdGhlciBhYmJyZXZpYXRpb246XG5cdFx0XHRcdC8vIHBhcnNlIGl0IGFuZCBpbnNlcnQgaW5zdGVhZCBvZiBjdXJyZW50IGNoaWxkXG5cdFx0XHRcdC8qKiBAdHlwZSBBYmJyZXZpYXRpb25Ob2RlICovXG5cdFx0XHRcdHZhciBzdWJ0cmVlID0gcGFyc2VyLnBhcnNlKHIuZGF0YSwge1xuXHRcdFx0XHRcdHN5bnRheDogc3ludGF4XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaWYgY29udGV4dCBlbGVtZW50IHNob3VsZCBiZSByZXBlYXRlZCwgY2hlY2sgaWYgd2UgbmVlZCB0byBcblx0XHRcdFx0Ly8gdHJhbnNmZXIgcmVwZWF0ZWQgZWxlbWVudCB0byBzcGVjaWZpYyBjaGlsZCBub2RlXG5cdFx0XHRcdGlmIChjaGlsZC5yZXBlYXRDb3VudCA+IDEpIHtcblx0XHRcdFx0XHR2YXIgcmVwZWF0ZWRDaGlsZHJlbiA9IHN1YnRyZWUuZmluZEFsbChmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbm9kZS5oYXNJbXBsaWNpdFJlcGVhdDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRfLmVhY2gocmVwZWF0ZWRDaGlsZHJlbiwgZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdFx0bm9kZS5yZXBlYXRDb3VudCA9IGNoaWxkLnJlcGVhdENvdW50O1xuXHRcdFx0XHRcdFx0bm9kZS5oYXNJbXBsaWNpdFJlcGVhdCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBtb3ZlIGNoaWxk4oCYcyBjaGlsZHJlbiBpbnRvIHRoZSBkZWVwZXN0IGNoaWxkIG9mIG5ldyBzdWJ0cmVlXG5cdFx0XHRcdHZhciBkZWVwZXN0Q2hpbGQgPSBzdWJ0cmVlLmRlZXBlc3RDaGlsZCgpO1xuXHRcdFx0XHRpZiAoZGVlcGVzdENoaWxkKSB7XG5cdFx0XHRcdFx0Xy5lYWNoKGNoaWxkLmNoaWxkcmVuLCBmdW5jdGlvbihjKSB7XG5cdFx0XHRcdFx0XHRkZWVwZXN0Q2hpbGQuYWRkQ2hpbGQoYyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvcHkgY3VycmVudCBhdHRyaWJ1dGVzIHRvIGNoaWxkcmVuXG5cdFx0XHRcdF8uZWFjaChzdWJ0cmVlLmNoaWxkcmVuLCBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdFx0Xy5lYWNoKGNoaWxkLmF0dHJpYnV0ZUxpc3QoKSwgZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0XHRcdFx0bm9kZS5hdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjaGlsZC5yZXBsYWNlKHN1YnRyZWUuY2hpbGRyZW4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuZGF0YSgncmVzb3VyY2UnLCByKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bWF0Y2hSZXNvdXJjZXMoY2hpbGQsIHN5bnRheCk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8vIFhYWCByZWdpc3RlciBhYmJyZXZpYXRpb24gZmlsdGVyIHRoYXQgY3JlYXRlcyByZWZlcmVuY2VzIHRvIHJlc291cmNlc1xuXHQvLyBvbiBhYmJyZXZpYXRpb24gbm9kZXNcblx0LyoqXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKi9cblx0cmVxdWlyZSgnYWJicmV2aWF0aW9uUGFyc2VyJykuYWRkUHJlcHJvY2Vzc29yKGZ1bmN0aW9uKHRyZWUsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3ludGF4ID0gb3B0aW9ucy5zeW50YXggfHwgZW1tZXQuZGVmYXVsdFN5bnRheCgpO1xuXHRcdG1hdGNoUmVzb3VyY2VzKHRyZWUsIHN5bnRheCk7XG5cdH0pO1xuXHRcbn0pOy8qKlxuICogUGFzdGVkIGNvbnRlbnQgYWJicmV2aWF0aW9uIHByb2Nlc3Nvci4gQSBwYXN0ZWQgY29udGVudCBpcyBhIGNvbnRlbnQgdGhhdFxuICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gaW1wbGljaXRseSByZXBlYXRlZCBhYmJyZXZpYXRpb24gbm9kZXMuXG4gKiBUaGlzIHByb2Nlc3NvciBwb3dlcnMg4oCcV3JhcCBXaXRoIEFiYnJldmlhdGlvbuKAnSBhY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIHBhcnNlciA9IHJlcXVpcmUoJ2FiYnJldmlhdGlvblBhcnNlcicpO1xuXHR2YXIgb3V0cHV0UGxhY2Vob2xkZXIgPSAnJCMnO1xuXHRcblx0LyoqXG5cdCAqIExvY2F0ZXMgb3V0cHV0IHBsYWNlaG9sZGVycyBpbnNpZGUgdGV4dFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHJhbmdlcyBvZiBvdXRwdXQgcGxhY2Vob2xkZXIgaW4gdGV4dFxuXHQgKi9cblx0ZnVuY3Rpb24gbG9jYXRlT3V0cHV0UGxhY2Vob2xkZXIodGV4dCkge1xuXHRcdHZhciByYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJyk7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFxuXHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHR2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyaW5nU3RyZWFtJykuY3JlYXRlKHRleHQpO1xuXHRcdFxuXHRcdHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG5cdFx0XHRpZiAoc3RyZWFtLnBlZWsoKSA9PSAnXFxcXCcpIHtcblx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHRcdGlmIChzdHJlYW0ubWF0Y2gob3V0cHV0UGxhY2Vob2xkZXIsIHRydWUpKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2gocmFuZ2UuY3JlYXRlKHN0cmVhbS5zdGFydCwgb3V0cHV0UGxhY2Vob2xkZXIpKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlcGxhY2VzIG91dHB1dCBwbGFjZWhvbGRlcnMgaW5zaWRlIDxjb2RlPnNvdXJjZTwvY29kZT4gd2l0aCBcblx0ICogPGNvZGU+dmFsdWU8L2NvZGU+XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiByZXBsYWNlT3V0cHV0UGxhY2Vob2xkZXJzKHNvdXJjZSwgdmFsdWUpIHtcblx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdHZhciByYW5nZXMgPSBsb2NhdGVPdXRwdXRQbGFjZWhvbGRlcihzb3VyY2UpO1xuXHRcdFxuXHRcdHJhbmdlcy5yZXZlcnNlKCk7XG5cdFx0Xy5lYWNoKHJhbmdlcywgZnVuY3Rpb24ocikge1xuXHRcdFx0c291cmNlID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyhzb3VyY2UsIHZhbHVlLCByKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gc291cmNlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgcGFyc2VkIG5vZGUgY29udGFpbnMgb3V0cHV0IHBsYWNlaG9sZGVyIOKAkyBhIHRhcmdldCB3aGVyZVxuXHQgKiBwYXN0ZWQgY29udGVudCBzaG91bGQgYmUgaW5zZXJ0ZWRcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzT3V0cHV0UGxhY2Vob2xkZXIobm9kZSkge1xuXHRcdGlmIChsb2NhdGVPdXRwdXRQbGFjZWhvbGRlcihub2RlLmNvbnRlbnQpLmxlbmd0aClcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFxuXHRcdC8vIGNoZWNrIGlmIGF0dHJpYnV0ZXMgY29udGFpbnMgcGxhY2Vob2xkZXJcblx0XHRyZXR1cm4gISFfLmZpbmQobm9kZS5hdHRyaWJ1dGVMaXN0KCksIGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdHJldHVybiAhIWxvY2F0ZU91dHB1dFBsYWNlaG9sZGVyKGF0dHIudmFsdWUpLmxlbmd0aDtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluc2VydCBwYXN0ZWQgY29udGVudCBpbnRvIGNvcnJlY3QgcG9zaXRpb25zIG9mIHBhcnNlZCBub2RlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJ3cml0ZSBPdmVyd3JpdGUgbm9kZSBjb250ZW50IGlmIG5vIHZhbHVlIHBsYWNlaG9sZGVyc1xuXHQgKiBmb3VuZCBpbnN0ZWFkIG9mIGFwcGVuZGluZyB0byBleGlzdGluZyBjb250ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBpbnNlcnRQYXN0ZWRDb250ZW50KG5vZGUsIGNvbnRlbnQsIG92ZXJ3cml0ZSkge1xuXHRcdHZhciBub2Rlc1dpdGhQbGFjZWhvbGRlcnMgPSBub2RlLmZpbmRBbGwoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGhhc091dHB1dFBsYWNlaG9sZGVyKGl0ZW0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChoYXNPdXRwdXRQbGFjZWhvbGRlcihub2RlKSlcblx0XHRcdG5vZGVzV2l0aFBsYWNlaG9sZGVycy51bnNoaWZ0KG5vZGUpO1xuXHRcdFxuXHRcdGlmIChub2Rlc1dpdGhQbGFjZWhvbGRlcnMubGVuZ3RoKSB7XG5cdFx0XHRfLmVhY2gobm9kZXNXaXRoUGxhY2Vob2xkZXJzLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGl0ZW0uY29udGVudCA9IHJlcGxhY2VPdXRwdXRQbGFjZWhvbGRlcnMoaXRlbS5jb250ZW50LCBjb250ZW50KTtcblx0XHRcdFx0Xy5lYWNoKGl0ZW0uX2F0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdFx0XHRhdHRyLnZhbHVlID0gcmVwbGFjZU91dHB1dFBsYWNlaG9sZGVycyhhdHRyLnZhbHVlLCBjb250ZW50KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gb24gb3V0cHV0IHBsYWNlaG9sZGVycyBpbiBzdWJ0cmVlLCBpbnNlcnQgY29udGVudCBpbiB0aGUgZGVlcGVzdFxuXHRcdFx0Ly8gY2hpbGQgbm9kZVxuXHRcdFx0dmFyIGRlZXBlc3QgPSBub2RlLmRlZXBlc3RDaGlsZCgpIHx8IG5vZGU7XG5cdFx0XHRpZiAob3ZlcndyaXRlKSB7XG5cdFx0XHRcdGRlZXBlc3QuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWVwZXN0LmNvbnRlbnQgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpLmluc2VydENoaWxkQ29udGVudChkZWVwZXN0LmNvbnRlbnQsIGNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0cGFyc2VyLmFkZFByZXByb2Nlc3NvcihmdW5jdGlvbih0cmVlLCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMucGFzdGVkQ29udGVudCkge1xuXHRcdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcdHZhciBsaW5lcyA9IF8ubWFwKHV0aWxzLnNwbGl0QnlMaW5lcyhvcHRpb25zLnBhc3RlZENvbnRlbnQsIHRydWUpLCB1dGlscy50cmltKTtcblx0XHRcdFxuXHRcdFx0Ly8gc2V0IHJlcGVhdCBjb3VudCBmb3IgaW1wbGljaXRseSByZXBlYXRlZCBlbGVtZW50cyBiZWZvcmVcblx0XHRcdC8vIHRyZWUgaXMgdW5yb2xsZWRcblx0XHRcdHRyZWUuZmluZEFsbChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGlmIChpdGVtLmhhc0ltcGxpY2l0UmVwZWF0KSB7XG5cdFx0XHRcdFx0aXRlbS5kYXRhKCdwYXN0ZScsIGxpbmVzKTtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS5yZXBlYXRDb3VudCA9IGxpbmVzLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdHBhcnNlci5hZGRQb3N0cHJvY2Vzc29yKGZ1bmN0aW9uKHRyZWUsIG9wdGlvbnMpIHtcblx0XHQvLyBmb3IgZWFjaCBub2RlIHdpdGggcGFzdGVkIGNvbnRlbnQsIHVwZGF0ZSB0ZXh0IGRhdGFcblx0XHR2YXIgdGFyZ2V0cyA9IHRyZWUuZmluZEFsbChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgcGFzdGVkQ29udGVudE9iaiA9IGl0ZW0uZGF0YSgncGFzdGUnKTtcblx0XHRcdHZhciBwYXN0ZWRDb250ZW50ID0gJyc7XG5cdFx0XHRpZiAoXy5pc0FycmF5KHBhc3RlZENvbnRlbnRPYmopKSB7XG5cdFx0XHRcdHBhc3RlZENvbnRlbnQgPSBwYXN0ZWRDb250ZW50T2JqW2l0ZW0uY291bnRlciAtIDFdO1xuXHRcdFx0fSBlbHNlIGlmIChfLmlzRnVuY3Rpb24ocGFzdGVkQ29udGVudE9iaikpIHtcblx0XHRcdFx0cGFzdGVkQ29udGVudCA9IHBhc3RlZENvbnRlbnRPYmooaXRlbS5jb3VudGVyIC0gMSwgaXRlbS5jb250ZW50KTtcblx0XHRcdH0gZWxzZSBpZiAocGFzdGVkQ29udGVudE9iaikge1xuXHRcdFx0XHRwYXN0ZWRDb250ZW50ID0gcGFzdGVkQ29udGVudE9iajtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHBhc3RlZENvbnRlbnQpIHtcblx0XHRcdFx0aW5zZXJ0UGFzdGVkQ29udGVudChpdGVtLCBwYXN0ZWRDb250ZW50LCAhIWl0ZW0uZGF0YSgncGFzdGVPdmVyd3JpdGVzJykpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpdGVtLmRhdGEoJ3Bhc3RlJywgbnVsbCk7XG5cdFx0XHRyZXR1cm4gISFwYXN0ZWRDb250ZW50T2JqO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgb3B0aW9ucy5wYXN0ZWRDb250ZW50KSB7XG5cdFx0XHQvLyBubyBpbXBsaWNpdGx5IHJlcGVhdGVkIGVsZW1lbnRzLCBwdXQgcGFzdGVkIGNvbnRlbnQgaW5cblx0XHRcdC8vIHRoZSBkZWVwZXN0IGNoaWxkXG5cdFx0XHRpbnNlcnRQYXN0ZWRDb250ZW50KHRyZWUsIG9wdGlvbnMucGFzdGVkQ29udGVudCk7XG5cdFx0fVxuXHR9KTtcbn0pOy8qKlxuICogUmVzb2x2ZXMgdGFnIG5hbWVzIGluIGFiYnJldmlhdGlvbnMgd2l0aCBpbXBsaWVkIG5hbWVcbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBSZXNvbHZlcyBpbXBsaWNpdCBub2RlIG5hbWVzIGluIHBhcnNlZCB0cmVlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzb2x2ZU5vZGVOYW1lcyh0cmVlKSB7XG5cdFx0dmFyIHRhZ05hbWUgPSByZXF1aXJlKCd0YWdOYW1lJyk7XG5cdFx0Xy5lYWNoKHRyZWUuY2hpbGRyZW4sIGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdGlmIChub2RlLmhhc0ltcGxpY2l0TmFtZSgpIHx8IG5vZGUuZGF0YSgnZm9yY2VOYW1lUmVzb2x2aW5nJykpIHtcblx0XHRcdFx0bm9kZS5fbmFtZSA9IHRhZ05hbWUucmVzb2x2ZShub2RlLnBhcmVudC5uYW1lKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmVzb2x2ZU5vZGVOYW1lcyhub2RlKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fVxuXHRcblx0cmVxdWlyZSgnYWJicmV2aWF0aW9uUGFyc2VyJykuYWRkUG9zdHByb2Nlc3NvcihyZXNvbHZlTm9kZU5hbWVzKTtcbn0pOy8qKlxuICogQGF1dGhvciBTdG95YW4gU3RlZmFub3ZcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdG95YW4vZXRjL3RyZWUvbWFzdGVyL2Nzc2V4XG4gKi9cblxuZW1tZXQuZGVmaW5lKCdjc3NQYXJzZXInLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG52YXIgd2Fsa2VyLCB0b2tlbnMgPSBbXSwgaXNPcCwgaXNOYW1lQ2hhciwgaXNEaWdpdDtcbiAgICBcbiAgICAvLyB3YWxrcyBhcm91bmQgdGhlIHNvdXJjZVxuICAgIHdhbGtlciA9IHtcbiAgICAgICAgbGluZXM6IG51bGwsXG4gICAgICAgIHRvdGFsX2xpbmVzOiAwLFxuICAgICAgICBsaW5lbnVtOiAtMSxcbiAgICAgICAgbGluZTogJycsXG4gICAgICAgIGNoOiAnJyxcbiAgICAgICAgY2hudW06IC0xLFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB3YWxrZXI7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gc291cmNlLCB5dW1tXG4gICAgICAgICAgICBtZS5saW5lcyA9IHNvdXJjZVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxuJylcbiAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgbWUudG90YWxfbGluZXMgPSBtZS5saW5lcy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgICAgIG1lLmNobnVtID0gLTE7XG4gICAgICAgICAgICBtZS5saW5lbnVtID0gLTE7XG4gICAgICAgICAgICBtZS5jaCA9ICcnO1xuICAgICAgICAgICAgbWUubGluZSA9ICcnO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGFkdmFuY2VcbiAgICAgICAgICAgIG1lLm5leHRMaW5lKCk7XG4gICAgICAgICAgICBtZS5uZXh0Q2hhcigpO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0TGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIG1lLmxpbmVudW0gKz0gMTtcbiAgICAgICAgICAgIGlmIChtZS50b3RhbF9saW5lcyA8PSBtZS5saW5lbnVtKSB7XG4gICAgICAgICAgICAgICAgbWUubGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5saW5lID0gbWUubGluZXNbbWUubGluZW51bV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWUuY2hudW0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbWUuY2hudW0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lLmxpbmU7XG4gICAgICAgIH0sIFxuICAgICAgICBuZXh0Q2hhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIG1lLmNobnVtICs9IDE7XG4gICAgICAgICAgICB3aGlsZSAobWUubGluZS5jaGFyQXQobWUuY2hudW0pID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRMaW5lKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZW5kIG9mIHNvdXJjZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5jaG51bSA9IC0xO1xuICAgICAgICAgICAgICAgIG1lLmNoID0gJ1xcbic7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWUuY2ggPSBtZS5saW5lLmNoYXJBdChtZS5jaG51bSk7XG4gICAgICAgICAgICByZXR1cm4gbWUuY2g7XG4gICAgICAgIH0sXG4gICAgICAgIHBlZWs6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZS5jaGFyQXQodGhpcy5jaG51bSArIDEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHV0aWxpdHkgaGVscGVyc1xuICAgIGlzTmFtZUNoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgIFx0Ly8gYmUgbW9yZSB0b2xlcmF0ZSBmb3IgbmFtZSB0b2tlbnM6IGFsbG93ICYgY2hhcmFjdGVyIGZvciBMRVNTIHN5bnRheFxuICAgICAgICByZXR1cm4gKGMgPT0gJyYnIHx8IGMgPT09ICdfJyB8fCBjID09PSAnLScgfHwgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSB8fCAoYyA+PSAnQScgJiYgYyA8PSAnWicpKTtcbiAgICB9O1xuXG4gICAgaXNEaWdpdCA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICByZXR1cm4gKGNoICE9PSBmYWxzZSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKTtcbiAgICB9OyAgXG5cbiAgICBpc09wID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wc2EgPSBcInt9W10oKSsqPS4sOzo+fnxcXFxcJSQjQF4hXCIuc3BsaXQoJycpLFxuICAgICAgICAgICAgb3BzbWF0Y2hhID0gXCIqXnwkflwiLnNwbGl0KCcnKSxcbiAgICAgICAgICAgIG9wcyA9IHt9LFxuICAgICAgICAgICAgb3BzbWF0Y2ggPSB7fSxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IG9wc2EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9wc1tvcHNhW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wc21hdGNoYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgb3BzbWF0Y2hbb3BzbWF0Y2hhW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaCwgbWF0Y2hhdHRyKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hhdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhb3BzbWF0Y2hbY2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICEhb3BzW2NoXTtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuICAgIFxuICAgIC8vIHNob3J0aGFuZHNcbiAgICBmdW5jdGlvbiBpc3NldCh2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbmYoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY2hhcic6IHdhbGtlci5jaG51bSxcbiAgICAgICAgICAgIGxpbmU6IHdhbGtlci5saW5lbnVtXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvLyBjcmVhdGVzIHRva2VuIG9iamVjdHMgYW5kIHB1c2hlcyB0aGVtIHRvIGEgbGlzdFxuICAgIGZ1bmN0aW9uIHRva2VuZXIodmFsdWUsIHR5cGUsIGNvbmYpIHtcbiAgICAgICAgdmFyIHcgPSB3YWxrZXIsIGMgPSBjb25mIHx8IHt9O1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICBjaGFyc3RhcnQ6IGlzc2V0KGNbJ2NoYXInXSkgPyBjWydjaGFyJ10gOiB3LmNobnVtLFxuICAgICAgICAgICAgY2hhcmVuZDogICBpc3NldChjLmNoYXJlbmQpID8gYy5jaGFyZW5kIDogdy5jaG51bSxcbiAgICAgICAgICAgIGxpbmVzdGFydDogaXNzZXQoYy5saW5lKSAgICA/IGMubGluZSAgICA6IHcubGluZW51bSxcbiAgICAgICAgICAgIGxpbmVlbmQ6ICAgaXNzZXQoYy5saW5lZW5kKSA/IGMubGluZWVuZCA6IHcubGluZW51bSxcbiAgICAgICAgICAgIHZhbHVlOiAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlOiAgICAgIHR5cGUgfHwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIG9vcHNcbiAgICBmdW5jdGlvbiBlcnJvcihtLCBjb25maWcpIHsgXG4gICAgICAgIHZhciB3ID0gd2Fsa2VyLFxuICAgICAgICAgICAgY29uZiA9IGNvbmZpZyB8fCB7fSxcbiAgICAgICAgICAgIGMgPSBpc3NldChjb25mWydjaGFyJ10pID8gY29uZlsnY2hhciddIDogdy5jaG51bSxcbiAgICAgICAgICAgIGwgPSBpc3NldChjb25mLmxpbmUpID8gY29uZi5saW5lIDogdy5saW5lbnVtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogXCJQYXJzZUVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBtICsgXCIgYXQgbGluZSBcIiArIChsICsgMSkgKyAnIGNoYXIgJyArIChjICsgMSksXG4gICAgICAgICAgICB3YWxrZXI6IHcsXG4gICAgICAgICAgICB0b2tlbnM6IHRva2Vuc1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gdG9rZW4gaGFuZGxlcnMgZm9sbG93IGZvcjpcbiAgICAvLyB3aGl0ZSBzcGFjZSwgY29tbWVudCwgc3RyaW5nLCBpZGVudGlmaWVyLCBudW1iZXIsIG9wZXJhdG9yXG4gICAgZnVuY3Rpb24gd2hpdGUoKSB7XG4gICAgXG4gICAgICAgIHZhciBjID0gd2Fsa2VyLmNoLFxuICAgICAgICAgICAgdG9rZW4gPSAnJyxcbiAgICAgICAgICAgIGNvbmYgPSBnZXRDb25mKCk7XG4gICAgXG4gICAgICAgIHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiKSB7XG4gICAgICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICAgICAgYyA9IHdhbGtlci5uZXh0Q2hhcigpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHRva2VuZXIodG9rZW4sICd3aGl0ZScsIGNvbmYpO1xuICAgIFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG4gICAgXG4gICAgICAgIHZhciB3ID0gd2Fsa2VyLFxuICAgICAgICAgICAgYyA9IHcuY2gsXG4gICAgICAgICAgICB0b2tlbiA9IGMsXG4gICAgICAgICAgICBjbmV4dCxcbiAgICAgICAgICAgIGNvbmYgPSBnZXRDb25mKCk7ICAgIFxuICAgICBcbiAgICAgICAgY25leHQgPSB3Lm5leHRDaGFyKCk7XG5cbiAgICAgICAgaWYgKGNuZXh0ID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIGlubGluZSBjb21tZW50IGluIFNDU1MgYW5kIHN1Y2hcbiAgICAgICAgICAgIHRva2VuICs9IGNuZXh0O1xuICAgICAgICAgICAgdmFyIHBrID0gdy5wZWVrKCk7XG4gICAgICAgICAgICB3aGlsZSAocGsgJiYgcGsgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gKz0gY25leHQ7XG4gICAgICAgICAgICAgICAgY25leHQgPSB3Lm5leHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgcGsgPSB3LnBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbmV4dCA9PT0gJyonKSB7XG4gICAgICAgICAgICAvLyBtdWx0aWxpbmUgQ1NTIGNvbW1tZW50XG4gICAgICAgICAgICB3aGlsZSAoIShjID09PSBcIipcIiAmJiBjbmV4dCA9PT0gXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gKz0gY25leHQ7XG4gICAgICAgICAgICAgICAgYyA9IGNuZXh0O1xuICAgICAgICAgICAgICAgIGNuZXh0ID0gdy5uZXh0Q2hhcigpOyAgICAgICAgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvb3BzLCBub3QgYSBjb21tZW50LCBqdXN0IGEgL1xuICAgICAgICAgICAgY29uZi5jaGFyZW5kID0gY29uZlsnY2hhciddO1xuICAgICAgICAgICAgY29uZi5saW5lZW5kID0gY29uZi5saW5lO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuZXIodG9rZW4sIHRva2VuLCBjb25mKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdG9rZW4gKz0gY25leHQ7XG4gICAgICAgIHcubmV4dENoYXIoKTtcbiAgICAgICAgdG9rZW5lcih0b2tlbiwgJ2NvbW1lbnQnLCBjb25mKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHIoKSB7XG4gICAgICAgIHZhciB3ID0gd2Fsa2VyLFxuICAgICAgICAgICAgYyA9IHcuY2gsXG4gICAgICAgICAgICBxID0gYyxcbiAgICAgICAgICAgIHRva2VuID0gYyxcbiAgICAgICAgICAgIGNuZXh0LFxuICAgICAgICAgICAgY29uZiA9IGdldENvbmYoKTtcbiAgICBcbiAgICAgICAgYyA9IHcubmV4dENoYXIoKTtcbiAgICBcbiAgICAgICAgd2hpbGUgKGMgIT09IHEpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgY25leHQgPSB3Lm5leHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNuZXh0ID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiArPSBjICsgY25leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIGxpbmUgd2l0aCBubyBcXCBlc2NhcGUgPSBiYWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nXCIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuICs9IGMgKyB3Lm5leHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgYyA9IHcubmV4dENoYXIoKTtcbiAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgdy5uZXh0Q2hhcigpO1xuICAgICAgICB0b2tlbmVyKHRva2VuLCAnc3RyaW5nJywgY29uZik7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGJyYWNlKCkge1xuICAgICAgICB2YXIgdyA9IHdhbGtlcixcbiAgICAgICAgICAgIGMgPSB3LmNoLFxuICAgICAgICAgICAgZGVwdGggPSAwLFxuICAgICAgICAgICAgdG9rZW4gPSBjLFxuICAgICAgICAgICAgY29uZiA9IGdldENvbmYoKTtcbiAgICBcbiAgICAgICAgYyA9IHcubmV4dENoYXIoKTtcbiAgICBcbiAgICAgICAgd2hpbGUgKGMgIT09ICcpJyAmJiAhZGVwdGgpIHtcbiAgICAgICAgXHRpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgIFx0XHRkZXB0aCsrO1xuICAgICAgICBcdH0gZWxzZSBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgIFx0XHRkZXB0aC0tO1xuICAgICAgICBcdH0gZWxzZSBpZiAoYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgXHRcdHRocm93IGVycm9yKFwiVW50ZXJtaW5hdGVkIGJyYWNlXCIsIGNvbmYpO1xuICAgICAgICBcdH1cbiAgICAgICAgXHRcbiAgICAgICAgXHR0b2tlbiArPSBjO1xuICAgICAgICAgICAgYyA9IHcubmV4dENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgdy5uZXh0Q2hhcigpO1xuICAgICAgICB0b2tlbmVyKHRva2VuLCAnYnJhY2UnLCBjb25mKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZGVudGlmaWVyKHByZSkge1xuICAgICAgICB2YXIgdyA9IHdhbGtlcixcbiAgICAgICAgICAgIGMgPSB3LmNoLFxuICAgICAgICAgICAgY29uZiA9IGdldENvbmYoKSxcbiAgICAgICAgICAgIHRva2VuID0gKHByZSkgPyBwcmUgKyBjIDogYztcbiAgICAgICAgICAgIFxuICAgICAgICBjID0gdy5uZXh0Q2hhcigpO1xuICAgIFxuICAgICAgICBpZiAocHJlKSB7IC8vIGFkanVzdCB0b2tlbiBwb3NpdGlvblxuICAgICAgICBcdGNvbmZbJ2NoYXInXSAtPSBwcmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAoaXNOYW1lQ2hhcihjKSB8fCBpc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICAgICAgYyA9IHcubmV4dENoYXIoKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICB0b2tlbmVyKHRva2VuLCAnaWRlbnRpZmllcicsIGNvbmYpOyAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBudW0oKSB7XG4gICAgICAgIHZhciB3ID0gd2Fsa2VyLFxuICAgICAgICAgICAgYyA9IHcuY2gsXG4gICAgICAgICAgICBjb25mID0gZ2V0Q29uZigpLFxuICAgICAgICAgICAgdG9rZW4gPSBjLFxuICAgICAgICAgICAgcG9pbnQgPSB0b2tlbiA9PT0gJy4nLFxuICAgICAgICAgICAgbm9uZGlnaXQ7XG4gICAgICAgIFxuICAgICAgICBjID0gdy5uZXh0Q2hhcigpO1xuICAgICAgICBub25kaWdpdCA9ICFpc0RpZ2l0KGMpO1xuICAgIFxuICAgICAgICAvLyAuMnB4IG9yIC5jbGFzc25hbWU/XG4gICAgICAgIGlmIChwb2ludCAmJiBub25kaWdpdCkge1xuICAgICAgICAgICAgLy8gbWVoLCBOYU4sIGNvdWxkIGJlIGEgY2xhc3MgbmFtZSwgc28gaXQncyBhbiBvcGVyYXRvciBmb3Igbm93XG4gICAgICAgICAgICBjb25mLmNoYXJlbmQgPSBjb25mWydjaGFyJ107XG4gICAgICAgICAgICBjb25mLmxpbmVlbmQgPSBjb25mLmxpbmU7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5lcih0b2tlbiwgJy4nLCBjb25mKTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIC0ycHggb3IgLW1vei1zb21ldGhpbmdcbiAgICAgICAgaWYgKHRva2VuID09PSAnLScgJiYgbm9uZGlnaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyKCctJyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgd2hpbGUgKGMgIT09IGZhbHNlICYmIChpc0RpZ2l0KGMpIHx8ICghcG9pbnQgJiYgYyA9PT0gJy4nKSkpIHsgLy8gbm90IGVuZCBvZiBzb3VyY2UgJiYgZGlnaXQgb3IgZmlyc3QgaW5zdGFuY2Ugb2YgLlxuICAgICAgICAgICAgaWYgKGMgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgICAgICBjID0gdy5uZXh0Q2hhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW5lcih0b2tlbiwgJ251bWJlcicsIGNvbmYpOyAgICBcbiAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcCgpIHtcbiAgICAgICAgdmFyIHcgPSB3YWxrZXIsXG4gICAgICAgICAgICBjID0gdy5jaCxcbiAgICAgICAgICAgIGNvbmYgPSBnZXRDb25mKCksXG4gICAgICAgICAgICB0b2tlbiA9IGMsXG4gICAgICAgICAgICBuZXh0ID0gdy5uZXh0Q2hhcigpO1xuICAgICAgICAgICAgXG4gICAgICAgIGlmIChuZXh0ID09PSBcIj1cIiAmJiBpc09wKHRva2VuLCB0cnVlKSkge1xuICAgICAgICAgICAgdG9rZW4gKz0gbmV4dDtcbiAgICAgICAgICAgIHRva2VuZXIodG9rZW4sICdtYXRjaCcsIGNvbmYpO1xuICAgICAgICAgICAgdy5uZXh0Q2hhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgY29uZi5jaGFyZW5kID0gY29uZlsnY2hhciddICsgMTtcbiAgICAgICAgY29uZi5saW5lZW5kID0gY29uZi5saW5lOyAgICBcbiAgICAgICAgdG9rZW5lcih0b2tlbiwgdG9rZW4sIGNvbmYpO1xuICAgIH1cblxuXG4gICAgLy8gY2FsbCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlciBiYXNlZCBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGEgdG9rZW4gc3VzcGVjdFxuICAgIGZ1bmN0aW9uIHRva2VuaXplKCkge1xuXG4gICAgICAgIHZhciBjaCA9IHdhbGtlci5jaDtcbiAgICBcbiAgICAgICAgaWYgKGNoID09PSBcIiBcIiB8fCBjaCA9PT0gXCJcXHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHdoaXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQoKTtcbiAgICAgICAgfSBcblxuICAgICAgICBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJygnKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJhY2UoKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nIHx8IGlzRGlnaXQoY2gpKSB7IC8vIHRyaWNreSAtIGNoYXI6IG1pbnVzICgtMXB4KSBvciBkYXNoICgtbW96LXN0dWZmKVxuICAgICAgICAgICAgcmV0dXJuIG51bSgpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChpc05hbWVDaGFyKGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc09wKGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgdG9rZW5lcihcImxpbmVcIik7XG4gICAgICAgICAgICB3YWxrZXIubmV4dENoYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgZXJyb3IoXCJVbnJlY29nbml6ZWQgY2hhcmFjdGVyXCIpO1xuICAgIH1cbiAgICBcbiAgICAvKipcblx0ICogUmV0dXJucyBuZXdsaW5lIGNoYXJhY3RlciBhdCBzcGVjaWZpZWQgcG9zaXRpb24gaW4gY29udGVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGdldE5ld2xpbmUoY29udGVudCwgcG9zKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQuY2hhckF0KHBvcykgPT0gJ1xccicgJiYgY29udGVudC5jaGFyQXQocG9zICsgMSkgPT0gJ1xcbicgXG5cdFx0XHQ/ICdcXHJcXG4nIFxuXHRcdFx0OiBjb250ZW50LmNoYXJBdChwb3MpO1xuXHR9XG5cbiAgICByZXR1cm4ge1xuICAgIFx0LyoqXG4gICAgXHQgKiBAcGFyYW0gc291cmNlXG4gICAgXHQgKiBAcmV0dXJuc1xuICAgIFx0ICogQG1lbWJlck9mIGVtbWV0LmNzc1BhcnNlclxuICAgIFx0ICovXG4gICAgICAgIGxleDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgd2Fsa2VyLmluaXQoc291cmNlKTtcbiAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHdhbGtlci5jaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0b2tlbml6ZSgpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2tlbml6ZXMgQ1NTIHNvdXJjZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgXHQvLyB0cmFuc2Zvcm0gdG9rZW5zXG5cdCBcdFx0dmFyIHBvcyA9IDA7XG5cdCBcdFx0cmV0dXJuIF8ubWFwKHRoaXMubGV4KHNvdXJjZSksIGZ1bmN0aW9uKHRva2VuKSB7XG5cdCBcdFx0XHRpZiAodG9rZW4udHlwZSA9PSAnbGluZScpIHtcblx0IFx0XHRcdFx0dG9rZW4udmFsdWUgPSBnZXROZXdsaW5lKHNvdXJjZSwgcG9zKTtcblx0IFx0XHRcdH1cblx0IFx0XHRcdFxuXHQgXHRcdFx0cmV0dXJuIHtcblx0IFx0XHRcdFx0dHlwZTogdG9rZW4udHlwZSxcblx0IFx0XHRcdFx0c3RhcnQ6IHBvcyxcblx0IFx0XHRcdFx0ZW5kOiAocG9zICs9IHRva2VuLnZhbHVlLmxlbmd0aClcblx0IFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHR9LFxuICAgICAgICBcbiAgICAgICAgdG9Tb3VyY2U6IGZ1bmN0aW9uICh0b2tzKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIG1heCA9IHRva3MubGVuZ3RoLCB0LCBzcmMgPSAnJztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbWF4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0ID0gdG9rc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodC50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyArPSB0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9O1xufSk7LyoqXG4gKiBIVE1MIHRva2VuaXplciBieSBNYXJpam4gSGF2ZXJiZWtlXG4gKiBodHRwOi8vY29kZW1pcnJvci5uZXQvXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX3htbFBhcnNlRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZGVmaW5lKCd4bWxQYXJzZXInLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciBLbHVkZ2VzID0ge1xuXHRcdGF1dG9TZWxmQ2xvc2VycyA6IHt9LFxuXHRcdGltcGxpY2l0bHlDbG9zZWQgOiB7fSxcblx0XHRjb250ZXh0R3JhYmJlcnMgOiB7fSxcblx0XHRkb05vdEluZGVudCA6IHt9LFxuXHRcdGFsbG93VW5xdW90ZWQgOiB0cnVlLFxuXHRcdGFsbG93TWlzc2luZyA6IHRydWVcblx0fTtcblxuXHQvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXG5cdHZhciB0YWdOYW1lID0gbnVsbCwgdHlwZSA9IG51bGw7XG5cblx0ZnVuY3Rpb24gaW5UZXh0KHN0cmVhbSwgc3RhdGUpIHtcblx0XHRmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcblx0XHRcdHN0YXRlLnRva2VuaXplID0gcGFyc2VyO1xuXHRcdFx0cmV0dXJuIHBhcnNlcihzdHJlYW0sIHN0YXRlKTtcblx0XHR9XG5cblx0XHR2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXHRcdGlmIChjaCA9PSBcIjxcIikge1xuXHRcdFx0aWYgKHN0cmVhbS5lYXQoXCIhXCIpKSB7XG5cdFx0XHRcdGlmIChzdHJlYW0uZWF0KFwiW1wiKSkge1xuXHRcdFx0XHRcdGlmIChzdHJlYW0ubWF0Y2goXCJDREFUQVtcIikpXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hhaW4oaW5CbG9jayhcImF0b21cIiwgXCJdXT5cIikpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIi0tXCIpKVxuXHRcdFx0XHRcdHJldHVybiBjaGFpbihpbkJsb2NrKFwiY29tbWVudFwiLCBcIi0tPlwiKSk7XG5cdFx0XHRcdGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIkRPQ1RZUEVcIiwgdHJ1ZSwgdHJ1ZSkpIHtcblx0XHRcdFx0XHRzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuXHRcdFx0XHRcdHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKSB7XG5cdFx0XHRcdHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl9cXC1dLyk7XG5cdFx0XHRcdHN0YXRlLnRva2VuaXplID0gaW5CbG9jayhcIm1ldGFcIiwgXCI/PlwiKTtcblx0XHRcdFx0cmV0dXJuIFwibWV0YVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IHN0cmVhbS5lYXQoXCIvXCIpID8gXCJjbG9zZVRhZ1wiIDogXCJvcGVuVGFnXCI7XG5cdFx0XHRcdHN0cmVhbS5lYXRTcGFjZSgpO1xuXHRcdFx0XHR0YWdOYW1lID0gXCJcIjtcblx0XHRcdFx0dmFyIGM7XG5cdFx0XHRcdHdoaWxlICgoYyA9IHN0cmVhbS5lYXQoL1teXFxzXFx1MDBhMD08PlxcXCJcXCdcXC8/XS8pKSlcblx0XHRcdFx0XHR0YWdOYW1lICs9IGM7XG5cdFx0XHRcdHN0YXRlLnRva2VuaXplID0gaW5UYWc7XG5cdFx0XHRcdHJldHVybiBcInRhZ1wiO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY2ggPT0gXCImXCIpIHtcblx0XHRcdHZhciBvaztcblx0XHRcdGlmIChzdHJlYW0uZWF0KFwiI1wiKSkge1xuXHRcdFx0XHRpZiAoc3RyZWFtLmVhdChcInhcIikpIHtcblx0XHRcdFx0XHRvayA9IHN0cmVhbS5lYXRXaGlsZSgvW2EtZkEtRlxcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5cXC06XS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9rID8gXCJhdG9tXCIgOiBcImVycm9yXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0cmVhbS5lYXRXaGlsZSgvW14mPF0vKTtcblx0XHRcdHJldHVybiBcInRleHRcIjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XG5cdFx0dmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblx0XHRpZiAoY2ggPT0gXCI+XCIgfHwgKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSkge1xuXHRcdFx0c3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG5cdFx0XHR0eXBlID0gY2ggPT0gXCI+XCIgPyBcImVuZFRhZ1wiIDogXCJzZWxmY2xvc2VUYWdcIjtcblx0XHRcdHJldHVybiBcInRhZ1wiO1xuXHRcdH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIpIHtcblx0XHRcdHR5cGUgPSBcImVxdWFsc1wiO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIGlmICgvW1xcJ1xcXCJdLy50ZXN0KGNoKSkge1xuXHRcdFx0c3RhdGUudG9rZW5pemUgPSBpbkF0dHJpYnV0ZShjaCk7XG5cdFx0XHRyZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcLz9dLyk7XG5cdFx0XHRyZXR1cm4gXCJ3b3JkXCI7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5BdHRyaWJ1dGUocXVvdGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuXHRcdFx0d2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcblx0XHRcdFx0aWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcblx0XHRcdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGluVGFnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gXCJzdHJpbmdcIjtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5CbG9jayhzdHlsZSwgdGVybWluYXRvcikge1xuXHRcdHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG5cdFx0XHR3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuXHRcdFx0XHRpZiAoc3RyZWFtLm1hdGNoKHRlcm1pbmF0b3IpKSB7XG5cdFx0XHRcdFx0c3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHlsZTtcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBkb2N0eXBlKGRlcHRoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcblx0XHRcdHZhciBjaDtcblx0XHRcdHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjaCA9PSBcIjxcIikge1xuXHRcdFx0XHRcdHN0YXRlLnRva2VuaXplID0gZG9jdHlwZShkZXB0aCArIDEpO1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSBcIj5cIikge1xuXHRcdFx0XHRcdGlmIChkZXB0aCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcblx0XHRcdFx0XHRcdHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBcIm1ldGFcIjtcblx0XHR9O1xuXHR9XG5cblx0dmFyIGN1clN0YXRlID0gbnVsbCwgc2V0U3R5bGU7XG5cdGZ1bmN0aW9uIHBhc3MoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdGN1clN0YXRlLmNjLnB1c2goYXJndW1lbnRzW2ldKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY29udCgpIHtcblx0XHRwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoQ29udGV4dCh0YWdOYW1lLCBzdGFydE9mTGluZSkge1xuXHRcdHZhciBub0luZGVudCA9IEtsdWRnZXMuZG9Ob3RJbmRlbnQuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgXG5cdFx0XHR8fCAoY3VyU3RhdGUuY29udGV4dCAmJiBjdXJTdGF0ZS5jb250ZXh0Lm5vSW5kZW50KTtcblx0XHRjdXJTdGF0ZS5jb250ZXh0ID0ge1xuXHRcdFx0cHJldiA6IGN1clN0YXRlLmNvbnRleHQsXG5cdFx0XHR0YWdOYW1lIDogdGFnTmFtZSxcblx0XHRcdGluZGVudCA6IGN1clN0YXRlLmluZGVudGVkLFxuXHRcdFx0c3RhcnRPZkxpbmUgOiBzdGFydE9mTGluZSxcblx0XHRcdG5vSW5kZW50IDogbm9JbmRlbnRcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwb3BDb250ZXh0KCkge1xuXHRcdGlmIChjdXJTdGF0ZS5jb250ZXh0KVxuXHRcdFx0Y3VyU3RhdGUuY29udGV4dCA9IGN1clN0YXRlLmNvbnRleHQucHJldjtcblx0fVxuXG5cdGZ1bmN0aW9uIGVsZW1lbnQodHlwZSkge1xuXHRcdGlmICh0eXBlID09IFwib3BlblRhZ1wiKSB7XG5cdFx0XHRjdXJTdGF0ZS50YWdOYW1lID0gdGFnTmFtZTtcblx0XHRcdHJldHVybiBjb250KGF0dHJpYnV0ZXMsIGVuZHRhZyhjdXJTdGF0ZS5zdGFydE9mTGluZSkpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcImNsb3NlVGFnXCIpIHtcblx0XHRcdHZhciBlcnIgPSBmYWxzZTtcblx0XHRcdGlmIChjdXJTdGF0ZS5jb250ZXh0KSB7XG5cdFx0XHRcdGlmIChjdXJTdGF0ZS5jb250ZXh0LnRhZ05hbWUgIT0gdGFnTmFtZSkge1xuXHRcdFx0XHRcdGlmIChLbHVkZ2VzLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY3VyU3RhdGUuY29udGV4dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRwb3BDb250ZXh0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVyciA9ICFjdXJTdGF0ZS5jb250ZXh0IHx8IGN1clN0YXRlLmNvbnRleHQudGFnTmFtZSAhPSB0YWdOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlcnIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoZXJyKVxuXHRcdFx0XHRzZXRTdHlsZSA9IFwiZXJyb3JcIjtcblx0XHRcdHJldHVybiBjb250KGVuZGNsb3NldGFnKGVycikpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29udCgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBlbmR0YWcoc3RhcnRPZkxpbmUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0aWYgKHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIlxuXHRcdFx0XHRcdHx8ICh0eXBlID09IFwiZW5kVGFnXCIgJiYgS2x1ZGdlcy5hdXRvU2VsZkNsb3NlcnNcblx0XHRcdFx0XHRcdFx0Lmhhc093blByb3BlcnR5KGN1clN0YXRlLnRhZ05hbWVcblx0XHRcdFx0XHRcdFx0XHRcdC50b0xvd2VyQ2FzZSgpKSkpIHtcblx0XHRcdFx0bWF5YmVQb3BDb250ZXh0KGN1clN0YXRlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdHJldHVybiBjb250KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PSBcImVuZFRhZ1wiKSB7XG5cdFx0XHRcdG1heWJlUG9wQ29udGV4dChjdXJTdGF0ZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRwdXNoQ29udGV4dChjdXJTdGF0ZS50YWdOYW1lLCBzdGFydE9mTGluZSk7XG5cdFx0XHRcdHJldHVybiBjb250KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udCgpO1xuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGVuZGNsb3NldGFnKGVycikge1xuXHRcdHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRpZiAoZXJyKVxuXHRcdFx0XHRzZXRTdHlsZSA9IFwiZXJyb3JcIjtcblx0XHRcdGlmICh0eXBlID09IFwiZW5kVGFnXCIpIHtcblx0XHRcdFx0cG9wQ29udGV4dCgpO1xuXHRcdFx0XHRyZXR1cm4gY29udCgpO1xuXHRcdFx0fVxuXHRcdFx0c2V0U3R5bGUgPSBcImVycm9yXCI7XG5cdFx0XHRyZXR1cm4gY29udChhcmd1bWVudHMuY2FsbGVlKTtcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBtYXliZVBvcENvbnRleHQobmV4dFRhZ05hbWUpIHtcblx0XHR2YXIgcGFyZW50VGFnTmFtZTtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKCFjdXJTdGF0ZS5jb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBhcmVudFRhZ05hbWUgPSBjdXJTdGF0ZS5jb250ZXh0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICghS2x1ZGdlcy5jb250ZXh0R3JhYmJlcnMuaGFzT3duUHJvcGVydHkocGFyZW50VGFnTmFtZSlcblx0XHRcdFx0XHR8fCAhS2x1ZGdlcy5jb250ZXh0R3JhYmJlcnNbcGFyZW50VGFnTmFtZV0uaGFzT3duUHJvcGVydHkobmV4dFRhZ05hbWUpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBvcENvbnRleHQoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhdHRyaWJ1dGVzKHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PSBcIndvcmRcIikge1xuXHRcdFx0c2V0U3R5bGUgPSBcImF0dHJpYnV0ZVwiO1xuXHRcdFx0cmV0dXJuIGNvbnQoYXR0cmlidXRlLCBhdHRyaWJ1dGVzKTtcblx0XHR9XG5cdFx0aWYgKHR5cGUgPT0gXCJlbmRUYWdcIiB8fCB0eXBlID09IFwic2VsZmNsb3NlVGFnXCIpXG5cdFx0XHRyZXR1cm4gcGFzcygpO1xuXHRcdHNldFN0eWxlID0gXCJlcnJvclwiO1xuXHRcdHJldHVybiBjb250KGF0dHJpYnV0ZXMpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhdHRyaWJ1dGUodHlwZSkge1xuXHRcdGlmICh0eXBlID09IFwiZXF1YWxzXCIpXG5cdFx0XHRyZXR1cm4gY29udChhdHR2YWx1ZSwgYXR0cmlidXRlcyk7XG5cdFx0aWYgKCFLbHVkZ2VzLmFsbG93TWlzc2luZylcblx0XHRcdHNldFN0eWxlID0gXCJlcnJvclwiO1xuXHRcdHJldHVybiAodHlwZSA9PSBcImVuZFRhZ1wiIHx8IHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIikgPyBwYXNzKClcblx0XHRcdFx0OiBjb250KCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGF0dHZhbHVlKHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PSBcInN0cmluZ1wiKVxuXHRcdFx0cmV0dXJuIGNvbnQoYXR0dmFsdWVtYXliZSk7XG5cdFx0aWYgKHR5cGUgPT0gXCJ3b3JkXCIgJiYgS2x1ZGdlcy5hbGxvd1VucXVvdGVkKSB7XG5cdFx0XHRzZXRTdHlsZSA9IFwic3RyaW5nXCI7XG5cdFx0XHRyZXR1cm4gY29udCgpO1xuXHRcdH1cblx0XHRzZXRTdHlsZSA9IFwiZXJyb3JcIjtcblx0XHRyZXR1cm4gKHR5cGUgPT0gXCJlbmRUYWdcIiB8fCB0eXBlID09IFwic2VsZkNsb3NlVGFnXCIpID8gcGFzcygpXG5cdFx0XHRcdDogY29udCgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhdHR2YWx1ZW1heWJlKHR5cGUpIHtcblx0XHRpZiAodHlwZSA9PSBcInN0cmluZ1wiKVxuXHRcdFx0cmV0dXJuIGNvbnQoYXR0dmFsdWVtYXliZSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHBhc3MoKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gc3RhcnRTdGF0ZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9rZW5pemUgOiBpblRleHQsXG5cdFx0XHRjYyA6IFtdLFxuXHRcdFx0aW5kZW50ZWQgOiAwLFxuXHRcdFx0c3RhcnRPZkxpbmUgOiB0cnVlLFxuXHRcdFx0dGFnTmFtZSA6IG51bGwsXG5cdFx0XHRjb250ZXh0IDogbnVsbFxuXHRcdH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHRva2VuKHN0cmVhbSwgc3RhdGUpIHtcblx0XHRpZiAoc3RyZWFtLnNvbCgpKSB7XG5cdFx0XHRzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG5cdFx0XHRzdGF0ZS5pbmRlbnRlZCA9IDA7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0c2V0U3R5bGUgPSB0eXBlID0gdGFnTmFtZSA9IG51bGw7XG5cdFx0dmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG5cdFx0c3RhdGUudHlwZSA9IHR5cGU7XG5cdFx0aWYgKChzdHlsZSB8fCB0eXBlKSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuXHRcdFx0Y3VyU3RhdGUgPSBzdGF0ZTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHZhciBjb21iID0gc3RhdGUuY2MucG9wKCkgfHwgZWxlbWVudDtcblx0XHRcdFx0aWYgKGNvbWIodHlwZSB8fCBzdHlsZSkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG5cdFx0cmV0dXJuIHNldFN0eWxlIHx8IHN0eWxlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQueG1sUGFyc2VyXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRwYXJzZTogZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KSB7XG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRcdHZhciBzdGF0ZSA9IHN0YXJ0U3RhdGUoKTtcblx0XHRcdHZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJpbmdTdHJlYW0nKS5jcmVhdGUoZGF0YSk7XG5cdFx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0XHR3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dHlwZTogdG9rZW4oc3RyZWFtLCBzdGF0ZSksXG5cdFx0XHRcdFx0c3RhcnQ6IHN0cmVhbS5zdGFydCArIG9mZnNldCxcblx0XHRcdFx0XHRlbmQ6IHN0cmVhbS5wb3MgKyBvZmZzZXRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fVx0XHRcblx0fTtcbn0pO1xuLyohXG4gKiBzdHJpbmdfc2NvcmUuanM6IFN0cmluZyBTY29yaW5nIEFsZ29yaXRobSAwLjEuMTAgXG4gKlxuICogaHR0cDovL2pvc2hhdmVuLmNvbS9zdHJpbmdfc2NvcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NoYXZlbi9zdHJpbmdfc2NvcmVcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDktMjAxMSBKb3NoYXZlbiBQb3R0ZXIgPHlvdXJ0ZWNoQGdtYWlsLmNvbT5cbiAqIFNwZWNpYWwgdGhhbmtzIHRvIGFsbCBvZiB0aGUgY29udHJpYnV0b3JzIGxpc3RlZCBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NoYXZlbi9zdHJpbmdfc2NvcmVcbiAqIE1JVCBsaWNlbnNlOiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIERhdGU6IFR1ZSBNYXIgMSAyMDExXG4qL1xuXG4vKipcbiAqIFNjb3JlcyBhIHN0cmluZyBhZ2FpbnN0IGFub3RoZXIgc3RyaW5nLlxuICogICdIZWxsbyBXb3JsZCcuc2NvcmUoJ2hlJyk7ICAgICAvLz0+IDAuNTkzMTgxODE4MTgxODE4MVxuICogICdIZWxsbyBXb3JsZCcuc2NvcmUoJ0hlbGxvJyk7ICAvLz0+IDAuNzMxODE4MTgxODE4MTgxOFxuICovXG5lbW1ldC5kZWZpbmUoJ3N0cmluZy1zY29yZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0cmV0dXJuIHtcblx0XHRzY29yZTogZnVuY3Rpb24oc3RyaW5nLCBhYmJyZXZpYXRpb24sIGZ1enppbmVzcykge1xuXHRcdFx0Ly8gSWYgdGhlIHN0cmluZyBpcyBlcXVhbCB0byB0aGUgYWJicmV2aWF0aW9uLCBwZXJmZWN0IG1hdGNoLlxuXHRcdFx0ICBpZiAoc3RyaW5nID09IGFiYnJldmlhdGlvbikge3JldHVybiAxO31cblx0XHRcdCAgLy9pZiBpdCdzIG5vdCBhIHBlcmZlY3QgbWF0Y2ggYW5kIGlzIGVtcHR5IHJldHVybiAwXG5cdFx0XHQgIGlmKGFiYnJldmlhdGlvbiA9PSBcIlwiKSB7cmV0dXJuIDA7fVxuXG5cdFx0XHQgIHZhciB0b3RhbF9jaGFyYWN0ZXJfc2NvcmUgPSAwLFxuXHRcdFx0ICAgICAgYWJicmV2aWF0aW9uX2xlbmd0aCA9IGFiYnJldmlhdGlvbi5sZW5ndGgsXG5cdFx0XHQgICAgICBzdHJpbmdfbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHRcdCAgICAgIHN0YXJ0X29mX3N0cmluZ19ib251cyxcblx0XHRcdCAgICAgIGFiYnJldmlhdGlvbl9zY29yZSxcblx0XHRcdCAgICAgIGZ1enppZXM9MSxcblx0XHRcdCAgICAgIGZpbmFsX3Njb3JlO1xuXHRcdFx0ICBcblx0XHRcdCAgLy8gV2FsayB0aHJvdWdoIGFiYnJldmlhdGlvbiBhbmQgYWRkIHVwIHNjb3Jlcy5cblx0XHRcdCAgZm9yICh2YXIgaSA9IDAsXG5cdFx0XHQgICAgICAgICBjaGFyYWN0ZXJfc2NvcmUvKiA9IDAqLyxcblx0XHRcdCAgICAgICAgIGluZGV4X2luX3N0cmluZy8qID0gMCovLFxuXHRcdFx0ICAgICAgICAgYy8qID0gJycqLyxcblx0XHRcdCAgICAgICAgIGluZGV4X2NfbG93ZXJjYXNlLyogPSAwKi8sXG5cdFx0XHQgICAgICAgICBpbmRleF9jX3VwcGVyY2FzZS8qID0gMCovLFxuXHRcdFx0ICAgICAgICAgbWluX2luZGV4LyogPSAwKi87XG5cdFx0XHQgICAgIGkgPCBhYmJyZXZpYXRpb25fbGVuZ3RoO1xuXHRcdFx0ICAgICArK2kpIHtcblx0XHRcdCAgICBcblx0XHRcdCAgICAvLyBGaW5kIHRoZSBmaXJzdCBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIG9mIGEgY2hhcmFjdGVyLlxuXHRcdFx0ICAgIGMgPSBhYmJyZXZpYXRpb24uY2hhckF0KGkpO1xuXHRcdFx0ICAgIFxuXHRcdFx0ICAgIGluZGV4X2NfbG93ZXJjYXNlID0gc3RyaW5nLmluZGV4T2YoYy50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdCAgICBpbmRleF9jX3VwcGVyY2FzZSA9IHN0cmluZy5pbmRleE9mKGMudG9VcHBlckNhc2UoKSk7XG5cdFx0XHQgICAgbWluX2luZGV4ID0gTWF0aC5taW4oaW5kZXhfY19sb3dlcmNhc2UsIGluZGV4X2NfdXBwZXJjYXNlKTtcblx0XHRcdCAgICBpbmRleF9pbl9zdHJpbmcgPSAobWluX2luZGV4ID4gLTEpID8gbWluX2luZGV4IDogTWF0aC5tYXgoaW5kZXhfY19sb3dlcmNhc2UsIGluZGV4X2NfdXBwZXJjYXNlKTtcblx0XHRcdCAgICBcblx0XHRcdCAgICBpZiAoaW5kZXhfaW5fc3RyaW5nID09PSAtMSkgeyBcblx0XHRcdCAgICAgIGlmIChmdXp6aW5lc3MpIHtcblx0XHRcdCAgICAgICAgZnV6emllcyArPSAxLWZ1enppbmVzcztcblx0XHRcdCAgICAgICAgY29udGludWU7XG5cdFx0XHQgICAgICB9IGVsc2Uge1xuXHRcdFx0ICAgICAgICByZXR1cm4gMDtcblx0XHRcdCAgICAgIH1cblx0XHRcdCAgICB9IGVsc2Uge1xuXHRcdFx0ICAgICAgY2hhcmFjdGVyX3Njb3JlID0gMC4xO1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBcblx0XHRcdCAgICAvLyBTZXQgYmFzZSBzY29yZSBmb3IgbWF0Y2hpbmcgJ2MnLlxuXHRcdFx0ICAgIFxuXHRcdFx0ICAgIC8vIFNhbWUgY2FzZSBib251cy5cblx0XHRcdCAgICBpZiAoc3RyaW5nW2luZGV4X2luX3N0cmluZ10gPT09IGMpIHsgXG5cdFx0XHQgICAgICBjaGFyYWN0ZXJfc2NvcmUgKz0gMC4xOyBcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgXG5cdFx0XHQgICAgLy8gQ29uc2VjdXRpdmUgbGV0dGVyICYgc3RhcnQtb2Ytc3RyaW5nIEJvbnVzXG5cdFx0XHQgICAgaWYgKGluZGV4X2luX3N0cmluZyA9PT0gMCkge1xuXHRcdFx0ICAgICAgLy8gSW5jcmVhc2UgdGhlIHNjb3JlIHdoZW4gbWF0Y2hpbmcgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIHN0cmluZ1xuXHRcdFx0ICAgICAgY2hhcmFjdGVyX3Njb3JlICs9IDAuNjtcblx0XHRcdCAgICAgIGlmIChpID09PSAwKSB7XG5cdFx0XHQgICAgICAgIC8vIElmIG1hdGNoIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZ1xuXHRcdFx0ICAgICAgICAvLyAmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYWJicmV2aWF0aW9uLCBhZGQgYVxuXHRcdFx0ICAgICAgICAvLyBzdGFydC1vZi1zdHJpbmcgbWF0Y2ggYm9udXMuXG5cdFx0XHQgICAgICAgIHN0YXJ0X29mX3N0cmluZ19ib251cyA9IDE7IC8vdHJ1ZTtcblx0XHRcdCAgICAgIH1cblx0XHRcdCAgICB9XG5cdFx0XHQgICAgZWxzZSB7XG5cdFx0XHQgIC8vIEFjcm9ueW0gQm9udXNcblx0XHRcdCAgLy8gV2VpZ2hpbmcgTG9naWM6IFR5cGluZyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGFuIGFjcm9ueW0gaXMgYXMgaWYgeW91XG5cdFx0XHQgIC8vIHByZWNlZGVkIGl0IHdpdGggdHdvIHBlcmZlY3QgY2hhcmFjdGVyIG1hdGNoZXMuXG5cdFx0XHQgIGlmIChzdHJpbmcuY2hhckF0KGluZGV4X2luX3N0cmluZyAtIDEpID09PSAnICcpIHtcblx0XHRcdCAgICBjaGFyYWN0ZXJfc2NvcmUgKz0gMC44OyAvLyAqIE1hdGgubWluKGluZGV4X2luX3N0cmluZywgNSk7IC8vIENhcCBib251cyBhdCAwLjQgKiA1XG5cdFx0XHQgIH1cblx0XHRcdCAgICB9XG5cdFx0XHQgICAgXG5cdFx0XHQgICAgLy8gTGVmdCB0cmltIHRoZSBhbHJlYWR5IG1hdGNoZWQgcGFydCBvZiB0aGUgc3RyaW5nXG5cdFx0XHQgICAgLy8gKGZvcmNlcyBzZXF1ZW50aWFsIG1hdGNoaW5nKS5cblx0XHRcdCAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKGluZGV4X2luX3N0cmluZyArIDEsIHN0cmluZ19sZW5ndGgpO1xuXHRcdFx0ICAgIFxuXHRcdFx0ICAgIHRvdGFsX2NoYXJhY3Rlcl9zY29yZSArPSBjaGFyYWN0ZXJfc2NvcmU7XG5cdFx0XHQgIH0gLy8gZW5kIG9mIGZvciBsb29wXG5cdFx0XHQgIFxuXHRcdFx0ICAvLyBVbmNvbW1lbnQgdG8gd2VpZ2ggc21hbGxlciB3b3JkcyBoaWdoZXIuXG5cdFx0XHQgIC8vIHJldHVybiB0b3RhbF9jaGFyYWN0ZXJfc2NvcmUgLyBzdHJpbmdfbGVuZ3RoO1xuXHRcdFx0ICBcblx0XHRcdCAgYWJicmV2aWF0aW9uX3Njb3JlID0gdG90YWxfY2hhcmFjdGVyX3Njb3JlIC8gYWJicmV2aWF0aW9uX2xlbmd0aDtcblx0XHRcdCAgLy9wZXJjZW50YWdlX29mX21hdGNoZWRfc3RyaW5nID0gYWJicmV2aWF0aW9uX2xlbmd0aCAvIHN0cmluZ19sZW5ndGg7XG5cdFx0XHQgIC8vd29yZF9zY29yZSA9IGFiYnJldmlhdGlvbl9zY29yZSAqIHBlcmNlbnRhZ2Vfb2ZfbWF0Y2hlZF9zdHJpbmc7XG5cdFx0XHQgIFxuXHRcdFx0ICAvLyBSZWR1Y2UgcGVuYWx0eSBmb3IgbG9uZ2VyIHN0cmluZ3MuXG5cdFx0XHQgIC8vZmluYWxfc2NvcmUgPSAod29yZF9zY29yZSArIGFiYnJldmlhdGlvbl9zY29yZSkgLyAyO1xuXHRcdFx0ICBmaW5hbF9zY29yZSA9ICgoYWJicmV2aWF0aW9uX3Njb3JlICogKGFiYnJldmlhdGlvbl9sZW5ndGggLyBzdHJpbmdfbGVuZ3RoKSkgKyBhYmJyZXZpYXRpb25fc2NvcmUpIC8gMjtcblx0XHRcdCAgXG5cdFx0XHQgIGZpbmFsX3Njb3JlID0gZmluYWxfc2NvcmUgLyBmdXp6aWVzO1xuXHRcdFx0ICBcblx0XHRcdCAgaWYgKHN0YXJ0X29mX3N0cmluZ19ib251cyAmJiAoZmluYWxfc2NvcmUgKyAwLjE1IDwgMSkpIHtcblx0XHRcdCAgICBmaW5hbF9zY29yZSArPSAwLjE1O1xuXHRcdFx0ICB9XG5cdFx0XHQgIFxuXHRcdFx0ICByZXR1cm4gZmluYWxfc2NvcmU7XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBVdGlsaXR5IG1vZHVsZSBmb3IgRW1tZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5kZWZpbmUoJ3V0aWxzJywgZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKiogXG5cdCAqIFNwZWNpYWwgdG9rZW4gdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBjYXJldCBwb3NpdGlvbnMgaW5zaWRlIFxuXHQgKiBnZW5lcmF0ZWQgb3V0cHV0IFxuXHQgKi9cblx0dmFyIGNhcmV0UGxhY2Vob2xkZXIgPSAnJHswfSc7XG5cdFxuXHQvKipcblx0ICogQSBzaW1wbGUgc3RyaW5nIGJ1aWxkZXIsIG9wdGltaXplZCBmb3IgZmFzdGVyIHRleHQgY29uY2F0ZW5hdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgSW5pdGlhbCB2YWx1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gU3RyaW5nQnVpbGRlcih2YWx1ZSkge1xuXHRcdHRoaXMuX2RhdGEgPSBbXTtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdFx0XG5cdFx0aWYgKHZhbHVlKVxuXHRcdFx0dGhpcy5hcHBlbmQodmFsdWUpO1xuXHR9XG5cdFxuXHRTdHJpbmdCdWlsZGVyLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBBcHBlbmQgc3RyaW5nXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKi9cblx0XHRhcHBlbmQ6IGZ1bmN0aW9uKHRleHQpIHtcblx0XHRcdHRoaXMuX2RhdGEucHVzaCh0ZXh0KTtcblx0XHRcdHRoaXMubGVuZ3RoICs9IHRleHQubGVuZ3RoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGF0YS5qb2luKCcnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dmFsdWVPZjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xuXHRcdH1cblx0fTtcblx0XG5cdHJldHVybiB7XG5cdFx0LyoqIEBtZW1iZXJPZiB1dGlscyAqL1xuXHRcdHJlVGFnOiAvPFxcLz9bXFx3OlxcLV0rKD86XFxzK1tcXHdcXC06XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKykpPykqXFxzKihcXC8/KT4kLyxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUZXN0IGlmIHBhc3NlZCBzdHJpbmcgZW5kcyB3aXRoIFhIVE1MIHRhZy4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgdGVzdGluZ1xuXHRcdCAqICc+JyBjaGFyYWN0ZXI6IGl0IGJlbG9uZ3MgdG8gdGFnIG9yIGl0J3MgYSBwYXJ0IG9mIGFiYnJldmlhdGlvbj8gXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZW5kc1dpdGhUYWc6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVUYWcudGVzdChzdHIpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgcGFzc2VkIHN5bWJvbCBpcyBhIG51bWJlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjaFxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzTnVtZXJpYzogZnVuY3Rpb24oY2gpIHtcblx0XHRcdGlmICh0eXBlb2YoY2gpID09ICdzdHJpbmcnKVxuXHRcdFx0XHRjaCA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIChjaCAmJiBjaCA+IDQ3ICYmIGNoIDwgNTgpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVHJpbSB3aGl0ZXNwYWNlIGZyb20gc3RyaW5nXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dHJpbTogZnVuY3Rpb24odGV4dCkge1xuXHRcdFx0cmV0dXJuICh0ZXh0IHx8IFwiXCIpLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBuZXdsaW5lIGNoYXJhY3RlclxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0TmV3bGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gcmVxdWlyZSgncmVzb3VyY2VzJyk7XG5cdFx0XHRpZiAoIXJlcykge1xuXHRcdFx0XHRyZXR1cm4gJ1xcbic7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBubCA9IHJlcy5nZXRWYXJpYWJsZSgnbmV3bGluZScpO1xuXHRcdFx0cmV0dXJuIF8uaXNTdHJpbmcobmwpID8gbmwgOiAnXFxuJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgbmV3IG5ld2xpbmUgY2hhcmFjdGVyIHRoYXQgd2lsbCBiZSB1c2VkIGluIG91dHB1dFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKi9cblx0XHRzZXROZXdsaW5lOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHZhciByZXMgPSByZXF1aXJlKCdyZXNvdXJjZXMnKTtcblx0XHRcdHJlcy5zZXRWYXJpYWJsZSgnbmV3bGluZScsIHN0cik7XG5cdFx0XHRyZXMuc2V0VmFyaWFibGUoJ25sJywgc3RyKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNwbGl0IHRleHQgaW50byBsaW5lcy4gU2V0IDxjb2RlPnJlbW92ZV9lbXB0eTwvY29kZT4gdG8gdHJ1ZSB0byBmaWx0ZXJcblx0XHQgKiBlbXB0eSBsaW5lc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgdG8gc3BsaXRcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZUVtcHR5IFJlbW92ZSBlbXB0eSBsaW5lcyBmcm9tIHJlc3VsdFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHRcdHNwbGl0QnlMaW5lczogZnVuY3Rpb24odGV4dCwgcmVtb3ZlRW1wdHkpIHtcblx0XHRcdC8vIElFIGZhaWxzIHRvIHNwbGl0IHN0cmluZyBieSByZWdleHAsIFxuXHRcdFx0Ly8gbmVlZCB0byBub3JtYWxpemUgbmV3bGluZXMgZmlyc3Rcblx0XHRcdC8vIEFsc28sIE1vemlsbGEncyBSaGlobyBKUyBlbmdpbmUgaGFzIGEgd2VpcmQgbmV3bGluZSBidWdcblx0XHRcdHZhciBubCA9IHRoaXMuZ2V0TmV3bGluZSgpO1xuXHRcdFx0dmFyIGxpbmVzID0gKHRleHQgfHwgJycpXG5cdFx0XHRcdC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpXG5cdFx0XHRcdC5yZXBsYWNlKC9cXG5cXHIvZywgJ1xcbicpXG5cdFx0XHRcdC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpXG5cdFx0XHRcdC5yZXBsYWNlKC9cXG4vZywgbmwpXG5cdFx0XHRcdC5zcGxpdChubCk7XG5cdFx0XHRcblx0XHRcdGlmIChyZW1vdmVFbXB0eSkge1xuXHRcdFx0XHRsaW5lcyA9IF8uZmlsdGVyKGxpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUubGVuZ3RoICYmICEhdGhpcy50cmltKGxpbmUpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxpbmVzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplcyBuZXdsaW5lIGNoYXJhY3RlcjogcmVwbGFjZXMgbmV3bGluZXMgaW4gPGNvZGU+dGV4dDwvY29kZT4gXG5cdFx0ICogd2l0aCBuZXdsaW5lIGRlZmluZWQgaW4gcHJlZmVyZW5jZXNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0bm9ybWFsaXplTmV3bGluZTogZnVuY3Rpb24odGV4dCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3BsaXRCeUxpbmVzKHRleHQpLmpvaW4odGhpcy5nZXROZXdsaW5lKCkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwZWF0cyBzdHJpbmcgPGNvZGU+aG93TWFueTwvY29kZT4gdGltZXNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhvd19tYW55XG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHJlcGVhdFN0cmluZzogZnVuY3Rpb24oc3RyLCBob3dNYW55KSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSBcblx0XHRcdFx0cmVzdWx0LnB1c2goc3RyKTtcblx0XHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBsaXN0IG9mIHBhZGRpbmdzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gYWxpZ24gcGFzc2VkIHN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHN0cmluZ3Ncblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0U3RyaW5nc1BhZHM6IGZ1bmN0aW9uKHN0cmluZ3MpIHtcblx0XHRcdHZhciBsZW5ndGhzID0gXy5tYXAoc3RyaW5ncywgZnVuY3Rpb24ocykge1xuXHRcdFx0XHRyZXR1cm4gXy5pc1N0cmluZyhzKSA/IHMubGVuZ3RoIDogK3M7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dmFyIG1heCA9IF8ubWF4KGxlbmd0aHMpO1xuXHRcdFx0cmV0dXJuIF8ubWFwKGxlbmd0aHMsIGZ1bmN0aW9uKGwpIHtcblx0XHRcdFx0dmFyIHBhZCA9IG1heCAtIGw7XG5cdFx0XHRcdHJldHVybiBwYWQgPyB0aGlzLnJlcGVhdFN0cmluZygnICcsIHBhZCkgOiAnJztcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZW50cyB0ZXh0IHdpdGggcGFkZGluZ1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgdG8gaW5kZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhZCBQYWRkaW5nIHNpemUgKG51bWJlcikgb3IgcGFkZGluZyBpdHNlbGYgKHN0cmluZylcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cGFkU3RyaW5nOiBmdW5jdGlvbih0ZXh0LCBwYWQpIHtcblx0XHRcdHZhciBwYWRTdHIgPSAoXy5pc051bWJlcihwYWQpKSBcblx0XHRcdFx0PyB0aGlzLnJlcGVhdFN0cmluZyhyZXF1aXJlKCdyZXNvdXJjZXMnKS5nZXRWYXJpYWJsZSgnaW5kZW50YXRpb24nKSB8fCAnXFx0JywgcGFkKSBcblx0XHRcdFx0OiBwYWQ7XG5cdFx0XHRcdFxuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0XG5cdFx0XHR2YXIgbGluZXMgPSB0aGlzLnNwbGl0QnlMaW5lcyh0ZXh0KTtcblx0XHRcdHZhciBubCA9IHRoaXMuZ2V0TmV3bGluZSgpO1xuXHRcdFx0XHRcblx0XHRcdHJlc3VsdC5wdXNoKGxpbmVzWzBdKTtcblx0XHRcdGZvciAodmFyIGogPSAxOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIFxuXHRcdFx0XHRyZXN1bHQucHVzaChubCArIHBhZFN0ciArIGxpbmVzW2pdKTtcblx0XHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGFkIHN0cmluZyB3aXRoIHplcm9lc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHBhZFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWQgRGVzaXJlZCBzdHJpbmcgbGVuZ3RoXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHplcm9QYWRTdHJpbmc6IGZ1bmN0aW9uKHN0ciwgcGFkKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9ICcnO1xuXHRcdFx0dmFyIGlsID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHR3aGlsZSAocGFkID4gaWwrKykgcGFkZGluZyArPSAnMCc7XG5cdFx0XHRyZXR1cm4gcGFkZGluZyArIHN0cjsgXG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHBhZGRpbmcgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIHRleHQncyBsaW5lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFkXG5cdFx0ICovXG5cdFx0dW5pbmRlbnRTdHJpbmc6IGZ1bmN0aW9uKHRleHQsIHBhZCkge1xuXHRcdFx0dmFyIGxpbmVzID0gdGhpcy5zcGxpdEJ5TGluZXModGV4dCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChsaW5lc1tpXS5zZWFyY2gocGFkKSA9PSAwKVxuXHRcdFx0XHRcdGxpbmVzW2ldID0gbGluZXNbaV0uc3Vic3RyKHBhZC5sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGluZXMuam9pbih0aGlzLmdldE5ld2xpbmUoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlcyB1bmVzY2FwZWQgc3ltYm9scyBpbiA8Y29kZT5zdHI8L2NvZGU+LiBGb3IgZXhhbXBsZSwgdGhlICckJyBzeW1ib2xcblx0XHQgKiB3aWxsIGJlIHJlcGxhY2VkIGluICdpdGVtJGNvdW50JywgYnV0IG5vdCBpbiAnaXRlbVxcJGNvdW50Jy5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE9yaWdpbmFsIHN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgU3ltYm9sIHRvIHJlcGxhY2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcmVwbGFjZSBTeW1ib2wgcmVwbGFjZW1lbnQuIE1pZ2h0IGJlIGEgZnVuY3Rpb24gdGhhdCBcblx0XHQgKiByZXR1cm5zIG5ldyB2YWx1ZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRyZXBsYWNlVW5lc2NhcGVkU3ltYm9sOiBmdW5jdGlvbihzdHIsIHN5bWJvbCwgcmVwbGFjZSkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0dmFyIGlsID0gc3RyLmxlbmd0aDtcblx0XHRcdHZhciBzbCA9IHN5bWJvbC5sZW5ndGg7XG5cdFx0XHR2YXIgbWF0Y2hDb3VudCA9IDA7XG5cdFx0XHRcdFxuXHRcdFx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdFx0XHRpZiAoc3RyLmNoYXJBdChpKSA9PSAnXFxcXCcpIHtcblx0XHRcdFx0XHQvLyBlc2NhcGVkIHN5bWJvbCwgc2tpcCBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRcdGkgKz0gc2wgKyAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0ci5zdWJzdHIoaSwgc2wpID09IHN5bWJvbCkge1xuXHRcdFx0XHRcdC8vIGhhdmUgbWF0Y2hcblx0XHRcdFx0XHR2YXIgY3VyU2wgPSBzbDtcblx0XHRcdFx0XHRtYXRjaENvdW50Kys7XG5cdFx0XHRcdFx0dmFyIG5ld1ZhbHVlID0gcmVwbGFjZTtcblx0XHRcdFx0XHRpZiAoXy5pc0Z1bmN0aW9uKHJlcGxhY2UpKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVwbGFjZURhdGEgPSByZXBsYWNlKHN0ciwgc3ltYm9sLCBpLCBtYXRjaENvdW50KTtcblx0XHRcdFx0XHRcdGlmIChyZXBsYWNlRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRjdXJTbCA9IHJlcGxhY2VEYXRhWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bmV3VmFsdWUgPSByZXBsYWNlRGF0YVsxXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ld1ZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChuZXdWYWx1ZSA9PT0gZmFsc2UpIHsgLy8gc2tpcCByZXBsYWNlbWVudFxuXHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSkgKyBuZXdWYWx1ZSArIHN0ci5zdWJzdHJpbmcoaSArIGN1clNsKTtcblx0XHRcdFx0XHQvLyBhZGp1c3QgaW5kZXhlc1xuXHRcdFx0XHRcdGlsID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XHRpICs9IG5ld1ZhbHVlLmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2UgdmFyaWFibGVzIGxpa2UgJHt2YXJ9IGluIHN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdmFycyBWYXJpYWJsZSBzZXQgKGRlZmF1bHRzIHRvIHZhcmlhYmxlcyBkZWZpbmVkIGluIFxuXHRcdCAqIDxjb2RlPnNuaXBwZXRzLmpzb248L2NvZGU+KSBvciB2YXJpYWJsZSByZXNvbHZlciAoPGNvZGU+RnVuY3Rpb248L2NvZGU+KVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRyZXBsYWNlVmFyaWFibGVzOiBmdW5jdGlvbihzdHIsIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHJlc29sdmVyID0gXy5pc0Z1bmN0aW9uKHZhcnMpID8gdmFycyA6IGZ1bmN0aW9uKHN0ciwgcDEpIHtcblx0XHRcdFx0cmV0dXJuIHAxIGluIHZhcnMgPyB2YXJzW3AxXSA6IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVzID0gcmVxdWlyZSgncmVzb3VyY2VzJyk7XG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgndGFiU3RvcHMnKS5wcm9jZXNzVGV4dChzdHIsIHtcblx0XHRcdFx0dmFyaWFibGU6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHR2YXIgbmV3VmFsdWUgPSByZXNvbHZlcihkYXRhLnRva2VuLCBkYXRhLm5hbWUsIGRhdGEpO1xuXHRcdFx0XHRcdGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0Ly8gdHJ5IHRvIGZpbmQgdmFyaWFibGUgaW4gcmVzb3VyY2VzXG5cdFx0XHRcdFx0XHRuZXdWYWx1ZSA9IHJlcy5nZXRWYXJpYWJsZShkYXRhLm5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobmV3VmFsdWUgPT09IG51bGwgfHwgXy5pc1VuZGVmaW5lZChuZXdWYWx1ZSkpXG5cdFx0XHRcdFx0XHQvLyBub3RoaW5nIGZvdW5kLCByZXR1cm4gdG9rZW4gaXRzZWxmXG5cdFx0XHRcdFx0XHRuZXdWYWx1ZSA9IGRhdGEudG9rZW47XG5cdFx0XHRcdFx0cmV0dXJuIG5ld1ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzICckJyBjaGFyYWN0ZXIgaW4gc3RyaW5nIGFzc3VtaW5nIGl0IG1pZ2h0IGJlIGVzY2FwZWQgd2l0aCAnXFwnXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgd2hlcmUgY2hhcmFjdGVyIHNob3VsZCBiZSByZXBsYWNlZFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBOZXcgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVwbGFjZUNvdW50ZXI6IGZ1bmN0aW9uKHN0ciwgdmFsdWUsIHRvdGFsKSB7XG5cdFx0XHR2YXIgc3ltYm9sID0gJyQnO1xuXHRcdFx0Ly8gaW4gY2FzZSB3ZSByZWNlaXZlZCBzdHJpbmdzIGZyb20gSmF2YSwgY29udmVydCB0aGUgdG8gbmF0aXZlIHN0cmluZ3Ncblx0XHRcdHN0ciA9IFN0cmluZyhzdHIpO1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoL15cXC0/XFxkKyQvLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gK3ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnJlcGxhY2VVbmVzY2FwZWRTeW1ib2woc3RyLCBzeW1ib2wsIGZ1bmN0aW9uKHN0ciwgc3ltYm9sLCBwb3MsIG1hdGNoTnVtKXtcblx0XHRcdFx0aWYgKHN0ci5jaGFyQXQocG9zICsgMSkgPT0gJ3snIHx8IHRoYXQuaXNOdW1lcmljKHN0ci5jaGFyQXQocG9zICsgMSkpICkge1xuXHRcdFx0XHRcdC8vIGl0J3MgYSB2YXJpYWJsZSwgc2tpcCBpdFxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gcmVwbGFjZSBzZXF1ZW5zZSBvZiAkIHN5bWJvbHMgd2l0aCBwYWRkZWQgbnVtYmVyICBcblx0XHRcdFx0dmFyIGogPSBwb3MgKyAxO1xuXHRcdFx0XHR3aGlsZShzdHIuY2hhckF0KGopID09ICckJyAmJiBzdHIuY2hhckF0KGogKyAxKSAhPSAneycpIGorKztcblx0XHRcdFx0dmFyIHBhZCA9IGogLSBwb3M7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBnZXQgY291bnRlciBiYXNlXG5cdFx0XHRcdHZhciBiYXNlID0gMCwgZGVjcmVtZW50ID0gZmFsc2UsIG07XG5cdFx0XHRcdGlmIChtID0gc3RyLnN1YnN0cihqKS5tYXRjaCgvXkAoXFwtPykoXFxkKikvKSkge1xuXHRcdFx0XHRcdGogKz0gbVswXS5sZW5ndGg7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1bMV0pIHtcblx0XHRcdFx0XHRcdGRlY3JlbWVudCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGJhc2UgPSBwYXJzZUludChtWzJdIHx8IDEpIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGRlY3JlbWVudCAmJiB0b3RhbCAmJiBfLmlzTnVtYmVyKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gdG90YWwgLSB2YWx1ZSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHZhbHVlICs9IGJhc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gW3N0ci5zdWJzdHJpbmcocG9zLCBqKSwgdGhhdC56ZXJvUGFkU3RyaW5nKHZhbHVlICsgJycsIHBhZCldO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBzdHJpbmcgbWF0Y2hlcyBhZ2FpbnN0IDxjb2RlPnJlVGFnPC9jb2RlPiByZWdleHAuIFRoaXMgXG5cdFx0ICogZnVuY3Rpb24gbWF5IGJlIHVzZWQgdG8gdGVzdCBpZiBwcm92aWRlZCBzdHJpbmcgY29udGFpbnMgSFRNTCB0YWdzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdG1hdGNoZXNUYWc6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVUYWcudGVzdChzdHIgfHwgJycpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgdXNlZCBpbiBFbW1ldCwgbGlrZSAnJCcsICd8JywgZXRjLlxuXHRcdCAqIFVzZSB0aGlzIG1ldGhvZCBiZWZvcmUgcGFzc2luZyB0byBhY3Rpb25zIGxpa2UgXCJXcmFwIHdpdGggQWJicmV2aWF0aW9uXCJcblx0XHQgKiB0byBtYWtlIHN1cmUgdGhhdCBleGlzdGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgd29uJ3QgYmUgYWx0ZXJlZFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGVzY2FwZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcblx0XHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoLyhbXFwkXFxcXF0pL2csICdcXFxcJDEnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVuZXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgdXNlZCBpbiBFbW1ldCwgbGlrZSAnJCcsICd8JywgZXRjLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHVuZXNjYXBlVGV4dDogZnVuY3Rpb24odGV4dCkge1xuXHRcdFx0cmV0dXJuIHRleHQucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgY2FyZXQgcGxhY2Vob2xkZXJcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldENhcmV0UGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIF8uaXNGdW5jdGlvbihjYXJldFBsYWNlaG9sZGVyKSBcblx0XHRcdFx0PyBjYXJldFBsYWNlaG9sZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0XHRcdFx0OiBjYXJldFBsYWNlaG9sZGVyO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBuZXcgcmVwcmVzZW50YXRpb24gZm9yIGNhcmV0cyBpbiBnZW5lcmF0ZWQgb3V0cHV0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIE5ldyBjYXJldCBwbGFjZWhvbGRlci4gTWlnaHQgYmUgYSBcblx0XHQgKiA8Y29kZT5GdW5jdGlvbjwvY29kZT5cblx0XHQgKi9cblx0XHRzZXRDYXJldFBsYWNlaG9sZGVyOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y2FyZXRQbGFjZWhvbGRlciA9IHZhbHVlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBsaW5lIHBhZGRpbmdcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGluZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRMaW5lUGFkZGluZzogZnVuY3Rpb24obGluZSkge1xuXHRcdFx0cmV0dXJuIChsaW5lLm1hdGNoKC9eKFxccyspLykgfHwgWycnXSlbMF07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHBhZGRpbmcgb2YgbGluZSBvZiA8Y29kZT5wb3M8L2NvZGU+XG5cdFx0ICogcG9zaXRpb24gaW4gPGNvZGU+Y29udGVudDwvY29kZT5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3Ncblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldExpbmVQYWRkaW5nRnJvbVBvc2l0aW9uOiBmdW5jdGlvbihjb250ZW50LCBwb3MpIHtcblx0XHRcdHZhciBsaW5lUmFuZ2UgPSB0aGlzLmZpbmROZXdsaW5lQm91bmRzKGNvbnRlbnQsIHBvcyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRMaW5lUGFkZGluZyhsaW5lUmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnQpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVzY2FwZSBzcGVjaWFsIHJlZ2V4cCBjaGFycyBpbiBzdHJpbmcsIG1ha2luZyBpdCB1c2FibGUgZm9yIGNyZWF0aW5nIGR5bmFtaWNcblx0XHQgKiByZWd1bGFyIGV4cHJlc3Npb25zXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRlc2NhcGVGb3JSZWdleHA6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0dmFyIHNwZWNpYWxzID0gbmV3IFJlZ0V4cChcIlsuKis/fCgpXFxcXFtcXFxcXXt9XFxcXFxcXFxdXCIsIFwiZ1wiKTsgLy8gLiorP3woKVtde31cXFxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHNwZWNpYWxzLCBcIlxcXFwkJlwiKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE1ha2UgZGVjaW1hbCBudW1iZXIgbG9vayBnb29kOiBjb252ZXJ0IGl0IHRvIGZpeGVkIHByZWNpc2lvbiBlbmQgcmVtb3ZlXG5cdFx0ICogdHJhbGluZyB6ZXJvZXMgXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjaW9uIEZyYWN0aW9uIG51bWJlcnMgKGRlZmF1bHQgaXMgMilcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cHJldHRpZnlOdW1iZXI6IGZ1bmN0aW9uKG51bSwgZnJhY3Rpb24pIHtcblx0XHRcdHJldHVybiBudW0udG9GaXhlZCh0eXBlb2YgZnJhY3Rpb24gPT0gJ3VuZGVmaW5lZCcgPyAyIDogZnJhY3Rpb24pLnJlcGxhY2UoL1xcLj8wKyQvLCAnJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIHNpbXBsZSBtdXRhYmxlIHN0cmluZyBzaGltLCBvcHRpbWl6ZWQgZm9yIGZhc3RlciB0ZXh0IGNvbmNhdGVuYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgSW5pdGlhbCB2YWx1ZVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmdCdWlsZGVyfVxuXHRcdCAqL1xuXHRcdHN0cmluZ0J1aWxkZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN0cmluZ0J1aWxkZXIodmFsdWUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZSBzdWJzdHJpbmcgb2YgPGNvZGU+c3RyPC9jb2RlPiB3aXRoIDxjb2RlPnZhbHVlPC9jb2RlPlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHdoZXJlIHRvIHJlcGxhY2Ugc3Vic3RyaW5nXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIE5ldyBzdWJzdHJpbmcgdmFsdWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW5kZXggb2Ygc3Vic3RyaW5nIHRvIHJlcGxhY2UuIE1heSBhbHNvXG5cdFx0ICogYmUgYSA8Y29kZT5SYW5nZTwvY29kZT4gb2JqZWN0OiBpbiB0aGlzIGNhc2UsIHRoZSA8Y29kZT5lbmQ8L2NvZGU+XG5cdFx0ICogYXJndW1lbnQgaXMgbm90IHJlcXVpcmVkXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW5kZXggb2Ygc3Vic3RyaW5nIHRvIHJlcGxhY2UuIElmIG9tbWl0ZWQsIFxuXHRcdCAqIDxjb2RlPnN0YXJ0PC9jb2RlPiBhcmd1bWVudCBpcyB1c2VkXG5cdFx0ICovXG5cdFx0cmVwbGFjZVN1YnN0cmluZzogZnVuY3Rpb24oc3RyLCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuXHRcdFx0aWYgKF8uaXNPYmplY3Qoc3RhcnQpICYmICdlbmQnIGluIHN0YXJ0KSB7XG5cdFx0XHRcdGVuZCA9IHN0YXJ0LmVuZDtcblx0XHRcdFx0c3RhcnQgPSBzdGFydC5zdGFydDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKF8uaXNTdHJpbmcoZW5kKSlcblx0XHRcdFx0ZW5kID0gc3RhcnQgKyBlbmQubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHRpZiAoXy5pc1VuZGVmaW5lZChlbmQpKVxuXHRcdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+IHN0ci5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTmFycm93cyBkb3duIHRleHQgcmFuZ2UsIGFkanVzdGluZyBzZWxlY3Rpb24gdG8gbm9uLXNwYWNlIGNoYXJhY3RlcnNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydGluZyByYW5nZSBpbiA8Y29kZT50ZXh0PC9jb2RlPiB3aGVyZSBcblx0XHQgKiBzbGVjdGlvbiBzaG91bGQgYmUgYWRqdXN0ZWQuIENhbiBhbHNvIGJlIGFueSBvYmplY3QgdGhhdCBpcyBhY2NlcHRlZFxuXHRcdCAqIGJ5IDxjb2RlPlJhbmdlPC9jb2RlPiBjbGFzc1xuXHRcdCAqIEByZXR1cm4ge1JhbmdlfVxuXHRcdCAqL1xuXHRcdG5hcnJvd1RvTm9uU3BhY2U6IGZ1bmN0aW9uKHRleHQsIHN0YXJ0LCBlbmQpIHtcblx0XHRcdHZhciByYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJykuY3JlYXRlKHN0YXJ0LCBlbmQpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVTcGFjZSA9IC9bXFxzXFxuXFxyXFx1MDBhMF0vO1xuXHRcdFx0Ly8gbmFycm93IGRvd24gc2VsZWN0aW9uIHVudGlsIGZpcnN0IG5vbi1zcGFjZSBjaGFyYWN0ZXJcblx0XHRcdHdoaWxlIChyYW5nZS5zdGFydCA8IHJhbmdlLmVuZCkge1xuXHRcdFx0XHRpZiAoIXJlU3BhY2UudGVzdCh0ZXh0LmNoYXJBdChyYW5nZS5zdGFydCkpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRyYW5nZS5zdGFydCsrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR3aGlsZSAocmFuZ2UuZW5kID4gcmFuZ2Uuc3RhcnQpIHtcblx0XHRcdFx0cmFuZ2UuZW5kLS07XG5cdFx0XHRcdGlmICghcmVTcGFjZS50ZXN0KHRleHQuY2hhckF0KHJhbmdlLmVuZCkpKSB7XG5cdFx0XHRcdFx0cmFuZ2UuZW5kKys7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJhbmdlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZCBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRleHQgbGluZSBmb3IgPGNvZGU+ZnJvbTwvY29kZT4gaW5kZXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZnJvbVxuXHRcdCAqL1xuXHRcdGZpbmROZXdsaW5lQm91bmRzOiBmdW5jdGlvbih0ZXh0LCBmcm9tKSB7XG5cdFx0XHR2YXIgbGVuID0gdGV4dC5sZW5ndGgsXG5cdFx0XHRcdHN0YXJ0ID0gMCxcblx0XHRcdFx0ZW5kID0gbGVuIC0gMTtcblx0XHRcdFxuXHRcdFx0Ly8gc2VhcmNoIGxlZnRcblx0XHRcdGZvciAodmFyIGkgPSBmcm9tIC0gMTsgaSA+IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgY2ggPSB0ZXh0LmNoYXJBdChpKTtcblx0XHRcdFx0aWYgKGNoID09ICdcXG4nIHx8IGNoID09ICdcXHInKSB7XG5cdFx0XHRcdFx0c3RhcnQgPSBpICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc2VhcmNoIHJpZ2h0XG5cdFx0XHRmb3IgKHZhciBqID0gZnJvbTsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHRcdHZhciBjaCA9IHRleHQuY2hhckF0KGopO1xuXHRcdFx0XHRpZiAoY2ggPT0gJ1xcbicgfHwgY2ggPT0gJ1xccicpIHtcblx0XHRcdFx0XHRlbmQgPSBqO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWVwIG1lcmdlIG9mIHR3byBvciBtb3JlIG9iamVjdHMuIFRha2VuIGZyb20galF1ZXJ5LmV4dGVuZCgpXG5cdFx0ICovXG5cdFx0ZGVlcE1lcmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMSxcblx0XHRcdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuXG5cdFx0XHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0XHRcdGlmICghXy5pc09iamVjdCh0YXJnZXQpICYmICFfLmlzRnVuY3Rpb24odGFyZ2V0KSkge1xuXHRcdFx0XHR0YXJnZXQgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdFx0XHRpZiAoIGNvcHkgJiYgKCBfLmlzT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IF8uaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIF8uaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBfLmlzT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IHRoaXMuZGVlcE1lcmdlKGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cdH07XG59KTtcbi8qKlxuICogSGVscGVyIG1vZHVsZSB0byB3b3JrIHdpdGggcmFuZ2VzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX3JhbmdlRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZGVmaW5lKCdyYW5nZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0ZnVuY3Rpb24gY21wKGEsIGIsIG9wKSB7XG5cdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0Y2FzZSAnZXEnOlxuXHRcdFx0Y2FzZSAnPT0nOlxuXHRcdFx0XHRyZXR1cm4gYSA9PT0gYjtcblx0XHRcdGNhc2UgJ2x0Jzpcblx0XHRcdGNhc2UgJzwnOlxuXHRcdFx0XHRyZXR1cm4gYSA8IGI7XG5cdFx0XHRjYXNlICdsdGUnOlxuXHRcdFx0Y2FzZSAnPD0nOlxuXHRcdFx0XHRyZXR1cm4gYSA8PSBiO1xuXHRcdFx0Y2FzZSAnZ3QnOlxuXHRcdFx0Y2FzZSAnPic6XG5cdFx0XHRcdHJldHVybiBhID4gYjtcblx0XHRcdGNhc2UgJ2d0ZSc6XG5cdFx0XHRjYXNlICc+PSc6XG5cdFx0XHRcdHJldHVybiBhID49IGI7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEB0eXBlIFJhbmdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlblxuXHQgKi9cblx0ZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGxlbikge1xuXHRcdGlmIChfLmlzT2JqZWN0KHN0YXJ0KSAmJiAnc3RhcnQnIGluIHN0YXJ0KSB7XG5cdFx0XHQvLyBjcmVhdGUgcmFuZ2UgZnJvbSBvYmplY3Qgc3R1YlxuXHRcdFx0dGhpcy5zdGFydCA9IE1hdGgubWluKHN0YXJ0LnN0YXJ0LCBzdGFydC5lbmQpO1xuXHRcdFx0dGhpcy5lbmQgPSBNYXRoLm1heChzdGFydC5zdGFydCwgc3RhcnQuZW5kKTtcblx0XHR9IGVsc2UgaWYgKF8uaXNBcnJheShzdGFydCkpIHtcblx0XHRcdHRoaXMuc3RhcnQgPSBzdGFydFswXTtcblx0XHRcdHRoaXMuZW5kID0gc3RhcnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxlbiA9IF8uaXNTdHJpbmcobGVuKSA/IGxlbi5sZW5ndGggOiArbGVuO1xuXHRcdFx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0dGhpcy5lbmQgPSBzdGFydCArIGxlbjtcblx0XHR9XG5cdH1cblx0XG5cdFJhbmdlLnByb3RvdHlwZSA9IHtcblx0XHRsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuZW5kIC0gdGhpcy5zdGFydCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHBhc3NlZCByYW5nZSBpcyBlcXVhbHMgdG8gY3VycmVudCBvbmVcblx0XHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGVxdWFsOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY21wKHJhbmdlLCAnZXEnLCAnZXEnKTtcbi8vXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQgPT09IHJhbmdlLnN0YXJ0ICYmIHRoaXMuZW5kID09PSByYW5nZS5lbmQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTaGlmdHMgaW5kZXhlcyBwb3NpdGlvbiB3aXRoIHBhc3NlZCA8Y29kZT5kZWxhdDwvY29kZT5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9IHJhbmdlIGl0c2VsZlxuXHRcdCAqL1xuXHRcdHNoaWZ0OiBmdW5jdGlvbihkZWx0YSkge1xuXHRcdFx0dGhpcy5zdGFydCArPSBkZWx0YTtcblx0XHRcdHRoaXMuZW5kICs9IGRlbHRhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiB0d28gcmFuZ2VzIGFyZSBvdmVybGFwcGVkXG5cdFx0ICogQHBhcmFtIHtSYW5nZX0gcmFuZ2Vcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRvdmVybGFwOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdFx0cmV0dXJuIHJhbmdlLnN0YXJ0IDw9IHRoaXMuZW5kICYmIHJhbmdlLmVuZCA+PSB0aGlzLnN0YXJ0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZHMgaW50ZXJzZWN0aW9uIG9mIHR3byByYW5nZXNcblx0XHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX0gPGNvZGU+bnVsbDwvY29kZT4gaWYgcmFuZ2VzIGRvZXMgbm90IG92ZXJsYXBcblx0XHQgKi9cblx0XHRpbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0XHRpZiAodGhpcy5vdmVybGFwKHJhbmdlKSkge1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBNYXRoLm1heChyYW5nZS5zdGFydCwgdGhpcy5zdGFydCk7XG5cdFx0XHRcdHZhciBlbmQgPSBNYXRoLm1pbihyYW5nZS5lbmQsIHRoaXMuZW5kKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHVuaW9uIG9mIHRoZSB0aG93IHJhbmdlcy5cblx0XHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX0gPGNvZGU+bnVsbDwvY29kZT4gaWYgcmFuZ2VzIGFyZSBub3Qgb3ZlcmxhcHBlZFxuXHRcdCAqL1xuXHRcdHVuaW9uOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdFx0aWYgKHRoaXMub3ZlcmxhcChyYW5nZSkpIHtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gTWF0aC5taW4ocmFuZ2Uuc3RhcnQsIHRoaXMuc3RhcnQpO1xuXHRcdFx0XHR2YXIgZW5kID0gTWF0aC5tYXgocmFuZ2UuZW5kLCB0aGlzLmVuZCk7XG5cdFx0XHRcdHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgQm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgc3BlY2lmaWVkIHBvc2l0aW9uIFxuXHRcdCAqIGlzIGluIGEgZ2l2ZW4gcmFuZ2UuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvY1xuXHRcdCAqL1xuXHRcdGluc2lkZTogZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jbXAobG9jLCAnbHRlJywgJ2d0Jyk7XG4vL1x0XHRcdHJldHVybiB0aGlzLnN0YXJ0IDw9IGxvYyAmJiB0aGlzLmVuZCA+IGxvYztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSBCb29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBzcGVjaWZpZWQgcG9zaXRpb24gXG5cdFx0ICogaXMgaW4gYSBnaXZlbiByYW5nZSwgYnV0IG5vdCBlcXVhbHMgYm91bmRzLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2Ncblx0XHQgKi9cblx0XHRjb250YWluczogZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jbXAobG9jLCAnbHQnLCAnZ3QnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGN1cnJlbnQgcmFuZ2UgY29tcGxldGVseSBpbmNsdWRlcyBzcGVjaWZpZWQgb25lXG5cdFx0ICogQHBhcmFtIHtSYW5nZX0gclxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufSBcblx0XHQgKi9cblx0XHRpbmNsdWRlOiBmdW5jdGlvbihyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jbXAobG9jLCAnbHRlJywgJ2d0ZScpO1xuLy9cdFx0XHRyZXR1cm4gdGhpcy5zdGFydCA8PSByLnN0YXJ0ICYmIHRoaXMuZW5kID49IHIuZW5kO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTG93LWxldmVsIGNvbXBhcmlzaW9uIG1ldGhvZFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2Ncblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGVmdCBMZWZ0IGNvbXBhcmlzb24gb3BlcmF0b3Jcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcmlnaHQgUmlnaHQgY29tYXByaXNvbiBvcGVyYXRvclxuXHRcdCAqL1xuXHRcdGNtcDogZnVuY3Rpb24obG9jLCBsZWZ0LCByaWdodCkge1xuXHRcdFx0dmFyIGEsIGI7XG5cdFx0XHRpZiAobG9jIGluc3RhbmNlb2YgUmFuZ2UpIHtcblx0XHRcdFx0YSA9IGxvYy5zdGFydDtcblx0XHRcdFx0YiA9IGxvYy5lbmQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhID0gYiA9IGxvYztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNtcCh0aGlzLnN0YXJ0LCBhLCBsZWZ0IHx8ICc8PScpICYmIGNtcCh0aGlzLmVuZCwgYiwgcmlnaHQgfHwgJz4nKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc3Vic3RyaW5nIG9mIHNwZWNpZmllZCA8Y29kZT5zdHI8L2NvZGU+IGZvciBjdXJyZW50IHJhbmdlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0c3Vic3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiB0aGlzLmxlbmd0aCgpID4gMCBcblx0XHRcdFx0PyBzdHIuc3Vic3RyaW5nKHRoaXMuc3RhcnQsIHRoaXMuZW5kKSBcblx0XHRcdFx0OiAnJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgY29weSBvZiBjdXJyZW50IHJhbmdlXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqL1xuXHRcdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5sZW5ndGgoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW3RoaXMuc3RhcnQsIHRoaXMuZW5kXTtcblx0XHR9LFxuXHRcdFxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAneycgKyB0aGlzLnN0YXJ0ICsgJywgJyArIHRoaXMubGVuZ3RoKCkgKyAnfSc7XG5cdFx0fVxuXHR9O1xuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIG5ldyByYW5nZSBvYmplY3QgaW5zdGFuY2Vcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3RhcnQgUmFuZ2Ugc3RhcnQgb3IgYXJyYXkgd2l0aCAnc3RhcnQnIGFuZCAnZW5kJ1xuXHRcdCAqIGFzIHR3byBmaXJzdCBpbmRleGVzIG9yIG9iamVjdCB3aXRoICdzdGFydCcgYW5kICdlbmQnIHByb3BlcnRpZXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbGVuIFJhbmdlIGxlbmd0aCBvciBzdHJpbmcgdG8gcHJvZHVjZSByYW5nZSBmcm9tXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqIEBtZW1iZXJPZiBlbW1ldC5yYW5nZVxuXHRcdCAqL1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oc3RhcnQsIGxlbikge1xuXHRcdFx0aWYgKF8uaXNVbmRlZmluZWQoc3RhcnQpIHx8IHN0YXJ0ID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0IGluc3RhbmNlb2YgUmFuZ2UpXG5cdFx0XHRcdHJldHVybiBzdGFydDtcblx0XHRcdFxuXHRcdFx0aWYgKF8uaXNPYmplY3Qoc3RhcnQpICYmICdzdGFydCcgaW4gc3RhcnQgJiYgJ2VuZCcgaW4gc3RhcnQpIHtcblx0XHRcdFx0bGVuID0gc3RhcnQuZW5kIC0gc3RhcnQuc3RhcnQ7XG5cdFx0XHRcdHN0YXJ0ID0gc3RhcnQuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBSYW5nZShzdGFydCwgbGVuKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIDxjb2RlPlJhbmdlPC9jb2RlPiBvYmplY3QgZmFjdG9yeSwgdGhlIHNhbWUgYXMgPGNvZGU+dGhpcy5jcmVhdGUoKTwvY29kZT5cblx0XHQgKiBidXQgbGFzdCBhcmd1bWVudCByZXByZXNlbnRzIGVuZCBvZiByYW5nZSwgbm90IGxlbmd0aFxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRjcmVhdGUyOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdFx0XHRpZiAoXy5pc051bWJlcihzdGFydCkgJiYgXy5pc051bWJlcihlbmQpKSB7XG5cdFx0XHRcdGVuZCAtPSBzdGFydDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlKHN0YXJ0LCBlbmQpO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogVXRpbGl0eSBtb2R1bGUgdGhhdCBwcm92aWRlcyBvcmRlcmVkIHN0b3JhZ2Ugb2YgZnVuY3Rpb24gaGFuZGxlcnMuIFxuICogTWFueSBFbW1ldCBtb2R1bGVzJyBmdW5jdGlvbmFsaXR5IGNhbiBiZSBleHRlbmRlZC9vdmVycmlkZGVuIGJ5IGN1c3RvbVxuICogZnVuY3Rpb24uIFRoaXMgbW9kdWxlcyBwcm92aWRlcyB1bmlmaWVkIHN0b3JhZ2Ugb2YgaGFuZGxlciBmdW5jdGlvbnMsIHRoZWlyIFxuICogbWFuYWdlbWVudCBhbmQgZXhlY3V0aW9uXG4gKiBcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1lbWJlck9mIF9faGFuZGxlckxpc3REZWZpbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5kZWZpbmUoJ2hhbmRsZXJMaXN0JywgZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKipcblx0ICogQHR5cGUgSGFuZGxlckxpc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBIYW5kbGVyTGlzdCgpIHtcblx0XHR0aGlzLl9saXN0ID0gW107XG5cdH1cblx0XG5cdEhhbmRsZXJMaXN0LnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBBZGRzIGZ1bmN0aW9uIGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBIYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgSGFuZGxlciBvcHRpb25zLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOjxicj48YnI+XG5cdFx0ICogPGI+b3JkZXI8L2I+IDogKDxjb2RlPk51bWJlcjwvY29kZT4pIOKAkyBvcmRlciBpbiBoYW5kbGVyIGxpc3QuIEhhbmRsZXJzXG5cdFx0ICogd2l0aCBoaWdoZXIgb3JkZXIgdmFsdWUgd2lsbCBiZSBleGVjdXRlZCBlYXJsaWVyLlxuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24oZm4sIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuX2xpc3QucHVzaChfLmV4dGVuZCh7b3JkZXI6IDB9LCBvcHRpb25zIHx8IHt9LCB7Zm46IGZufSkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBoYW5kbGVyIGZyb20gbGlzdFxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbihmbikge1xuXHRcdFx0dGhpcy5fbGlzdCA9IF8ud2l0aG91dCh0aGlzLl9saXN0LCBfLmZpbmQodGhpcy5fbGlzdCwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5mbiA9PT0gZm47XG5cdFx0XHR9KSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG9yZGVyZWQgbGlzdCBvZiBoYW5kbGVycy4gQnkgZGVmYXVsdCwgaGFuZGxlcnMgXG5cdFx0ICogd2l0aCB0aGUgc2FtZSA8Y29kZT5vcmRlcjwvY29kZT4gb3B0aW9uIHJldHVybmVkIGluIHJldmVyc2Ugb3JkZXIsIFxuXHRcdCAqIGkuZS4gdGhlIGxhdHRlciBmdW5jdGlvbiB3YXMgYWRkZWQgaW50byB0aGUgaGFuZGxlcnMgbGlzdCwgdGhlIGhpZ2hlciBcblx0XHQgKiBpdCB3aWxsIGJlIGluIHRoZSByZXR1cm5lZCBhcnJheSBcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gXy5zb3J0QnkodGhpcy5fbGlzdCwgJ29yZGVyJykucmV2ZXJzZSgpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBvcmRlcmVkIGxpc3Qgb2YgaGFuZGxlciBmdW5jdGlvbnNcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdEZuOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfLnBsdWNrKHRoaXMubGlzdCgpLCAnZm4nKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIGhhbmRsZXIgZnVuY3Rpb25zIGluIHRoZWlyIGRlc2lnbmF0ZWQgb3JkZXIuIElmIGZ1bmN0aW9uXG5cdFx0ICogcmV0dXJucyA8Y29kZT5za2lwVmFsPC9jb2RlPiwgbWVhbmluZyB0aGF0IGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gXG5cdFx0ICogaGFuZGxlIHBhc3NlZCA8Y29kZT5hcmdzPC9jb2RlPiwgdGhlIG5leHQgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZFxuXHRcdCAqIGFuZCBzbyBvbi5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2tpcFZhbHVlIElmIGZ1bmN0aW9uIHJldHVybnMgdGhpcyB2YWx1ZSwgZXhlY3V0ZSBcblx0XHQgKiBuZXh0IGhhbmRsZXIuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHMgdG8gcGFzcyB0byBoYW5kbGVyIGZ1bmN0aW9uXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgYW55IG9mIHJlZ2lzdGVyZWQgaGFuZGxlcnMgcGVyZm9ybWVkXG5cdFx0ICogc3VjY2Vzc2Z1bGx5ICBcblx0XHQgKi9cblx0XHRleGVjOiBmdW5jdGlvbihza2lwVmFsdWUsIGFyZ3MpIHtcblx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cdFx0XHRfLmZpbmQodGhpcy5saXN0KCksIGZ1bmN0aW9uKGgpIHtcblx0XHRcdFx0cmVzdWx0ID0gaC5mbi5hcHBseShoLCBhcmdzKTtcblx0XHRcdFx0aWYgKHJlc3VsdCAhPT0gc2tpcFZhbHVlKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9O1xuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IHByb2R1Y2VzIDxjb2RlPkhhbmRsZXJMaXN0PC9jb2RlPiBpbnN0YW5jZVxuXHRcdCAqIEByZXR1cm5zIHtIYW5kbGVyTGlzdH1cblx0XHQgKiBAbWVtYmVyT2YgaGFuZGxlckxpc3Rcblx0XHQgKi9cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBIYW5kbGVyTGlzdCgpO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogSGVscGVyIGNsYXNzIGZvciBjb252ZW5pZW50IHRva2VuIGl0ZXJhdGlvblxuICovXG5lbW1ldC5kZWZpbmUoJ3Rva2VuSXRlcmF0b3InLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSBUb2tlbkl0ZXJhdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuXHQgKiBAdHlwZSBUb2tlbkl0ZXJhdG9yXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVG9rZW5JdGVyYXRvcih0b2tlbnMpIHtcblx0XHQvKiogQHR5cGUgQXJyYXkgKi9cblx0XHR0aGlzLnRva2VucyA9IHRva2Vucztcblx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdFx0dGhpcy5yZXNldCgpO1xuXHR9XG5cdFxuXHRUb2tlbkl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRuZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLmhhc05leHQoKSkge1xuXHRcdFx0XHR2YXIgdG9rZW4gPSB0aGlzLnRva2Vuc1srK3RoaXMuX2ldO1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHRva2VuLnN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0XG5cdFx0Y3VycmVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5faV07XG5cdFx0fSxcblx0XHRcblx0XHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XG5cdFx0fSxcblx0XHRcblx0XHRoYXNOZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pIDwgdGhpcy5faWwgLSAxO1xuXHRcdH0sXG5cdFx0XG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5faSA9IC0xO1xuXHRcdFx0dGhpcy5faWwgPSB0aGlzLnRva2Vucy5sZW5ndGg7XG5cdFx0fSxcblx0XHRcblx0XHRpdGVtOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLl9pXTtcblx0XHR9LFxuXHRcdFxuXHRcdGl0ZW1OZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLl9pICsgMV07XG5cdFx0fSxcblx0XHRcblx0XHRpdGVtUHJldjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5faSAtIDFdO1xuXHRcdH0sXG5cdFx0XG5cdFx0bmV4dFVudGlsOiBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHRva2VuO1xuXHRcdFx0dmFyIHRlc3QgPSBfLmlzU3RyaW5nKHR5cGUpIFxuXHRcdFx0XHQ/IGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGUgPT0gdHlwZTt9IFxuXHRcdFx0XHQ6IHR5cGU7XG5cdFx0XHRcblx0XHRcdHdoaWxlICh0b2tlbiA9IHRoaXMubmV4dCgpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjaylcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHRva2VuKTtcblx0XHRcdFx0aWYgKHRlc3QuY2FsbCh0aGlzLCB0b2tlbikpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0cmV0dXJuIHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHRva2Vucykge1xuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbkl0ZXJhdG9yKHRva2Vucyk7XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBBIHRyaW1tZWQgdmVyc2lvbiBvZiBDb2RlTWlycm9yJ3MgU3RyaW5nU3RyZWFtIG1vZHVsZSBmb3Igc3RyaW5nIHBhcnNpbmdcbiAqL1xuZW1tZXQuZGVmaW5lKCdzdHJpbmdTdHJlYW0nLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSBTdHJpbmdTdHJlYW1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcblx0ICovXG5cdGZ1bmN0aW9uIFN0cmluZ1N0cmVhbShzdHJpbmcpIHtcblx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xuXHRcdHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuXHR9XG5cdFxuXHRTdHJpbmdTdHJlYW0ucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBzdHJlYW0gaXMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRlb2w6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBzdHJlYW0gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0c29sOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBvcyA9PSAwO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmVhbSB3aXRob3V0IGFkdmFuY2luZyBpdC4gXG5cdFx0ICogV2lsbCByZXR1cm4gPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0cGVlazogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG5leHQgY2hhcmFjdGVyIGluIHRoZSBzdHJlYW0gYW5kIGFkdmFuY2VzIGl0LlxuXHRcdCAqIEFsc28gcmV0dXJucyA8Y29kZT51bmRlZmluZWQ8L2NvZGU+IHdoZW4gbm8gbW9yZSBjaGFyYWN0ZXJzIGFyZSBhdmFpbGFibGUuXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRuZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIG1hdGNoIGNhbiBiZSBhIGNoYXJhY3RlciwgYSByZWd1bGFyIGV4cHJlc3Npb24sIG9yIGEgZnVuY3Rpb24gdGhhdFxuXHRcdCAqIHRha2VzIGEgY2hhcmFjdGVyIGFuZCByZXR1cm5zIGEgYm9vbGVhbi4gSWYgdGhlIG5leHQgY2hhcmFjdGVyIGluIHRoZVxuXHRcdCAqIHN0cmVhbSAnbWF0Y2hlcycgdGhlIGdpdmVuIGFyZ3VtZW50LCBpdCBpcyBjb25zdW1lZCBhbmQgcmV0dXJuZWQuXG5cdFx0ICogT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG1hdGNoXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRlYXQ6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHR2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpLCBvaztcblx0XHRcdGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcblx0XHRcdFx0b2sgPSBjaCA9PSBtYXRjaDtcblx0XHRcdGVsc2Vcblx0XHRcdFx0b2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcblx0XHRcdFxuXHRcdFx0aWYgKG9rKSB7XG5cdFx0XHRcdCsrdGhpcy5wb3M7XG5cdFx0XHRcdHJldHVybiBjaDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcGVhdGVkbHkgY2FsbHMgPGNvZGU+ZWF0PC9jb2RlPiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudCwgdW50aWwgaXRcblx0XHQgKiBmYWlscy4gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBhbnkgY2hhcmFjdGVycyB3ZXJlIGVhdGVuLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaFxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGVhdFdoaWxlOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG5cdFx0XHR3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7fVxuXHRcdFx0cmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTaG9ydGN1dCBmb3IgPGNvZGU+ZWF0V2hpbGU8L2NvZGU+IHdoZW4gbWF0Y2hpbmcgd2hpdGUtc3BhY2UuXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZWF0U3BhY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG5cdFx0XHR3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcblx0XHRcdFx0Kyt0aGlzLnBvcztcblx0XHRcdHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTW92ZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG5cdFx0ICovXG5cdFx0c2tpcFRvRW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2tpcHMgdG8gdGhlIG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcblx0XHQgKiBjdXJyZW50IGxpbmUgKGRvZXNuJ3QgYWR2YW5jZSB0aGUgc3RyZWFtIGlmIHRoZSBjaGFyYWN0ZXIgZG9lcyBub3Rcblx0XHQgKiBvY2N1ciBvbiB0aGUgbGluZSkuIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIHdhcyBmb3VuZC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY2hcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRza2lwVG86IGZ1bmN0aW9uKGNoKSB7XG5cdFx0XHR2YXIgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XG5cdFx0XHRpZiAoZm91bmQgPiAtMSkge1xuXHRcdFx0XHR0aGlzLnBvcyA9IGZvdW5kO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNraXBzIHRvIDxjb2RlPmNsb3NlPC9jb2RlPiBjaGFyYWN0ZXIgd2hpY2ggaXMgcGFpciB0byA8Y29kZT5vcGVuPC9jb2RlPlxuXHRcdCAqIGNoYXJhY3RlciwgY29uc2lkZXJpbmcgcG9zc2libGUgcGFpciBuZXN0aW5nLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcblx0XHQgKiB0byBjb25zdW1lIHBhaXIgb2YgY2hhcmFjdGVycywgbGlrZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGJyYWNlc1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBvcGVuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNsb3NlXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgcGFpciB3YXMgc3VjY2Vzc2Z1bGx5XG5cdFx0ICogY29uc3VtZWRcblx0XHQgKi9cblx0XHRza2lwVG9QYWlyOiBmdW5jdGlvbihvcGVuLCBjbG9zZSkge1xuXHRcdFx0dmFyIGJyYWNlQ291bnQgPSAwLCBjaDtcblx0XHRcdHZhciBwb3MgPSB0aGlzLnBvcywgbGVuID0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKHBvcyA8IGxlbikge1xuXHRcdFx0XHRjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdChwb3MrKyk7XG5cdFx0XHRcdGlmIChjaCA9PSBvcGVuKSB7XG5cdFx0XHRcdFx0YnJhY2VDb3VudCsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNoID09IGNsb3NlKSB7XG5cdFx0XHRcdFx0YnJhY2VDb3VudC0tO1xuXHRcdFx0XHRcdGlmIChicmFjZUNvdW50IDwgMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5wb3MgPSBwb3M7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQmFja3MgdXAgdGhlIHN0cmVhbSBuIGNoYXJhY3RlcnMuIEJhY2tpbmcgaXQgdXAgZnVydGhlciB0aGFuIHRoZVxuXHRcdCAqIHN0YXJ0IG9mIHRoZSBjdXJyZW50IHRva2VuIHdpbGwgY2F1c2UgdGhpbmdzIHRvIGJyZWFrLCBzbyBiZSBjYXJlZnVsLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBuXG5cdFx0ICovXG5cdFx0YmFja1VwIDogZnVuY3Rpb24obikge1xuXHRcdFx0dGhpcy5wb3MgLT0gbjtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFjdCBsaWtlIGEgbXVsdGktY2hhcmFjdGVyIDxjb2RlPmVhdDwvY29kZT7igJRpZiA8Y29kZT5jb25zdW1lPC9jb2RlPiBpcyB0cnVlIG9yXG5cdFx0ICogbm90IGdpdmVu4oCUb3IgYSBsb29rLWFoZWFkIHRoYXQgZG9lc24ndCB1cGRhdGUgdGhlIHN0cmVhbSBwb3NpdGlvbuKAlGlmXG5cdFx0ICogaXQgaXMgZmFsc2UuIDxjb2RlPnBhdHRlcm48L2NvZGU+IGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYVxuXHRcdCAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdGFydGluZyB3aXRoIF4uIFdoZW4gaXQgaXMgYSBzdHJpbmcsXG5cdFx0ICogPGNvZGU+Y2FzZUluc2Vuc2l0aXZlPC9jb2RlPiBjYW4gYmUgc2V0IHRvIHRydWUgdG8gbWFrZSB0aGUgbWF0Y2hcblx0XHQgKiBjYXNlLWluc2Vuc2l0aXZlLiBXaGVuIHN1Y2Nlc3NmdWxseSBtYXRjaGluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbixcblx0XHQgKiB0aGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSB0aGUgYXJyYXkgcmV0dXJuZWQgYnkgPGNvZGU+bWF0Y2g8L2NvZGU+LFxuXHRcdCAqIGluIGNhc2UgeW91IG5lZWQgdG8gZXh0cmFjdCBtYXRjaGVkIGdyb3Vwcy5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FzZUluc2Vuc2l0aXZlXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRtYXRjaDogZnVuY3Rpb24ocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG5cdFx0XHRpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR2YXIgY2FzZWQgPSBjYXNlSW5zZW5zaXRpdmVcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKHN0cikge3JldHVybiBzdHIudG9Mb3dlckNhc2UoKTt9XG5cdFx0XHRcdFx0OiBmdW5jdGlvbihzdHIpIHtyZXR1cm4gc3RyO307XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY2FzZWQodGhpcy5zdHJpbmcpLmluZGV4T2YoY2FzZWQocGF0dGVybiksIHRoaXMucG9zKSA9PSB0aGlzLnBvcykge1xuXHRcdFx0XHRcdGlmIChjb25zdW1lICE9PSBmYWxzZSlcblx0XHRcdFx0XHRcdHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG5cdFx0XHRcdGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSlcblx0XHRcdFx0XHR0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc3RyaW5nIGJldHdlZW4gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IHRva2VuIGFuZCB0aGUgXG5cdFx0ICogY3VycmVudCBzdHJlYW0gcG9zaXRpb24uXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRjdXJyZW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7XG5cdFx0fVxuXHR9O1xuXHRcblx0cmV0dXJuIHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIG5ldyBTdHJpbmdTdHJlYW0oc3RyaW5nKTtcblx0XHR9XG5cdH07XG59KTsvKipcbiAqIFBhcnNlZCByZXNvdXJjZXMgKHNuaXBwZXRzLCBhYmJyZXZpYXRpb25zLCB2YXJpYWJsZXMsIGV0Yy4pIGZvciBFbW1ldC5cbiAqIENvbnRhaW5zIGNvbnZlbmllbnQgbWV0aG9kIHRvIGdldCBhY2Nlc3MgZm9yIHNuaXBwZXRzIHdpdGggcmVzcGVjdCBvZiBcbiAqIGluaGVyaXRhbmNlLiBBbHNvIHByb3ZpZGVzIGFiaWxpdHkgdG8gc3RvcmUgZGF0YSBpbiBkaWZmZXJlbnQgdm9jYWJ1bGFyaWVzXG4gKiAoJ3N5c3RlbScgYW5kICd1c2VyJykgZm9yIGZhc3QgYW5kIHNhZmUgcmVzb3VyY2UgdXBkYXRlXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKVxuICogQGxpbmsgaHR0cDovL2NoaWt1eW9ub2sucnVcbiAqIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmRlZmluZSgncmVzb3VyY2VzJywgZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHR2YXIgVk9DX1NZU1RFTSA9ICdzeXN0ZW0nO1xuXHR2YXIgVk9DX1VTRVIgPSAndXNlcic7XG5cdFxuXHR2YXIgY2FjaGUgPSB7fTtcblx0XHRcblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgWE1MIHRhZyBtYXRjaGluZyAqL1xuXHR2YXIgcmVUYWcgPSAvXjwoXFx3K1xcOj9bXFx3XFwtXSopKCg/OlxccytbXFx3XFw6XFwtXStcXHMqPVxccyooWydcIl0pLio/XFwzKSopXFxzKihcXC8/KT4vO1xuXHRcdFxuXHR2YXIgc3lzdGVtU2V0dGluZ3MgPSB7fTtcblx0dmFyIHVzZXJTZXR0aW5ncyA9IHt9O1xuXHRcblx0LyoqIEB0eXBlIEhhbmRsZXJMaXN0IExpc3Qgb2YgcmVnaXN0ZXJlZCBhYmJyZXZpYXRpb24gcmVzb2x2ZXJzICovXG5cdHZhciByZXNvbHZlcnMgPSByZXF1aXJlKCdoYW5kbGVyTGlzdCcpLmNyZWF0ZSgpO1xuXHRcblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgY2FyZXQgcGxjZWhvbGRlciBpbiBwYXNzZWQgdGV4dDogcmVwbGFjZXMgfCBjaGFyYWN0ZXIgd2l0aFxuXHQgKiBkZWZhdWx0IGNhcmV0IHBsYWNlaG9sZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVDYXJldFBsYWNlaG9sZGVyKHRleHQpIHtcblx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdHJldHVybiB1dGlscy5yZXBsYWNlVW5lc2NhcGVkU3ltYm9sKHRleHQsICd8JywgdXRpbHMuZ2V0Q2FyZXRQbGFjZWhvbGRlcigpKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcGFyc2VJdGVtKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG5cdFx0dmFsdWUgPSBub3JtYWxpemVDYXJldFBsYWNlaG9sZGVyKHZhbHVlKTtcblx0XHRcblx0XHRpZiAodHlwZSA9PSAnc25pcHBldHMnKSB7XG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgnZWxlbWVudHMnKS5jcmVhdGUoJ3NuaXBwZXQnLCB2YWx1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmICh0eXBlID09ICdhYmJyZXZpYXRpb25zJykge1xuXHRcdFx0cmV0dXJuIHBhcnNlQWJicmV2aWF0aW9uKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQYXJzZXMgc2luZ2xlIGFiYnJldmlhdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEFiYnJldmlhdGlvbiBuYW1lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBBYmJyZXZpYXRpb24gdmFsdWVcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VBYmJyZXZpYXRpb24oa2V5LCB2YWx1ZSkge1xuXHRcdGtleSA9IHJlcXVpcmUoJ3V0aWxzJykudHJpbShrZXkpO1xuXHRcdHZhciBlbGVtZW50cyA9IHJlcXVpcmUoJ2VsZW1lbnRzJyk7XG5cdFx0dmFyIG07XG5cdFx0aWYgKG0gPSByZVRhZy5leGVjKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzLmNyZWF0ZSgnZWxlbWVudCcsIG1bMV0sIG1bMl0sIG1bNF0gPT0gJy8nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYXNzdW1lIGl0J3MgcmVmZXJlbmNlIHRvIGFub3RoZXIgYWJicmV2aWF0aW9uXG5cdFx0XHRyZXR1cm4gZWxlbWVudHMuY3JlYXRlKCdyZWZlcmVuY2UnLCB2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogTm9ybWFsaXplcyBzbmlwcGV0IGtleSBuYW1lIGZvciBiZXR0ZXIgZnV6enkgc2VhcmNoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC86JC8sICcnKS5yZXBsYWNlKC86L2csICctJyk7XG5cdH1cblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBuZXcgdW5wYXJzZWQgZGF0YSBmb3Igc3BlY2lmaWVkIHNldHRpbmdzIHZvY2FidWxhcnlcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFZvY2FidWxhcnkgdHlwZSAoJ3N5c3RlbScgb3IgJ3VzZXInKVxuXHRcdCAqIEBtZW1iZXJPZiByZXNvdXJjZXNcblx0XHQgKi9cblx0XHRzZXRWb2NhYnVsYXJ5OiBmdW5jdGlvbihkYXRhLCB0eXBlKSB7XG5cdFx0XHRjYWNoZSA9IHt9O1xuXHRcdFx0aWYgKHR5cGUgPT0gVk9DX1NZU1RFTSlcblx0XHRcdFx0c3lzdGVtU2V0dGluZ3MgPSBkYXRhO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR1c2VyU2V0dGluZ3MgPSBkYXRhO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyByZXNvdXJjZSB2b2NhYnVsYXJ5IGJ5IGl0cyBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVm9jYWJ1bGFyeSBuYW1lICgnc3lzdGVtJyBvciAndXNlcicpXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldFZvY2FidWxhcnk6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiBuYW1lID09IFZPQ19TWVNURU0gPyBzeXN0ZW1TZXR0aW5ncyA6IHVzZXJTZXR0aW5ncztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcmVzb3VyY2UgKGFiYnJldmlhdGlvbiwgc25pcHBldCwgZXRjLikgbWF0Y2hlZCBmb3IgcGFzc2VkIFxuXHRcdCAqIGFiYnJldmlhdGlvblxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldE1hdGNoZWRSZXNvdXJjZTogZnVuY3Rpb24obm9kZSwgc3ludGF4KSB7XG5cdFx0XHRyZXR1cm4gcmVzb2x2ZXJzLmV4ZWMobnVsbCwgXy50b0FycmF5KGFyZ3VtZW50cykpIFxuXHRcdFx0XHR8fCB0aGlzLmZpbmRTbmlwcGV0KHN5bnRheCwgbm9kZS5uYW1lKCkpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB2YXJpYWJsZSB2YWx1ZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuICh0aGlzLmdldFNlY3Rpb24oJ3ZhcmlhYmxlcycpIHx8IHt9KVtuYW1lXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIHJ1bnRpbWUgdmFyaWFibGUgaW4gdXNlciBzdG9yYWdlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVmFyaWFibGUgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBWYXJpYWJsZSB2YWx1ZVxuXHRcdCAqL1xuXHRcdHNldFZhcmlhYmxlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XG5cdFx0XHR2YXIgdm9jID0gdGhpcy5nZXRWb2NhYnVsYXJ5KCd1c2VyJykgfHwge307XG5cdFx0XHRpZiAoISgndmFyaWFibGVzJyBpbiB2b2MpKVxuXHRcdFx0XHR2b2MudmFyaWFibGVzID0ge307XG5cdFx0XHRcdFxuXHRcdFx0dm9jLnZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5zZXRWb2NhYnVsYXJ5KHZvYywgJ3VzZXInKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIHRoZXJlIGFyZSByZXNvdXJjZXMgZm9yIHNwZWNpZmllZCBzeW50YXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4XG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNTeW50YXg6IGZ1bmN0aW9uKHN5bnRheCkge1xuXHRcdFx0cmV0dXJuIHN5bnRheCBpbiB0aGlzLmdldFZvY2FidWxhcnkoVk9DX1VTRVIpIFxuXHRcdFx0XHR8fCBzeW50YXggaW4gdGhpcy5nZXRWb2NhYnVsYXJ5KFZPQ19TWVNURU0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIG5ldyBhYmJyZXZpYXRpb24gcmVzb2x2ZXIuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQWJicmV2aWF0aW9uIHJlc29sdmVyIHdoaWNoIHdpbGwgcmVjZWl2ZSBcblx0XHQgKiBhYmJyZXZpYXRpb24gYXMgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gcGFyc2VkIGFiYnJldmlhdGlvblxuXHRcdCAqIG9iamVjdCBpZiBhYmJyZXZpYXRpb24gaGFzIGhhbmRsZWQgc3VjY2Vzc2Z1bGx5LCA8Y29kZT5udWxsPC9jb2RlPlxuXHRcdCAqIG90aGVyd2lzZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgbGlzdCBhcyBkZXNjcmliZWQgaW4gXG5cdFx0ICoge0BsaW5rIEhhbmRsZXJMaXN0I2FkZCgpfSBtZXRob2Rcblx0XHQgKi9cblx0XHRhZGRSZXNvbHZlcjogZnVuY3Rpb24oZm4sIG9wdGlvbnMpIHtcblx0XHRcdHJlc29sdmVycy5hZGQoZm4sIG9wdGlvbnMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0cmVtb3ZlUmVzb2x2ZXI6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRyZXNvbHZlcnMucmVtb3ZlKGZuKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWN0dWFsIHNlY3Rpb24gZGF0YSwgbWVyZ2VkIGZyb20gYm90aFxuXHRcdCAqIHN5c3RlbSBhbmQgdXNlciBkYXRhXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU2VjdGlvbiBuYW1lIChzeW50YXgpXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IC4uLmFyZ3MgU3Vic2VjdGlvbnNcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdGdldFNlY3Rpb246IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdGlmICghbmFtZSlcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICghKG5hbWUgaW4gY2FjaGUpKSB7XG5cdFx0XHRcdGNhY2hlW25hbWVdID0gcmVxdWlyZSgndXRpbHMnKS5kZWVwTWVyZ2Uoe30sIHN5c3RlbVNldHRpbmdzW25hbWVdLCB1c2VyU2V0dGluZ3NbbmFtZV0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgZGF0YSA9IGNhY2hlW25hbWVdLCBzdWJzZWN0aW9ucyA9IF8ucmVzdChhcmd1bWVudHMpLCBrZXk7XG5cdFx0XHR3aGlsZSAoZGF0YSAmJiAoa2V5ID0gc3Vic2VjdGlvbnMuc2hpZnQoKSkpIHtcblx0XHRcdFx0aWYgKGtleSBpbiBkYXRhKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFba2V5XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGZvciBhIGl0ZW0gaW5zaWRlIHRvcCBsZXZlbCBzZWN0aW9ucyAoc3ludGF4ZXMpXG5cdFx0ICogd2l0aCByZXNwZWN0IG9mIGBleHRlbmRzYCBhdHRyaWJ1dGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdG9wU2VjdGlvbiBUb3Agc2VjdGlvbiBuYW1lIChzeW50YXgpXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN1YnNlY3Rpb24gSW5uZXIgc2VjdGlvbiBuYW1lXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRmaW5kSXRlbTogZnVuY3Rpb24odG9wU2VjdGlvbiwgc3Vic2VjdGlvbikge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmdldFNlY3Rpb24odG9wU2VjdGlvbik7XG5cdFx0XHR3aGlsZSAoZGF0YSkge1xuXHRcdFx0XHRpZiAoc3Vic2VjdGlvbiBpbiBkYXRhKVxuXHRcdFx0XHRcdHJldHVybiBkYXRhW3N1YnNlY3Rpb25dO1xuXHRcdFx0XHRcblx0XHRcdFx0ZGF0YSA9IHRoaXMuZ2V0U2VjdGlvbihkYXRhWydleHRlbmRzJ10pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgZm9yIGEgc25pcHBldCBkZWZpbml0aW9uIGluc2lkZSBzeW50YXggc2VjdGlvbi5cblx0XHQgKiBEZWZpbml0aW9uIGlzIHNlYXJjaGVkIGluc2lkZSBgc25pcHBldHNgIGFuZCBgYWJicmV2aWF0aW9uc2AgXG5cdFx0ICogc3Vic2VjdGlvbnMgIFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggVG9wLWxldmVsIHNlY3Rpb24gbmFtZSAoc3ludGF4KVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFNuaXBwZXQgbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0ZmluZFNuaXBwZXQ6IGZ1bmN0aW9uKHN5bnRheCwgbmFtZSwgbWVtbykge1xuXHRcdFx0aWYgKCFzeW50YXggfHwgIW5hbWUpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRtZW1vID0gbWVtbyB8fCBbXTtcblx0XHRcdFxuXHRcdFx0dmFyIG5hbWVzID0gW25hbWVdO1xuXHRcdFx0Ly8gY3JlYXRlIGF1dG9tYXRpYyBhbGlhc2VzIHRvIHByb3BlcnRpZXMgd2l0aCBjb2xvbnMsXG5cdFx0XHQvLyBlLmcuIHBvcy1hID09IHBvczphXG5cdFx0XHRpZiAofm5hbWUuaW5kZXhPZignLScpKVxuXHRcdFx0XHRuYW1lcy5wdXNoKG5hbWUucmVwbGFjZSgvXFwtL2csICc6JykpO1xuXHRcdFx0XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0U2VjdGlvbihzeW50YXgpLCBtYXRjaGVkSXRlbSA9IG51bGw7XG5cdFx0XHRfLmZpbmQoWydzbmlwcGV0cycsICdhYmJyZXZpYXRpb25zJ10sIGZ1bmN0aW9uKHNlY3Rpb25OYW1lKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gdGhpcy5nZXRTZWN0aW9uKHN5bnRheCwgc2VjdGlvbk5hbWUpO1xuXHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiBfLmZpbmQobmFtZXMsIGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhW25dKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlZEl0ZW0gPSBwYXJzZUl0ZW0obiwgZGF0YVtuXSwgc2VjdGlvbk5hbWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0bWVtby5wdXNoKHN5bnRheCk7XG5cdFx0XHRpZiAoIW1hdGNoZWRJdGVtICYmIGRhdGFbJ2V4dGVuZHMnXSAmJiAhXy5pbmNsdWRlKG1lbW8sIGRhdGFbJ2V4dGVuZHMnXSkpIHtcblx0XHRcdFx0Ly8gdHJ5IHRvIGZpbmQgaXRlbSBpbiBwYXJlbnQgc3ludGF4IHNlY3Rpb25cblx0XHRcdFx0cmV0dXJuIHRoaXMuZmluZFNuaXBwZXQoZGF0YVsnZXh0ZW5kcyddLCBuYW1lLCBtZW1vKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG1hdGNoZWRJdGVtO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgZnV6enkgc2VhcmNoIG9mIHNuaXBwZXQgZGVmaW5pdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggVG9wLWxldmVsIHNlY3Rpb24gbmFtZSAoc3ludGF4KVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFNuaXBwZXQgbmFtZVxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0ZnV6enlGaW5kU25pcHBldDogZnVuY3Rpb24oc3ludGF4LCBuYW1lLCBtaW5TY29yZSkge1xuXHRcdFx0bWluU2NvcmUgPSBtaW5TY29yZSB8fCAwLjM7XG5cdFx0XHRcblx0XHRcdHZhciBwYXlsb2FkID0gdGhpcy5nZXRBbGxTbmlwcGV0cyhzeW50YXgpO1xuXHRcdFx0dmFyIHNjID0gcmVxdWlyZSgnc3RyaW5nLXNjb3JlJyk7XG5cdFx0XHRcblx0XHRcdG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuXHRcdFx0dmFyIHNjb3JlcyA9IF8ubWFwKHBheWxvYWQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRrZXk6IGtleSxcblx0XHRcdFx0XHRzY29yZTogc2Muc2NvcmUodmFsdWUubmssIG5hbWUsIDAuMSlcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVzdWx0ID0gXy5sYXN0KF8uc29ydEJ5KHNjb3JlcywgJ3Njb3JlJykpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQuc2NvcmUgPj0gbWluU2NvcmUpIHtcblx0XHRcdFx0dmFyIGsgPSByZXN1bHQua2V5O1xuXHRcdFx0XHRyZXR1cm4gcGF5bG9hZFtrXS5wYXJzZWRWYWx1ZTtcbi8vXHRcdFx0XHRyZXR1cm4gcGFyc2VJdGVtKGssIHBheWxvYWRba10udmFsdWUsIHBheWxvYWRba10udHlwZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHBsYWluIGRpY3Rpb25hcnkgb2YgYWxsIGF2YWlsYWJsZSBhYmJyZXZpYXRpb25zIGFuZCBzbmlwcGV0c1xuXHRcdCAqIGZvciBzcGVjaWZpZWQgc3ludGF4IHdpdGggcmVzcGVjdCBvZiBpbmhlcml0YW5jZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldEFsbFNuaXBwZXRzOiBmdW5jdGlvbihzeW50YXgpIHtcblx0XHRcdHZhciBjYWNoZUtleSA9ICdhbGwtJyArIHN5bnRheDtcblx0XHRcdGlmICghY2FjaGVbY2FjaGVLZXldKSB7XG5cdFx0XHRcdHZhciBzdGFjayA9IFtdLCBzZWN0aW9uS2V5ID0gc3ludGF4O1xuXHRcdFx0XHR2YXIgbWVtbyA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdHZhciBzZWN0aW9uID0gdGhpcy5nZXRTZWN0aW9uKHNlY3Rpb25LZXkpO1xuXHRcdFx0XHRcdGlmICghc2VjdGlvbilcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdF8uZWFjaChbJ3NuaXBwZXRzJywgJ2FiYnJldmlhdGlvbnMnXSwgZnVuY3Rpb24oc2VjdGlvbk5hbWUpIHtcblx0XHRcdFx0XHRcdHZhciBzdGFja0l0ZW0gPSB7fTtcblx0XHRcdFx0XHRcdF8uZWFjaChzZWN0aW9uW3NlY3Rpb25OYW1lXSB8fCBudWxsLCBmdW5jdGlvbih2LCBrKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrSXRlbVtrXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRuazogbm9ybWFsaXplTmFtZShrKSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogdixcblx0XHRcdFx0XHRcdFx0XHRwYXJzZWRWYWx1ZTogcGFyc2VJdGVtKGssIHYsIHNlY3Rpb25OYW1lKSxcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBzZWN0aW9uTmFtZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tJdGVtKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRtZW1vLnB1c2goc2VjdGlvbktleSk7XG5cdFx0XHRcdFx0c2VjdGlvbktleSA9IHNlY3Rpb25bJ2V4dGVuZHMnXTtcblx0XHRcdFx0fSB3aGlsZSAoc2VjdGlvbktleSAmJiAhXy5pbmNsdWRlKG1lbW8sIHNlY3Rpb25LZXkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRjYWNoZVtjYWNoZUtleV0gPSBfLmV4dGVuZC5hcHBseShfLCBzdGFjay5yZXZlcnNlKCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogTW9kdWxlIGRlc2NyaWJlcyBhbmQgcGVyZm9ybXMgRW1tZXQgYWN0aW9ucy4gVGhlIGFjdGlvbnMgdGhlbXNlbHZlcyBhcmVcbiAqIGRlZmluZWQgaW4gPGk+YWN0aW9uczwvaT4gZm9sZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZGVmaW5lKCdhY3Rpb25zJywgZnVuY3Rpb24ocmVxdWlyZSwgXywgemMpIHtcblx0dmFyIGFjdGlvbnMgPSB7fTtcblx0XG5cdC8qKlxuXHQgKiDigJxIdW1hbml6ZXPigJ0gYWN0aW9uIG5hbWUsIG1ha2VzIGl0IG1vcmUgcmVhZGFibGUgZm9yIHBlb3BsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBY3Rpb24gbmFtZSAobGlrZSAnZXhwYW5kX2FiYnJldmlhdGlvbicpXG5cdCAqIEByZXR1cm4gSHVtYW5pemVkIG5hbWUgKGxpa2UgJ0V4cGFuZCBBYmJyZXZpYXRpb24nKVxuXHQgKi9cblx0ZnVuY3Rpb24gaHVtYW5pemVBY3Rpb25OYW1lKG5hbWUpIHtcblx0XHRyZXR1cm4gcmVxdWlyZSgndXRpbHMnKS50cmltKG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgXG5cdFx0XHQrIG5hbWUuc3Vic3RyaW5nKDEpLnJlcGxhY2UoL19bYS16XS9nLCBmdW5jdGlvbihzdHIpIHtcblx0XHRcdFx0cmV0dXJuICcgJyArIHN0ci5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pKTtcblx0fVxuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgbmV3IGFjdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEFjdGlvbiBuYW1lXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQWN0aW9uIGZ1bmN0aW9uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ3VzdG9tIGFjdGlvbiBvcHRpb25zOjxicj5cblx0XHQgKiA8Yj5sYWJlbDwvYj4gOiAoPGNvZGU+U3RyaW5nPC9jb2RlPikg4oCTIEh1bWFuLXJlYWRhYmxlIGFjdGlvbiBuYW1lLiBcblx0XHQgKiBNYXkgY29udGFpbiAnLycgc3ltYm9scyBhcyBzdWJtZW51IHNlcGFyYXRvcnM8YnI+XG5cdFx0ICogPGI+aGlkZGVuPC9iPiA6ICg8Y29kZT5Cb29sZWFuPC9jb2RlPikg4oCTIEluZGljYXRlcyB3aGV0aGVyIGFjdGlvblxuXHRcdCAqIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gbWVudSAoPGNvZGU+Z2V0TWVudSgpPC9jb2RlPiBtZXRob2QpXG5cdFx0ICogXG5cdFx0ICogQG1lbWJlck9mIGFjdGlvbnNcblx0XHQgKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKG5hbWUsIGZuLCBvcHRpb25zKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRpZiAoIW9wdGlvbnMubGFiZWwpIHtcblx0XHRcdFx0b3B0aW9ucy5sYWJlbCA9IGh1bWFuaXplQWN0aW9uTmFtZShuYW1lKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0YWN0aW9uc1tuYW1lXSA9IHtcblx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0Zm46IGZuLFxuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhY3Rpb24gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQWN0aW9uIG5hbWVcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIGFjdGlvbnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJ1bnMgRW1tZXQgYWN0aW9uLiBGb3IgbGlzdCBvZiBhdmFpbGFibGUgYWN0aW9ucyBhbmQgdGhlaXJcblx0XHQgKiBhcmd1bWVudHMgc2VlIDxpPmFjdGlvbnM8L2k+IGZvbGRlci5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBY3Rpb24gbmFtZSBcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzLiBJdCBtYXkgYmUgYXJyYXkgb2YgYXJndW1lbnRzXG5cdFx0ICogb3IgaW5saW5lIGFyZ3VtZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSA8Y29kZT5JRW1tZXRFZGl0b3I8L2NvZGU+IGluc3RhbmNlXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IFN0YXR1cyBvZiBwZXJmb3JtZWQgb3BlcmF0aW9uLCA8Y29kZT50cnVlPC9jb2RlPlxuXHRcdCAqIG1lYW5zIGFjdGlvbiB3YXMgcGVyZm9ybWVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGVtbWV0LnJlcXVpcmUoJ2FjdGlvbnMnKS5ydW4oJ2V4cGFuZF9hYmJyZXZpYXRpb24nLCBlZGl0b3IpOyAgXG5cdFx0ICogZW1tZXQucmVxdWlyZSgnYWN0aW9ucycpLnJ1bignd3JhcF93aXRoX2FiYnJldmlhdGlvbicsIFtlZGl0b3IsICdkaXYnXSk7ICBcblx0XHQgKi9cblx0XHRydW46IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcblx0XHRcdGlmICghXy5pc0FycmF5KGFyZ3MpKSB7XG5cdFx0XHRcdGFyZ3MgPSBfLnJlc3QoYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGFjdGlvbiA9IHRoaXMuZ2V0KG5hbWUpO1xuXHRcdFx0aWYgKGFjdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmZuLmFwcGx5KGVtbWV0LCBhcmdzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVtbWV0LmxvZygnQWN0aW9uIFwiJXNcIiBpcyBub3QgZGVmaW5lZCcsIG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIGFjdGlvbnMgYXMgb2JqZWN0XG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXRBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGFjdGlvbnM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIGFjdGlvbnMgYXMgYXJyYXlcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0TGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gXy52YWx1ZXModGhpcy5nZXRBbGwoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFjdGlvbnMgbGlzdCBhcyBzdHJ1Y3R1cmVkIG1lbnUuIElmIGFjdGlvbiBoYXMgPGk+bGFiZWw8L2k+LFxuXHRcdCAqIGl0IHdpbGwgYmUgc3BsaXR0ZWQgYnkgJy8nIHN5bWJvbCBpbnRvIHN1Ym1lbnVzIChmb3IgZXhhbXBsZTogXG5cdFx0ICogQ1NTL1JlZmxlY3QgVmFsdWUpIGFuZCBncm91cGVkIHdpdGggb3RoZXIgaXRlbXNcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBza2lwQWN0aW9ucyBMaXN0IG9mIGFjdGlvbiBpZGVudGlmaWVycyB0aGF0IHNob3VsZCBiZSBcblx0XHQgKiBza2lwcGVkIGZyb20gbWVudVxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKi9cblx0XHRnZXRNZW51OiBmdW5jdGlvbihza2lwQWN0aW9ucykge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0c2tpcEFjdGlvbnMgPSBza2lwQWN0aW9ucyB8fCBbXTtcblx0XHRcdF8uZWFjaCh0aGlzLmdldExpc3QoKSwgZnVuY3Rpb24oYWN0aW9uKSB7XG5cdFx0XHRcdGlmIChhY3Rpb24ub3B0aW9ucy5oaWRkZW4gfHwgXy5pbmNsdWRlKHNraXBBY3Rpb25zLCBhY3Rpb24ubmFtZSkpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGFjdGlvbk5hbWUgPSBodW1hbml6ZUFjdGlvbk5hbWUoYWN0aW9uLm5hbWUpO1xuXHRcdFx0XHR2YXIgY3R4ID0gcmVzdWx0O1xuXHRcdFx0XHRpZiAoYWN0aW9uLm9wdGlvbnMubGFiZWwpIHtcblx0XHRcdFx0XHR2YXIgcGFydHMgPSBhY3Rpb24ub3B0aW9ucy5sYWJlbC5zcGxpdCgnLycpO1xuXHRcdFx0XHRcdGFjdGlvbk5hbWUgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBjcmVhdGUgc3VibWVudXMsIGlmIG5lZWRlZFxuXHRcdFx0XHRcdHZhciBtZW51TmFtZSwgc3VibWVudTtcblx0XHRcdFx0XHR3aGlsZSAobWVudU5hbWUgPSBwYXJ0cy5zaGlmdCgpKSB7XG5cdFx0XHRcdFx0XHRzdWJtZW51ID0gXy5maW5kKGN0eCwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaXRlbS50eXBlID09ICdzdWJtZW51JyAmJiBpdGVtLm5hbWUgPT0gbWVudU5hbWU7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCFzdWJtZW51KSB7XG5cdFx0XHRcdFx0XHRcdHN1Ym1lbnUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogbWVudU5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogJ3N1Ym1lbnUnLFxuXHRcdFx0XHRcdFx0XHRcdGl0ZW1zOiBbXVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRjdHgucHVzaChzdWJtZW51KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y3R4ID0gc3VibWVudS5pdGVtcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGN0eC5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiAnYWN0aW9uJyxcblx0XHRcdFx0XHRuYW1lOiBhY3Rpb24ubmFtZSxcblx0XHRcdFx0XHRsYWJlbDogYWN0aW9uTmFtZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFjdGlvbiBuYW1lIGFzc29jaWF0ZWQgd2l0aCBtZW51IGl0ZW0gdGl0bGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldEFjdGlvbk5hbWVGb3JNZW51VGl0bGU6IGZ1bmN0aW9uKHRpdGxlLCBtZW51KSB7XG5cdFx0XHR2YXIgaXRlbSA9IG51bGw7XG5cdFx0XHRfLmZpbmQobWVudSB8fCB0aGlzLmdldE1lbnUoKSwgZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdGlmICh2YWwudHlwZSA9PSAnYWN0aW9uJykge1xuXHRcdFx0XHRcdGlmICh2YWwubGFiZWwgPT0gdGl0bGUgfHwgdmFsLm5hbWUgPT0gdGl0bGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtID0gdmFsLm5hbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtID0gdGhpcy5nZXRBY3Rpb25OYW1lRm9yTWVudVRpdGxlKHRpdGxlLCB2YWwuaXRlbXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGl0ZW0gfHwgbnVsbDtcblx0XHR9XG5cdH07XG59KTsvKipcbiAqIE91dHB1dCBwcm9maWxlIG1vZHVsZS5cbiAqIFByb2ZpbGUgZGVmaW5lcyBob3cgWEhUTUwgb3V0cHV0IGRhdGEgc2hvdWxkIGxvb2sgbGlrZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmRlZmluZSgncHJvZmlsZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIHByb2ZpbGVzID0ge307XG5cdFxuXHR2YXIgZGVmYXVsdFByb2ZpbGUgPSB7XG5cdFx0dGFnX2Nhc2U6ICdhc2lzJyxcblx0XHRhdHRyX2Nhc2U6ICdhc2lzJyxcblx0XHRhdHRyX3F1b3RlczogJ2RvdWJsZScsXG5cdFx0XG5cdFx0Ly8gZWFjaCB0YWcgb24gbmV3IGxpbmVcblx0XHR0YWdfbmw6ICdkZWNpZGUnLFxuXHRcdFxuXHRcdC8vIHdpdGggdGFnX25sID09PSB0cnVlLCBkZWZpbmVzIGlmIGxlYWYgbm9kZSAoZS5nLiBub2RlIHdpdGggbm8gY2hpbGRyZW4pXG5cdFx0Ly8gc2hvdWxkIGhhdmUgZm9ybWF0dGVkIGxpbmUgYnJlYWtzXG5cdFx0dGFnX25sX2xlYWY6IGZhbHNlLFxuXHRcdFxuXHRcdHBsYWNlX2N1cnNvcjogdHJ1ZSxcblx0XHRcblx0XHQvLyBpbmRlbnQgdGFnc1xuXHRcdGluZGVudDogdHJ1ZSxcblx0XHRcblx0XHQvLyBob3cgbWFueSBpbmxpbmUgZWxlbWVudHMgc2hvdWxkIGJlIHRvIGZvcmNlIGxpbmUgYnJlYWsgXG5cdFx0Ly8gKHNldCB0byAwIHRvIGRpc2FibGUpXG5cdFx0aW5saW5lX2JyZWFrOiAzLFxuXHRcdFxuXHRcdC8vIHVzZSBzZWxmLWNsb3Npbmcgc3R5bGUgZm9yIHdyaXRpbmcgZW1wdHkgZWxlbWVudHMsIGUuZy4gPGJyIC8+IG9yIDxicj5cblx0XHRzZWxmX2Nsb3NpbmdfdGFnOiAneGh0bWwnLFxuXHRcdFxuXHRcdC8vIFByb2ZpbGUtbGV2ZWwgb3V0cHV0IGZpbHRlcnMsIHJlLWRlZmluZXMgc3ludGF4IGZpbHRlcnMgXG5cdFx0ZmlsdGVyczogJycsXG5cdFx0XG5cdFx0Ly8gQWRkaXRpb25hbCBmaWx0ZXJzIGFwcGxpZWQgdG8gYWJicmV2aWF0aW9uLlxuXHRcdC8vIFVubGlrZSBcImZpbHRlcnNcIiwgdGhpcyBwcmVmZXJlbmNlIGRvZXNuJ3Qgb3ZlcnJpZGUgZGVmYXVsdCBmaWx0ZXJzXG5cdFx0Ly8gYnV0IGFkZCB0aGUgaW5zdGVhZCBldmVyeSB0aW1lIGdpdmVuIHByb2ZpbGUgaXMgY2hvc2VuXG5cdFx0ZXh0cmFGaWx0ZXJzOiAnJ1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAdHlwZSBPdXRwdXRQcm9maWxlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBPdXRwdXRQcm9maWxlKG9wdGlvbnMpIHtcblx0XHRfLmV4dGVuZCh0aGlzLCBkZWZhdWx0UHJvZmlsZSwgb3B0aW9ucyk7XG5cdH1cblx0XG5cdE91dHB1dFByb2ZpbGUucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybXMgdGFnIG5hbWUgY2FzZSBkZXBlbmRpbmcgb24gY3VycmVudCBwcm9maWxlIHNldHRpbmdzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU3RyaW5nIHRvIHRyYW5zZm9ybVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGFnTmFtZTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ0Nhc2UobmFtZSwgdGhpcy50YWdfY2FzZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUcmFuc2Zvcm1zIGF0dHJpYnV0ZSBuYW1lIGNhc2UgZGVwZW5kaW5nIG9uIGN1cnJlbnQgcHJvZmlsZSBzZXR0aW5ncyBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBTdHJpbmcgdG8gdHJhbnNmb3JtXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRhdHRyaWJ1dGVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nQ2FzZShuYW1lLCB0aGlzLmF0dHJfY2FzZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHF1b3RlIGNoYXJhY3RlciBmb3IgY3VycmVudCBwcm9maWxlXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRhdHRyaWJ1dGVRdW90ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyX3F1b3RlcyA9PSAnc2luZ2xlJyA/IFwiJ1wiIDogJ1wiJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc2VsZi1jbG9zaW5nIHRhZyBzeW1ib2wgZm9yIGN1cnJlbnQgcHJvZmlsZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbVxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0c2VsZkNsb3Npbmc6IGZ1bmN0aW9uKHBhcmFtKSB7XG5cdFx0XHRpZiAodGhpcy5zZWxmX2Nsb3NpbmdfdGFnID09ICd4aHRtbCcpXG5cdFx0XHRcdHJldHVybiAnIC8nO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5zZWxmX2Nsb3NpbmdfdGFnID09PSB0cnVlKVxuXHRcdFx0XHRyZXR1cm4gJy8nO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGN1cnNvciB0b2tlbiBiYXNlZCBvbiBjdXJyZW50IHByb2ZpbGUgc2V0dGluZ3Ncblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGN1cnNvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGFjZV9jdXJzb3IgPyByZXF1aXJlKCd1dGlscycpLmdldENhcmV0UGxhY2Vob2xkZXIoKSA6ICcnO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBzdHJpbmcgY2FzZSBkZXBlbmRpbmcgb24gXG5cdCAqIDxjb2RlPmNhc2VWYWx1ZTwvY29kZT4gXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyYW5zZm9ybVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2FzZVZhbHVlIENhc2UgdmFsdWU6IGNhbiBiZSA8aT5sb3dlcjwvaT4sIFxuXHQgKiA8aT51cHBlcjwvaT4gYW5kIDxpPmxlYXZlPC9pPlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3RyaW5nQ2FzZShzdHIsIGNhc2VWYWx1ZSkge1xuXHRcdHN3aXRjaCAoU3RyaW5nKGNhc2VWYWx1ZSB8fCAnJykudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0Y2FzZSAnbG93ZXInOlxuXHRcdFx0XHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjYXNlICd1cHBlcic6XG5cdFx0XHRcdHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgbmV3IG91dHB1dCBwcm9maWxlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByb2ZpbGUgbmFtZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQcm9maWxlIG9wdGlvbnNcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2ZpbGUobmFtZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiBwcm9maWxlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gbmV3IE91dHB1dFByb2ZpbGUob3B0aW9ucyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRQcm9maWxlcygpIHtcblx0XHRjcmVhdGVQcm9maWxlKCd4aHRtbCcpO1xuXHRcdGNyZWF0ZVByb2ZpbGUoJ2h0bWwnLCB7c2VsZl9jbG9zaW5nX3RhZzogZmFsc2V9KTtcblx0XHRjcmVhdGVQcm9maWxlKCd4bWwnLCB7c2VsZl9jbG9zaW5nX3RhZzogdHJ1ZSwgdGFnX25sOiB0cnVlfSk7XG5cdFx0Y3JlYXRlUHJvZmlsZSgncGxhaW4nLCB7dGFnX25sOiBmYWxzZSwgaW5kZW50OiBmYWxzZSwgcGxhY2VfY3Vyc29yOiBmYWxzZX0pO1xuXHRcdGNyZWF0ZVByb2ZpbGUoJ2xpbmUnLCB7dGFnX25sOiBmYWxzZSwgaW5kZW50OiBmYWxzZSwgZXh0cmFGaWx0ZXJzOiAncyd9KTtcblx0fVxuXHRcblx0Y3JlYXRlRGVmYXVsdFByb2ZpbGVzKCk7XG5cdFxuXHRyZXR1cm4gIHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIG5ldyBvdXRwdXQgcHJvZmlsZSBhbmQgYWRkcyBpdCBpbnRvIGludGVybmFsIGRpY3Rpb25hcnlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9maWxlIG5hbWVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQcm9maWxlIG9wdGlvbnNcblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQucHJvZmlsZVxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBwcm9maWxlXG5cdFx0ICovXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKVxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlUHJvZmlsZShuYW1lLCBvcHRpb25zKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0Ly8gY3JlYXRlIHByb2ZpbGUgb2JqZWN0IG9ubHlcblx0XHRcdFx0cmV0dXJuIG5ldyBPdXRwdXRQcm9maWxlKF8uZGVmYXVsdHMobmFtZSB8fCB7fSwgZGVmYXVsdFByb2ZpbGUpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcHJvZmlsZSBieSBpdHMgbmFtZS4gSWYgcHJvZmlsZSB3YXNuJ3QgZm91bmQsIHJldHVybnNcblx0XHQgKiAncGxhaW4nIHByb2ZpbGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9maWxlIG5hbWUuIE1pZ2h0IGJlIHByb2ZpbGUgaXRzZWxmXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheC4gT3B0aW9uYWwuIEN1cnJlbnQgZWRpdG9yIHN5bnRheC4gSWYgZGVmaW5lZCxcblx0XHQgKiBwcm9maWxlIGlzIHNlYXJjaGVkIGluIHJlc291cmNlcyBmaXJzdCwgdGhlbiBpbiBwcmVkZWZpbmVkIHByb2ZpbGVzXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUsIHN5bnRheCkge1xuXHRcdFx0aWYgKCFuYW1lICYmIHN5bnRheCkge1xuXHRcdFx0XHQvLyBzZWFyY2ggaW4gdXNlciByZXNvdXJjZXMgZmlyc3Rcblx0XHRcdFx0dmFyIHByb2ZpbGUgPSByZXF1aXJlKCdyZXNvdXJjZXMnKS5maW5kSXRlbShzeW50YXgsICdwcm9maWxlJyk7XG5cdFx0XHRcdGlmIChwcm9maWxlKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHByb2ZpbGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBwcm9maWxlcy5wbGFpbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG5hbWUgaW5zdGFuY2VvZiBPdXRwdXRQcm9maWxlKSB7XG5cdFx0XHRcdHJldHVybiBuYW1lO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoXy5pc1N0cmluZyhuYW1lKSAmJiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gcHJvZmlsZXMpIHtcblx0XHRcdFx0cmV0dXJuIHByb2ZpbGVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZShuYW1lKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERlbGV0ZXMgcHJvZmlsZSB3aXRoIHNwZWNpZmllZCBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJvZmlsZSBuYW1lXG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRuYW1lID0gKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAobmFtZSBpbiBwcm9maWxlcylcblx0XHRcdFx0ZGVsZXRlIHByb2ZpbGVzW25hbWVdO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVzZXRzIGFsbCB1c2VyLWRlZmluZWQgcHJvZmlsZXNcblx0XHQgKi9cblx0XHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRwcm9maWxlcyA9IHt9O1xuXHRcdFx0Y3JlYXRlRGVmYXVsdFByb2ZpbGVzKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBzdHJpbmcgY2FzZSBkZXBlbmRpbmcgb24gXG5cdFx0ICogPGNvZGU+Y2FzZVZhbHVlPC9jb2RlPiBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byB0cmFuc2Zvcm1cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY2FzZVZhbHVlIENhc2UgdmFsdWU6IGNhbiBiZSA8aT5sb3dlcjwvaT4sIFxuXHRcdCAqIDxpPnVwcGVyPC9pPiBhbmQgPGk+bGVhdmU8L2k+XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRzdHJpbmdDYXNlOiBzdHJpbmdDYXNlXG5cdH07XG59KTsvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHVzZWQgdG8gcHJlcGFyZSB0ZXh0IGZvciBwYXN0aW5nIGludG8gYmFjay1lbmQgZWRpdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pIDxodHRwOi8vY2hpa3V5b25vay5ydT5cbiAqL1xuZW1tZXQuZGVmaW5lKCdlZGl0b3JVdGlscycsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0cmV0dXJuICB7XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgY3Vyc29yIGlzIHBsYWNlZCBpbnNpZGUgWEhUTUwgdGFnXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGh0bWwgQ29udGVudHMgb2YgdGhlIGRvY3VtZW50XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGNhcmV0UG9zIEN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaW5zaWRlIHRhZ1xuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNJbnNpZGVUYWc6IGZ1bmN0aW9uKGh0bWwsIGNhcmV0UG9zKSB7XG5cdFx0XHR2YXIgcmVUYWcgPSAvXjxcXC8/XFx3W1xcd1xcOlxcLV0qLio/Pi87XG5cdFx0XHRcblx0XHRcdC8vIHNlYXJjaCBsZWZ0IHRvIGZpbmQgb3BlbmluZyBicmFjZVxuXHRcdFx0dmFyIHBvcyA9IGNhcmV0UG9zO1xuXHRcdFx0d2hpbGUgKHBvcyA+IC0xKSB7XG5cdFx0XHRcdGlmIChodG1sLmNoYXJBdChwb3MpID09ICc8JykgXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdHBvcy0tO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocG9zICE9IC0xKSB7XG5cdFx0XHRcdHZhciBtID0gcmVUYWcuZXhlYyhodG1sLnN1YnN0cmluZyhwb3MpKTtcblx0XHRcdFx0aWYgKG0gJiYgY2FyZXRQb3MgPiBwb3MgJiYgY2FyZXRQb3MgPCBwb3MgKyBtWzBdLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2FuaXRpemVzIGluY29taW5nIGVkaXRvciBkYXRhIGFuZCBwcm92aWRlcyBkZWZhdWx0IHZhbHVlcyBmb3Jcblx0XHQgKiBvdXRwdXQtc3BlY2lmaWMgaW5mb1xuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGVcblx0XHQgKi9cblx0XHRvdXRwdXRJbmZvOiBmdW5jdGlvbihlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSkge1xuXHRcdFx0Ly8gbW9zdCBvZiB0aGlzIGNvZGUgbWFrZXMgc2Vuc2UgZm9yIEphdmEvUmhpbm8gZW52aXJvbm1lbnRcblx0XHRcdC8vIGJlY2F1c2Ugc3RyaW5nIHRoYXQgY29tZXMgZnJvbSBKYXZhIGFyZSBub3QgYWN0dWFsbHkgSlMgc3RyaW5nXG5cdFx0XHQvLyBidXQgSmF2YSBTdHJpbmcgb2JqZWN0IHNvIHRoZSBoYXZlIHRvIGJlIGV4cGxpY2l0bHkgY29udmVydGVkXG5cdFx0XHQvLyB0byBuYXRpdmUgc3RyaW5nXG5cdFx0XHRwcm9maWxlID0gcHJvZmlsZSB8fCBlZGl0b3IuZ2V0UHJvZmlsZU5hbWUoKTtcblx0XHRcdHJldHVybiAge1xuXHRcdFx0XHQvKiogQG1lbWJlck9mIG91dHB1dEluZm8gKi9cblx0XHRcdFx0c3ludGF4OiBTdHJpbmcoc3ludGF4IHx8IGVkaXRvci5nZXRTeW50YXgoKSksXG5cdFx0XHRcdHByb2ZpbGU6IHByb2ZpbGUgfHwgbnVsbCxcblx0XHRcdFx0Y29udGVudDogU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVW5pbmRlbnQgY29udGVudCwgdGh1cyBwcmVwYXJpbmcgdGV4dCBmb3IgdGFnIHdyYXBwaW5nXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBFZGl0b3IgaW5zdGFuY2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHR1bmluZGVudDogZnVuY3Rpb24oZWRpdG9yLCB0ZXh0KSB7XG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgndXRpbHMnKS51bmluZGVudFN0cmluZyh0ZXh0LCB0aGlzLmdldEN1cnJlbnRMaW5lUGFkZGluZyhlZGl0b3IpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgcGFkZGluZyBvZiBjdXJyZW50IGVkaXRvcidzIGxpbmVcblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gRWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldEN1cnJlbnRMaW5lUGFkZGluZzogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgndXRpbHMnKS5nZXRMaW5lUGFkZGluZyhlZGl0b3IuZ2V0Q3VycmVudExpbmUoKSk7XG5cdFx0fVxuXHR9O1xufSk7XG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kcyBmb3IgRW1tZXQgYWN0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKSA8aHR0cDovL2NoaWt1eW9ub2sucnU+XG4gKi9cbmVtbWV0LmRlZmluZSgnYWN0aW9uVXRpbHMnLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHJldHVybiB7XG5cdFx0bWltZVR5cGVzOiB7XG5cdFx0XHQnZ2lmJyA6ICdpbWFnZS9naWYnLFxuXHRcdFx0J3BuZycgOiAnaW1hZ2UvcG5nJyxcblx0XHRcdCdqcGcnIDogJ2ltYWdlL2pwZWcnLFxuXHRcdFx0J2pwZWcnOiAnaW1hZ2UvanBlZycsXG5cdFx0XHQnc3ZnJyA6ICdpbWFnZS9zdmcreG1sJyxcblx0XHRcdCdodG1sJzogJ3RleHQvaHRtbCcsXG5cdFx0XHQnaHRtJyA6ICd0ZXh0L2h0bWwnXG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBhYmJyZXZpYXRpb25zIGZyb20gdGV4dCBzdHJlYW0sIHN0YXJ0aW5nIGZyb20gdGhlIGVuZFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IEFiYnJldmlhdGlvbiBvciBlbXB0eSBzdHJpbmdcblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQuYWN0aW9uVXRpbHNcblx0XHQgKi9cblx0XHRleHRyYWN0QWJicmV2aWF0aW9uOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHZhciBjdXJPZmZzZXQgPSBzdHIubGVuZ3RoO1xuXHRcdFx0dmFyIHN0YXJ0SW5kZXggPSAtMTtcblx0XHRcdHZhciBncm91cENvdW50ID0gMDtcblx0XHRcdHZhciBicmFjZUNvdW50ID0gMDtcblx0XHRcdHZhciB0ZXh0Q291bnQgPSAwO1xuXHRcdFx0XG5cdFx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdFx0dmFyIHBhcnNlciA9IHJlcXVpcmUoJ2FiYnJldmlhdGlvblBhcnNlcicpO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRjdXJPZmZzZXQtLTtcblx0XHRcdFx0aWYgKGN1ck9mZnNldCA8IDApIHtcblx0XHRcdFx0XHQvLyBtb3ZlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG5cdFx0XHRcdFx0c3RhcnRJbmRleCA9IDA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHZhciBjaCA9IHN0ci5jaGFyQXQoY3VyT2Zmc2V0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaCA9PSAnXScpIHtcblx0XHRcdFx0XHRicmFjZUNvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJ1snKSB7XG5cdFx0XHRcdFx0aWYgKCFicmFjZUNvdW50KSB7IC8vIHVuZXhwZWN0ZWQgYnJhY2Vcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBjdXJPZmZzZXQgKyAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyYWNlQ291bnQtLTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnfScpIHtcblx0XHRcdFx0XHR0ZXh0Q291bnQrKztcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAneycpIHtcblx0XHRcdFx0XHRpZiAoIXRleHRDb3VudCkgeyAvLyB1bmV4cGVjdGVkIGJyYWNlXG5cdFx0XHRcdFx0XHRzdGFydEluZGV4ID0gY3VyT2Zmc2V0ICsgMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0Q291bnQtLTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnKScpIHtcblx0XHRcdFx0XHRncm91cENvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJygnKSB7XG5cdFx0XHRcdFx0aWYgKCFncm91cENvdW50KSB7IC8vIHVuZXhwZWN0ZWQgYnJhY2Vcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBjdXJPZmZzZXQgKyAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdyb3VwQ291bnQtLTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoYnJhY2VDb3VudCB8fCB0ZXh0Q291bnQpIFxuXHRcdFx0XHRcdFx0Ly8gcmVzcGVjdCBhbGwgY2hhcmFjdGVycyBpbnNpZGUgYXR0cmlidXRlIHNldHMgb3IgdGV4dCBub2Rlc1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIXBhcnNlci5pc0FsbG93ZWRDaGFyKGNoKSB8fCAoY2ggPT0gJz4nICYmIHV0aWxzLmVuZHNXaXRoVGFnKHN0ci5zdWJzdHJpbmcoMCwgY3VyT2Zmc2V0ICsgMSkpKSkge1xuXHRcdFx0XHRcdFx0Ly8gZm91bmQgc3RvcCBzeW1ib2xcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBjdXJPZmZzZXQgKyAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzdGFydEluZGV4ICE9IC0xICYmICF0ZXh0Q291bnQgJiYgIWJyYWNlQ291bnQgJiYgIWdyb3VwQ291bnQpIFxuXHRcdFx0XHQvLyBmb3VuZCBzb21ldGhpbmcsIHJlbW92ZSBzb21lIGludmFsaWQgc3ltYm9scyBmcm9tIHRoZSBcblx0XHRcdFx0Ly8gYmVnaW5uaW5nIGFuZCByZXR1cm4gYWJicmV2aWF0aW9uXG5cdFx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLnJlcGxhY2UoL15bXFwqXFwrXFw+XFxeXSsvLCAnJyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJldHVybiAnJztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgaW1hZ2Ugc2l6ZSBmcm9tIGltYWdlIGJ5dGUgc3RyZWFtLlxuXHRcdCAqIEBhdXRob3IgaHR0cDovL3JvbWVkYS5vcmcvcmVQdWJsaXNoL1xuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJlYW0gSW1hZ2UgYnl0ZSBzdHJlYW0gKHVzZSA8Y29kZT5JRW1tZXRGaWxlLnJlYWQoKTwvY29kZT4pXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCA8Y29kZT53aWR0aDwvY29kZT4gYW5kIDxjb2RlPmhlaWdodDwvY29kZT4gcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdGdldEltYWdlU2l6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG5cdFx0XHR2YXIgcG5nTWFnaWNOdW0gPSBcIlxcMjExUE5HXFxyXFxuXFwwMzJcXG5cIixcblx0XHRcdFx0anBnTWFnaWNOdW0gPSBcIlxcMzc3XFwzMzBcIixcblx0XHRcdFx0Z2lmTWFnaWNOdW0gPSBcIkdJRjhcIixcblx0XHRcdFx0bmV4dEJ5dGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyZWFtLmNoYXJDb2RlQXQocG9zKyspO1xuXHRcdFx0XHR9O1xuXHRcdFxuXHRcdFx0aWYgKHN0cmVhbS5zdWJzdHIoMCwgOCkgPT09IHBuZ01hZ2ljTnVtKSB7XG5cdFx0XHRcdC8vIFBORy4gRWFzeSBwZWFzeS5cblx0XHRcdFx0dmFyIHBvcyA9IHN0cmVhbS5pbmRleE9mKCdJSERSJykgKyA0O1xuXHRcdFx0XG5cdFx0XHRcdHJldHVybiB7IHdpZHRoOiAgKG5leHRCeXRlKCkgPDwgMjQpIHwgKG5leHRCeXRlKCkgPDwgMTYpIHxcblx0XHRcdFx0XHRcdFx0XHQgKG5leHRCeXRlKCkgPDwgIDgpIHwgbmV4dEJ5dGUoKSxcblx0XHRcdFx0XHRcdCBoZWlnaHQ6IChuZXh0Qnl0ZSgpIDw8IDI0KSB8IChuZXh0Qnl0ZSgpIDw8IDE2KSB8XG5cdFx0XHRcdFx0XHRcdFx0IChuZXh0Qnl0ZSgpIDw8ICA4KSB8IG5leHRCeXRlKCkgfTtcblx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmIChzdHJlYW0uc3Vic3RyKDAsIDQpID09PSBnaWZNYWdpY051bSkge1xuXHRcdFx0XHRwb3MgPSA2O1xuXHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0d2lkdGg6ICBuZXh0Qnl0ZSgpIHwgKG5leHRCeXRlKCkgPDwgOCksXG5cdFx0XHRcdFx0aGVpZ2h0OiBuZXh0Qnl0ZSgpIHwgKG5leHRCeXRlKCkgPDwgOClcblx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmIChzdHJlYW0uc3Vic3RyKDAsIDIpID09PSBqcGdNYWdpY051bSkge1xuXHRcdFx0XHRwb3MgPSAyO1xuXHRcdFx0XG5cdFx0XHRcdHZhciBsID0gc3RyZWFtLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKHBvcyA8IGwpIHtcblx0XHRcdFx0XHRpZiAobmV4dEJ5dGUoKSAhPSAweEZGKSByZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBtYXJrZXIgPSBuZXh0Qnl0ZSgpO1xuXHRcdFx0XHRcdGlmIChtYXJrZXIgPT0gMHhEQSkgYnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBzaXplID0gKG5leHRCeXRlKCkgPDwgOCkgfCBuZXh0Qnl0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobWFya2VyID49IDB4QzAgJiYgbWFya2VyIDw9IDB4Q0YgJiYgIShtYXJrZXIgJiAweDQpICYmICEobWFya2VyICYgMHg4KSkge1xuXHRcdFx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBoZWlnaHQ6ICAobmV4dEJ5dGUoKSA8PCA4KSB8IG5leHRCeXRlKCksXG5cdFx0XHRcdFx0XHRcdFx0IHdpZHRoOiAobmV4dEJ5dGUoKSA8PCA4KSB8IG5leHRCeXRlKCkgfTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvcyArPSBzaXplIC0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENhcHR1cmVzIGNvbnRleHQgWEhUTUwgZWxlbWVudCBmcm9tIGVkaXRvciB1bmRlciBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuXHRcdCAqIFRoaXMgbm9kZSBjYW4gYmUgdXNlZCBhcyBhIGhlbHBlciBmb3IgYWJicmV2aWF0aW9uIGV4dHJhY3Rpb25cblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRjYXB0dXJlQ29udGV4dDogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHR2YXIgYWxsb3dlZFN5bnRheGVzID0geydodG1sJzogMSwgJ3htbCc6IDEsICd4c2wnOiAxfTtcblx0XHRcdHZhciBzeW50YXggPSBTdHJpbmcoZWRpdG9yLmdldFN5bnRheCgpKTtcblx0XHRcdGlmIChzeW50YXggaW4gYWxsb3dlZFN5bnRheGVzKSB7XG5cdFx0XHRcdHZhciBjb250ZW50ID0gU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpO1xuXHRcdFx0XHR2YXIgdGFnID0gcmVxdWlyZSgnaHRtbE1hdGNoZXInKS5maW5kKGNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0YWcgJiYgdGFnLnR5cGUgPT0gJ3RhZycpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnRUYWcgPSB0YWcub3Blbjtcblx0XHRcdFx0XHR2YXIgY29udGV4dE5vZGUgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiBzdGFydFRhZy5uYW1lLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHBhcnNlIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHR2YXIgdGFnVHJlZSA9IHJlcXVpcmUoJ3htbEVkaXRUcmVlJykucGFyc2Uoc3RhcnRUYWcucmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnQpKTtcblx0XHRcdFx0XHRpZiAodGFnVHJlZSkge1xuXHRcdFx0XHRcdFx0Y29udGV4dE5vZGUuYXR0cmlidXRlcyA9IF8ubWFwKHRhZ1RyZWUuZ2V0QWxsKCksIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBpdGVtLm5hbWUoKSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogaXRlbS52YWx1ZSgpXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRleHROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZCBleHByZXNzaW9uIGJvdW5kcyBpbiBjdXJyZW50IGVkaXRvciBhdCBjYXJldCBwb3NpdGlvbi4gXG5cdFx0ICogT24gZWFjaCBjaGFyYWN0ZXIgYSA8Y29kZT5mbjwvY29kZT4gZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYW5kIG11c3QgXG5cdFx0ICogcmV0dXJuIDxjb2RlPnRydWU8L2NvZGU+IGlmIGN1cnJlbnQgY2hhcmFjdGVyIG1lZXRzIHJlcXVpcmVtZW50cywgXG5cdFx0ICogPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZVxuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggY2hhcmFjdGVyIG9mIGV4cHJlc3Npb25cblx0XHQgKiBAcmV0dXJuIHtSYW5nZX1cblx0XHQgKi9cblx0XHRmaW5kRXhwcmVzc2lvbkJvdW5kczogZnVuY3Rpb24oZWRpdG9yLCBmbikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0XHR2YXIgaWwgPSBjb250ZW50Lmxlbmd0aDtcblx0XHRcdHZhciBleHByU3RhcnQgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSAtIDE7XG5cdFx0XHR2YXIgZXhwckVuZCA9IGV4cHJTdGFydCArIDE7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gc3RhcnQgYnkgc2VhcmNoaW5nIGxlZnRcblx0XHRcdHdoaWxlIChleHByU3RhcnQgPj0gMCAmJiBmbihjb250ZW50LmNoYXJBdChleHByU3RhcnQpLCBleHByU3RhcnQsIGNvbnRlbnQpKSBleHByU3RhcnQtLTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhlbiBzZWFyY2ggcmlnaHRcblx0XHRcdHdoaWxlIChleHByRW5kIDwgaWwgJiYgZm4oY29udGVudC5jaGFyQXQoZXhwckVuZCksIGV4cHJFbmQsIGNvbnRlbnQpKSBleHByRW5kKys7XG5cdFx0XHRcblx0XHRcdGlmIChleHByRW5kID4gZXhwclN0YXJ0KSB7XG5cdFx0XHRcdHJldHVybiByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShbKytleHByU3RhcnQsIGV4cHJFbmRdKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGNvbXBvdW5kVXBkYXRlOiBmdW5jdGlvbihlZGl0b3IsIGRhdGEpIHtcblx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdHZhciBzZWwgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGRhdGEuZGF0YSwgZGF0YS5zdGFydCwgZGF0YS5lbmQsIHRydWUpO1xuXHRcdFx0XHRlZGl0b3IuY3JlYXRlU2VsZWN0aW9uKGRhdGEuY2FyZXQsIGRhdGEuY2FyZXQgKyBzZWwuZW5kIC0gc2VsLnN0YXJ0KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbW1vbiBzeW50YXggZGV0ZWN0aW9uIG1ldGhvZCBmb3IgZWRpdG9ycyB0aGF0IGRvZXNu4oCZdCBwcm92aWRlIGFueVxuXHRcdCAqIGluZm8gYWJvdXQgY3VycmVudCBzeW50YXggc2NvcGUuIFxuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgQ3VycmVudCBlZGl0b3Jcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaGludCBBbnkgc3ludGF4IGhpbnQgdGhhdCBlZGl0b3IgY2FuIHByb3ZpZGUgXG5cdFx0ICogZm9yIHN5bnRheCBkZXRlY3Rpb24uIERlZmF1bHQgaXMgJ2h0bWwnXG5cdFx0ICogQHJldHVybnMge1N0cmluZ30gXG5cdFx0ICovXG5cdFx0ZGV0ZWN0U3ludGF4OiBmdW5jdGlvbihlZGl0b3IsIGhpbnQpIHtcblx0XHRcdHZhciBzeW50YXggPSBoaW50IHx8ICdodG1sJztcblx0XHRcdFxuXHRcdFx0aWYgKCFyZXF1aXJlKCdyZXNvdXJjZXMnKS5oYXNTeW50YXgoc3ludGF4KSkge1xuXHRcdFx0XHRzeW50YXggPSAnaHRtbCc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzeW50YXggPT0gJ2h0bWwnICYmICh0aGlzLmlzU3R5bGUoZWRpdG9yKSB8fCB0aGlzLmlzSW5saW5lQ1NTKGVkaXRvcikpKSB7XG5cdFx0XHRcdHN5bnRheCA9ICdjc3MnO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc3ludGF4O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29tbW9uIG1ldGhvZCBmb3IgZGV0ZWN0aW5nIG91dHB1dCBwcm9maWxlXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZGV0ZWN0UHJvZmlsZTogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHR2YXIgc3ludGF4ID0gZWRpdG9yLmdldFN5bnRheCgpO1xuXHRcdFx0XG5cdFx0XHQvLyBnZXQgcHJvZmlsZSBmcm9tIHN5bnRheCBkZWZpbml0aW9uXG5cdFx0XHR2YXIgcHJvZmlsZSA9IHJlcXVpcmUoJ3Jlc291cmNlcycpLmZpbmRJdGVtKHN5bnRheCwgJ3Byb2ZpbGUnKTtcblx0XHRcdGlmIChwcm9maWxlKSB7XG5cdFx0XHRcdHJldHVybiBwcm9maWxlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRzd2l0Y2goc3ludGF4KSB7XG5cdFx0XHRcdGNhc2UgJ3htbCc6XG5cdFx0XHRcdGNhc2UgJ3hzbCc6XG5cdFx0XHRcdFx0cmV0dXJuICd4bWwnO1xuXHRcdFx0XHRjYXNlICdjc3MnOlxuXHRcdFx0XHRcdGlmICh0aGlzLmlzSW5saW5lQ1NTKGVkaXRvcikpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnbGluZSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdodG1sJzpcblx0XHRcdFx0XHR2YXIgcHJvZmlsZSA9IHJlcXVpcmUoJ3Jlc291cmNlcycpLmdldFZhcmlhYmxlKCdwcm9maWxlJyk7XG5cdFx0XHRcdFx0aWYgKCFwcm9maWxlKSB7IC8vIG5vIGZvcmNlZCBwcm9maWxlLCBndWVzcyBmcm9tIGNvbnRlbnRcblx0XHRcdFx0XHRcdC8vIGh0bWwgb3IgeGh0bWw/XG5cdFx0XHRcdFx0XHRwcm9maWxlID0gdGhpcy5pc1hIVE1MKGVkaXRvcikgPyAneGh0bWwnOiAnaHRtbCc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHByb2ZpbGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAneGh0bWwnO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZXMgdG8gZGV0ZWN0IGlmIGN1cnJlbnQgZG9jdW1lbnQgaXMgWEhUTUwgb25lLlxuXHRcdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc1hIVE1MOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHJldHVybiBlZGl0b3IuZ2V0Q29udGVudCgpLnNlYXJjaCgvPCFET0NUWVBFW14+XStYSFRNTC9pKSAhPSAtMTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaXMgaW5zaWRlICZsdDtzdHlsZSZndDsgdGFnXG5cdFx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0aXNTdHlsZTogZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IFN0cmluZyhlZGl0b3IuZ2V0Q29udGVudCgpKTtcblx0XHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFx0dmFyIHRhZyA9IHJlcXVpcmUoJ2h0bWxNYXRjaGVyJykudGFnKGNvbnRlbnQsIGNhcmV0UG9zKTtcblx0XHRcdHJldHVybiB0YWcgJiYgdGFnLm9wZW4ubmFtZS50b0xvd2VyQ2FzZSgpID09ICdzdHlsZScgXG5cdFx0XHRcdCYmIHRhZy5pbm5lclJhbmdlLmNtcChjYXJldFBvcywgJ2x0ZScsICdndGUnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaXMgaW5zaWRlIFwic3R5bGVcIiBhdHRyaWJ1dGUgb2YgSFRNTFxuXHRcdCAqIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNJbmxpbmVDU1M6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHRcdHZhciB0cmVlID0gcmVxdWlyZSgneG1sRWRpdFRyZWUnKS5wYXJzZUZyb21Qb3NpdGlvbihjb250ZW50LCBjYXJldFBvcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAodHJlZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gdHJlZS5pdGVtRnJvbVBvc2l0aW9uKGNhcmV0UG9zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ciAmJiBhdHRyLm5hbWUoKS50b0xvd2VyQ2FzZSgpID09ICdzdHlsZScgXG4gICAgICAgICAgICAgICAgXHQmJiBhdHRyLnZhbHVlUmFuZ2UodHJ1ZSkuY21wKGNhcmV0UG9zLCAnbHRlJywgJ2d0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggPGNvZGU+QWJicmV2aWF0aW9uTm9kZTwvY29kZT4gYXMgSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZGVmaW5lKCdhYmJyZXZpYXRpb25VdGlscycsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBwYXNzZWQgYWJicmV2aWF0aW9uIG5vZGUgaGFzIG1hdGNoZWQgc25pcHBldCByZXNvdXJjZVxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqIEBtZW1iZXJPZiBhYmJyZXZpYXRpb25VdGlsc1xuXHRcdCAqL1xuXHRcdGlzU25pcHBldDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIHJlcXVpcmUoJ2VsZW1lbnRzJykuaXMobm9kZS5tYXRjaGVkUmVzb3VyY2UoKSwgJ3NuaXBwZXQnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRlc3QgaWYgcGFzc2VkIG5vZGUgaXMgdW5hcnkgKG5vIGNsb3NpbmcgdGFnKVxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNVbmFyeTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0aWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoIHx8IG5vZGUuX3RleHQgfHwgdGhpcy5pc1NuaXBwZXQobm9kZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgciA9IG5vZGUubWF0Y2hlZFJlc291cmNlKCk7XG5cdFx0XHRyZXR1cm4gciAmJiByLmlzX2VtcHR5O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGVzdCBpZiBwYXNzZWQgbm9kZSBpcyBpbmxpbmUtbGV2ZWwgKGxpa2UgJmx0O3N0cm9uZyZndDssICZsdDtpbWcmZ3Q7KVxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNJbmxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBub2RlLmlzVGV4dE5vZGUoKSBcblx0XHRcdFx0fHwgIW5vZGUubmFtZSgpIFxuXHRcdFx0XHR8fCByZXF1aXJlKCd0YWdOYW1lJykuaXNJbmxpbmVMZXZlbChub2RlLm5hbWUoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUZXN0IGlmIHBhc3NlZCBub2RlIGlzIGJsb2NrLWxldmVsXG5cdFx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0Jsb2NrOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1NuaXBwZXQobm9kZSkgfHwgIXRoaXMuaXNJbmxpbmUobm9kZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUZXN0IGlmIGdpdmVuIG5vZGUgaXMgYSBzbmlwcGV0XG5cdFx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc1NuaXBwZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiByZXF1aXJlKCdlbGVtZW50cycpLmlzKG5vZGUubWF0Y2hlZFJlc291cmNlKCksICdzbmlwcGV0Jyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIGlmIHBhc3NlZCBub2RlIGNvbnRlbnQgY29udGFpbnMgSFRNTCB0YWdzLiBcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VkIGZvciBvdXRwdXQgZm9ybWF0dGluZ1xuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGhhc1RhZ3NJbkNvbnRlbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiByZXF1aXJlKCd1dGlscycpLm1hdGNoZXNUYWcobm9kZS5jb250ZW50KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRlc3QgaWYgY3VycmVudCBlbGVtZW50IGNvbnRhaW5zIGJsb2NrLWxldmVsIGNoaWxkcmVuXG5cdFx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNCbG9ja0NoaWxkcmVuOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuaGFzVGFnc0luQ29udGVudChub2RlKSAmJiB0aGlzLmlzQmxvY2sobm9kZSkpIFxuXHRcdFx0XHR8fCBfLmFueShub2RlLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmlzQmxvY2soY2hpbGQpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBpbnNlcnRzIGNvbnRlbnQgaW5zdGVhZCBvZiA8Y29kZT4ke2NoaWxkfTwvY29kZT5cblx0XHQgKiB2YXJpYWJsZXMgb24gPGNvZGU+dGV4dDwvY29kZT5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHdoZXJlIGNoaWxkIGNvbnRlbnQgc2hvdWxkIGJlIGluc2VydGVkXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkQ29udGVudCBDb250ZW50IHRvIGluc2VydFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICogQHJldHVybnMge1N0cmluZ1xuXHRcdCAqL1xuXHRcdGluc2VydENoaWxkQ29udGVudDogZnVuY3Rpb24odGV4dCwgY2hpbGRDb250ZW50LCBvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gXy5leHRlbmQoe1xuXHRcdFx0XHRrZWVwVmFyaWFibGU6IHRydWUsXG5cdFx0XHRcdGFwcGVuZElmTm9DaGlsZDogdHJ1ZVxuXHRcdFx0fSwgb3B0aW9ucyB8fCB7fSk7XG5cdFx0XHRcblx0XHRcdHZhciBjaGlsZFZhcmlhYmxlUmVwbGFjZWQgPSBmYWxzZTtcblx0XHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0XHR0ZXh0ID0gdXRpbHMucmVwbGFjZVZhcmlhYmxlcyh0ZXh0LCBmdW5jdGlvbih2YXJpYWJsZSwgbmFtZSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgb3V0cHV0ID0gdmFyaWFibGU7XG5cdFx0XHRcdGlmIChuYW1lID09ICdjaGlsZCcpIHtcblx0XHRcdFx0XHQvLyBhZGQgY29ycmVjdCBpbmRlbnRhdGlvblxuXHRcdFx0XHRcdG91dHB1dCA9IHV0aWxzLnBhZFN0cmluZyhjaGlsZENvbnRlbnQsIHV0aWxzLmdldExpbmVQYWRkaW5nRnJvbVBvc2l0aW9uKHRleHQsIGRhdGEuc3RhcnQpKTtcblx0XHRcdFx0XHRjaGlsZFZhcmlhYmxlUmVwbGFjZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLmtlZXBWYXJpYWJsZSlcblx0XHRcdFx0XHRcdG91dHB1dCArPSB2YXJpYWJsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWNoaWxkVmFyaWFibGVSZXBsYWNlZCAmJiBvcHRpb25zLmFwcGVuZElmTm9DaGlsZCkge1xuXHRcdFx0XHR0ZXh0ICs9IGNoaWxkQ29udGVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKVxuICogQGxpbmsgaHR0cDovL2NoaWt1eW9ub2sucnVcbiAqL1xuZW1tZXQuZGVmaW5lKCdiYXNlNjQnLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIEVuY29kZXMgZGF0YSB1c2luZyBiYXNlNjQgYWxnb3JpdGhtXG5cdFx0ICogQGF1dGhvciBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQuYmFzZTY0XG5cdFx0ICovXG5cdFx0ZW5jb2RlIDogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0LCBjZHAxLCBjZHAyLCBjZHAzO1xuXHRcdFx0dmFyIGkgPSAwLCBpbCA9IGlucHV0Lmxlbmd0aCwgYjY0ID0gY2hhcnM7XG5cblx0XHRcdHdoaWxlIChpIDwgaWwpIHtcblxuXHRcdFx0XHRjZHAxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXHRcdFx0XHRjZHAyID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXHRcdFx0XHRjZHAzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG5cdFx0XHRcdGNocjEgPSBjZHAxICYgMHhmZjtcblx0XHRcdFx0Y2hyMiA9IGNkcDIgJiAweGZmO1xuXHRcdFx0XHRjaHIzID0gY2RwMyAmIDB4ZmY7XG5cblx0XHRcdFx0ZW5jMSA9IGNocjEgPj4gMjtcblx0XHRcdFx0ZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG5cdFx0XHRcdGVuYzMgPSAoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KTtcblx0XHRcdFx0ZW5jNCA9IGNocjMgJiA2MztcblxuXHRcdFx0XHRpZiAoaXNOYU4oY2RwMikpIHtcblx0XHRcdFx0XHRlbmMzID0gZW5jNCA9IDY0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzTmFOKGNkcDMpKSB7XG5cdFx0XHRcdFx0ZW5jNCA9IDY0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3V0cHV0LnB1c2goYjY0LmNoYXJBdChlbmMxKSArIGI2NC5jaGFyQXQoZW5jMikgKyBiNjQuY2hhckF0KGVuYzMpICsgYjY0LmNoYXJBdChlbmM0KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlY29kZXMgc3RyaW5nIHVzaW5nIE1JTUUgYmFzZTY0IGFsZ29yaXRobVxuXHRcdCAqIFxuXHRcdCAqIEBhdXRob3IgVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGRlY29kZSA6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsIGFjID0gMCwgdG1wQXJyID0gW107XG5cdFx0XHR2YXIgYjY0ID0gY2hhcnMsIGlsID0gZGF0YS5sZW5ndGg7XG5cblx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0ZGF0YSArPSAnJztcblxuXHRcdFx0ZG8geyAvLyB1bnBhY2sgZm91ciBoZXhldHMgaW50byB0aHJlZSBvY3RldHMgdXNpbmcgaW5kZXggcG9pbnRzIGluIGI2NFxuXHRcdFx0XHRoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXHRcdFx0XHRoMiA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXHRcdFx0XHRoMyA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXHRcdFx0XHRoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG5cdFx0XHRcdGJpdHMgPSBoMSA8PCAxOCB8IGgyIDw8IDEyIHwgaDMgPDwgNiB8IGg0O1xuXG5cdFx0XHRcdG8xID0gYml0cyA+PiAxNiAmIDB4ZmY7XG5cdFx0XHRcdG8yID0gYml0cyA+PiA4ICYgMHhmZjtcblx0XHRcdFx0bzMgPSBiaXRzICYgMHhmZjtcblxuXHRcdFx0XHRpZiAoaDMgPT0gNjQpIHtcblx0XHRcdFx0XHR0bXBBcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xKTtcblx0XHRcdFx0fSBlbHNlIGlmIChoNCA9PSA2NCkge1xuXHRcdFx0XHRcdHRtcEFyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXBBcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMiwgbzMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlIChpIDwgaWwpO1xuXG5cdFx0XHRyZXR1cm4gdG1wQXJyLmpvaW4oJycpO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogSFRNTCBtYXRjaGVyOiB0YWtlcyBzdHJpbmcgYW5kIHNlYXJjaGVzIGZvciBIVE1MIHRhZyBwYWlycyBmb3IgZ2l2ZW4gcG9zaXRpb24gXG4gKiBcbiAqIFVubGlrZSDigJxjbGFzc2lj4oCdIG1hdGNoZXJzLCBpdCBwYXJzZXMgY29udGVudCBmcm9tIHRoZSBzcGVjaWZpZWQgXG4gKiBwb3NpdGlvbiwgbm90IGZyb20gdGhlIHN0YXJ0LCBzbyBpdCBtYXkgd29yayBldmVuIG91dHNpZGUgSFRNTCBkb2N1bWVudHNcbiAqIChmb3IgZXhhbXBsZSwgaW5zaWRlIHN0cmluZ3Mgb2YgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIGxpa2UgSmF2YVNjcmlwdCwgUHl0aG9uIFxuICogZXRjLilcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1lbWJlck9mIF9faHRtbE1hdGNoZXJEZWZpbmVcbiAqL1xuZW1tZXQuZGVmaW5lKCdodG1sTWF0Y2hlcicsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0Ly8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5cdHZhciByZU9wZW5UYWcgPSAvXjwoW1xcd1xcOlxcLV0rKSgoPzpcXHMrW1xcd1xcLTpdKyg/Olxccyo9XFxzKig/Oig/OlwiW15cIl0qXCIpfCg/OidbXiddKicpfFtePlxcc10rKSk/KSopXFxzKihcXC8/KT4vO1xuXHR2YXIgcmVDbG9zZVRhZyA9IC9ePFxcLyhbXFx3XFw6XFwtXSspW14+XSo+Lztcblx0XG5cdGZ1bmN0aW9uIG9wZW5UYWcoaSwgbWF0Y2gpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogbWF0Y2hbMV0sXG5cdFx0XHRzZWxmQ2xvc2U6ICEhbWF0Y2hbM10sXG5cdFx0XHQvKiogQHR5cGUgUmFuZ2UgKi9cblx0XHRcdHJhbmdlOiByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShpLCBtYXRjaFswXSksXG5cdFx0XHR0eXBlOiAnb3Blbidcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjbG9zZVRhZyhpLCBtYXRjaCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiBtYXRjaFsxXSxcblx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0cmFuZ2U6IHJlcXVpcmUoJ3JhbmdlJykuY3JlYXRlKGksIG1hdGNoWzBdKSxcblx0XHRcdHR5cGU6ICdjbG9zZSdcblx0XHR9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjb21tZW50KGksIG1hdGNoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0cmFuZ2U6IHJlcXVpcmUoJ3JhbmdlJykuY3JlYXRlKGksIF8uaXNOdW1iZXIobWF0Y2gpID8gbWF0Y2ggLSBpIDogbWF0Y2hbMF0pLFxuXHRcdFx0dHlwZTogJ2NvbW1lbnQnXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgbmV3IHRhZyBtYXRjaGVyIHNlc3Npb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIodGV4dCkge1xuXHRcdHZhciBtZW1vID0ge30sIG07XG5cdFx0cmV0dXJuIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGVzdCBpZiBnaXZlbiBwb3NpdGlvbiBtYXRjaGVzIG9wZW5pbmcgdGFnXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gaVxuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gTWF0Y2hlZCB0YWcgb2JqZWN0XG5cdFx0XHQgKi9cblx0XHRcdG9wZW46IGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIG0gPSB0aGlzLm1hdGNoZXMoaSk7XG5cdFx0XHRcdHJldHVybiBtICYmIG0udHlwZSA9PSAnb3BlbicgPyBtIDogbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGVzdCBpZiBnaXZlbiBwb3NpdGlvbiBtYXRjaGVzIGNsb3NpbmcgdGFnXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gaVxuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gTWF0Y2hlZCB0YWcgb2JqZWN0XG5cdFx0XHQgKi9cblx0XHRcdGNsb3NlOiBmdW5jdGlvbihpKSB7XG5cdFx0XHRcdHZhciBtID0gdGhpcy5tYXRjaGVzKGkpO1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLnR5cGUgPT0gJ2Nsb3NlJyA/IG0gOiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNYXRjaGVzIGVpdGhlciBvcGVuaW5nIG9yIGNsb3NpbmcgdGFnIGZvciBnaXZlbiBwb3NpdGlvblxuXHRcdFx0ICogQHBhcmFtIGlcblx0XHRcdCAqIEByZXR1cm5zXG5cdFx0XHQgKi9cblx0XHRcdG1hdGNoZXM6IGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIGtleSA9ICdwJyArIGk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIShrZXkgaW4gbWVtbykpIHtcblx0XHRcdFx0XHRpZiAodGV4dC5jaGFyQXQoaSkgPT0gJzwnKSB7XG5cdFx0XHRcdFx0XHR2YXIgc3Vic3RyID0gdGV4dC5zbGljZShpKTtcblx0XHRcdFx0XHRcdGlmIChtID0gc3Vic3RyLm1hdGNoKHJlT3BlblRhZykpIHtcblx0XHRcdFx0XHRcdFx0bWVtb1trZXldID0gb3BlblRhZyhpLCBtKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobSA9IHN1YnN0ci5tYXRjaChyZUNsb3NlVGFnKSkge1xuXHRcdFx0XHRcdFx0XHRtZW1vW2tleV0gPSBjbG9zZVRhZyhpLCBtKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZ2l2ZW4gcG9zaXRpb24gY29udGFpbnMgbm8gdmFsaWQgdGFnXG5cdFx0XHRcdFx0XHRcdG1lbW9ba2V5XSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG1lbW9ba2V5XTtcblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBvcmlnaW5hbCB0ZXh0XG5cdFx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHR0ZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWF0Y2hlcyh0ZXh0LCBwb3MsIHBhdHRlcm4pIHtcblx0XHRyZXR1cm4gdGV4dC5zdWJzdHJpbmcocG9zLCBwb3MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNlYXJjaCBmb3IgY2xvc2luZyBwYWlyIG9mIG9wZW5pbmcgdGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcGVuIE9wZW4gdGFnIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGVyIE1hdGNoZXIgaW5zdGFuY2Vcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRDbG9zaW5nUGFpcihvcGVuLCBtYXRjaGVyKSB7XG5cdFx0dmFyIHN0YWNrID0gW10sIHRhZyA9IG51bGw7XG5cdFx0dmFyIHRleHQgPSBtYXRjaGVyLnRleHQoKTtcblx0XHRcblx0XHRmb3IgKHZhciBwb3MgPSBvcGVuLnJhbmdlLmVuZCwgbGVuID0gdGV4dC5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcblx0XHRcdGlmIChtYXRjaGVzKHRleHQsIHBvcywgJzwhLS0nKSkge1xuXHRcdFx0XHQvLyBza2lwIHRvIGVuZCBvZiBjb21tZW50XG5cdFx0XHRcdGZvciAodmFyIGogPSBwb3M7IGogPCBsZW47IGorKykge1xuXHRcdFx0XHRcdGlmIChtYXRjaGVzKHRleHQsIGosICctLT4nKSkge1xuXHRcdFx0XHRcdFx0cG9zID0gaiArIDM7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRhZyA9IG1hdGNoZXIubWF0Y2hlcyhwb3MpKSB7XG5cdFx0XHRcdGlmICh0YWcudHlwZSA9PSAnb3BlbicgJiYgIXRhZy5zZWxmQ2xvc2UpIHtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHRhZy5uYW1lKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0YWcudHlwZSA9PSAnY2xvc2UnKSB7XG5cdFx0XHRcdFx0aWYgKCFzdGFjay5sZW5ndGgpIHsgLy8gZm91bmQgdmFsaWQgcGFpcj9cblx0XHRcdFx0XHRcdHJldHVybiB0YWcubmFtZSA9PSBvcGVuLm5hbWUgPyB0YWcgOiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBjdXJyZW50IGNsb3NpbmcgdGFnIG1hdGNoZXMgcHJldmlvdXNseSBvcGVuZWQgb25lXG5cdFx0XHRcdFx0aWYgKF8ubGFzdChzdGFjaykgPT0gdGFnLm5hbWUpIHtcblx0XHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHdoaWxlIChzdGFjay5sZW5ndGggJiYgIWZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsYXN0ID0gc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChsYXN0ID09IHRhZy5uYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICghc3RhY2subGVuZ3RoICYmICFmb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGFnLm5hbWUgPT0gb3Blbi5uYW1lID8gdGFnIDogbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0fVxuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBNYWluIGZ1bmN0aW9uOiBzZWFyY2ggZm9yIHRhZyBwYWlyIGluIDxjb2RlPnRleHQ8L2NvZGU+IGZvciBnaXZlbiBcblx0XHQgKiBwb3NpdGlvblxuXHRcdCAqIEBtZW1iZXJPZiBodG1sTWF0Y2hlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3Ncblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGZpbmQ6IGZ1bmN0aW9uKHRleHQsIHBvcykge1xuXHRcdFx0dmFyIHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKTtcblx0XHRcdHZhciBtYXRjaGVyID0gY3JlYXRlTWF0Y2hlcih0ZXh0KTsgXG5cdFx0XHR2YXIgb3BlbiA9IG51bGwsIGNsb3NlID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgaSA9IHBvczsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKG9wZW4gPSBtYXRjaGVyLm9wZW4oaSkpIHtcblx0XHRcdFx0XHQvLyBmb3VuZCBvcGVuaW5nIHRhZ1xuXHRcdFx0XHRcdGlmIChvcGVuLnNlbGZDbG9zZSkge1xuXHRcdFx0XHRcdFx0aWYgKG9wZW4ucmFuZ2UuY21wKHBvcywgJ2x0JywgJ2d0JykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gaW5zaWRlIHNlbGYtY2xvc2luZyB0YWcsIGZvdW5kIG1hdGNoXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBvdXRzaWRlIHNlbGYtY2xvc2luZyB0YWcsIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2xvc2UgPSBmaW5kQ2xvc2luZ1BhaXIob3BlbiwgbWF0Y2hlcik7XG5cdFx0XHRcdFx0aWYgKGNsb3NlKSB7XG5cdFx0XHRcdFx0XHQvLyBmb3VuZCBjbG9zaW5nIHRhZy5cblx0XHRcdFx0XHRcdHZhciByID0gcmFuZ2UuY3JlYXRlMihvcGVuLnJhbmdlLnN0YXJ0LCBjbG9zZS5yYW5nZS5lbmQpO1xuXHRcdFx0XHRcdFx0aWYgKHIuY29udGFpbnMocG9zKSkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKG9wZW4ucmFuZ2UuY29udGFpbnMocG9zKSkge1xuXHRcdFx0XHRcdFx0Ly8gd2UgaW5zaWRlIGVtcHR5IEhUTUwgdGFnIGxpa2UgPGJyPlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG9wZW4gPSBudWxsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGNoZXModGV4dCwgaSwgJy0tPicpKSB7XG5cdFx0XHRcdFx0Ly8gc2tpcCBiYWNrIHRvIGNvbW1lbnQgc3RhcnRcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hlcyh0ZXh0LCBqLCAnLS0+JykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZm91bmQgYW5vdGhlciBjb21tZW50IGVuZCwgZG8gbm90aGluZ1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hlcyh0ZXh0LCBqLCAnPCEtLScpKSB7XG5cdFx0XHRcdFx0XHRcdGkgPSBqO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hlcyh0ZXh0LCBpLCAnPCEtLScpKSB7XG5cdFx0XHRcdFx0Ly8gd2UncmUgaW5zaWRlIGNvbW1lbnQsIG1hdGNoIGl0XG5cdFx0XHRcdFx0dmFyIGogPSBpICsgNCwgamwgPSB0ZXh0Lmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChtYXRjaGVzKHRleHQsIGosICctLT4nKSkge1xuXHRcdFx0XHRcdFx0XHRqICs9IDM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRvcGVuID0gY29tbWVudChpLCBqKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAob3Blbikge1xuXHRcdFx0XHR2YXIgb3V0ZXJSYW5nZSA9IG51bGw7XG5cdFx0XHRcdHZhciBpbm5lclJhbmdlID0gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjbG9zZSkge1xuXHRcdFx0XHRcdG91dGVyUmFuZ2UgPSByYW5nZS5jcmVhdGUyKG9wZW4ucmFuZ2Uuc3RhcnQsIGNsb3NlLnJhbmdlLmVuZCk7XG5cdFx0XHRcdFx0aW5uZXJSYW5nZSA9IHJhbmdlLmNyZWF0ZTIob3Blbi5yYW5nZS5lbmQsIGNsb3NlLnJhbmdlLnN0YXJ0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRlclJhbmdlID0gaW5uZXJSYW5nZSA9IHJhbmdlLmNyZWF0ZTIob3Blbi5yYW5nZS5zdGFydCwgb3Blbi5yYW5nZS5lbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob3Blbi50eXBlID09ICdjb21tZW50Jykge1xuXHRcdFx0XHRcdC8vIGFkanVzdCBwb3NpdGlvbnMgb2YgaW5uZXIgcmFuZ2UgZm9yIGNvbW1lbnRcblx0XHRcdFx0XHR2YXIgX2MgPSBvdXRlclJhbmdlLnN1YnN0cmluZyh0ZXh0KTtcblx0XHRcdFx0XHRpbm5lclJhbmdlLnN0YXJ0ICs9IF9jLmxlbmd0aCAtIF9jLnJlcGxhY2UoL148XFwhLS1cXHMqLywgJycpLmxlbmd0aDtcblx0XHRcdFx0XHRpbm5lclJhbmdlLmVuZCAtPSBfYy5sZW5ndGggLSBfYy5yZXBsYWNlKC9cXHMqLS0+JC8sICcnKS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0b3Blbjogb3Blbixcblx0XHRcdFx0XHRjbG9zZTogY2xvc2UsXG5cdFx0XHRcdFx0dHlwZTogb3Blbi50eXBlID09ICdjb21tZW50JyA/ICdjb21tZW50JyA6ICd0YWcnLFxuXHRcdFx0XHRcdGlubmVyUmFuZ2U6IGlubmVyUmFuZ2UsXG5cdFx0XHRcdFx0aW5uZXJDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmlubmVyUmFuZ2Uuc3Vic3RyaW5nKHRleHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b3V0ZXJSYW5nZTogb3V0ZXJSYW5nZSxcblx0XHRcdFx0XHRvdXRlckNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3V0ZXJSYW5nZS5zdWJzdHJpbmcodGV4dCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRyYW5nZTogIWlubmVyUmFuZ2UubGVuZ3RoKCkgfHwgIWlubmVyUmFuZ2UuY21wKHBvcywgJ2x0ZScsICdndGUnKSA/IG91dGVyUmFuZ2UgOiBpbm5lclJhbmdlLFxuXHRcdFx0XHRcdGNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMucmFuZ2Uuc3Vic3RyaW5nKHRleHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c291cmNlOiB0ZXh0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2FtZSBhcyA8Y29kZT5maW5kKCk8L2NvZGU+IG1ldGhvZCwgYnV0IHJlc3RyaWN0cyBtYXRjaGVkIHJlc3VsdCBcblx0XHQgKiB0byA8Y29kZT50YWc8L2NvZGU+IHR5cGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHR0YWc6IGZ1bmN0aW9uKHRleHQsIHBvcykge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuZmluZCh0ZXh0LCBwb3MpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudHlwZSA9PSAndGFnJykge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogVXRpbGl0eSBtb2R1bGUgZm9yIGhhbmRsaW5nIHRhYnN0b3BzIHRva2VucyBnZW5lcmF0ZWQgYnkgRW1tZXQncyBcbiAqIFwiRXhwYW5kIEFiYnJldmlhdGlvblwiIGFjdGlvbi4gVGhlIG1haW4gPGNvZGU+ZXh0cmFjdDwvY29kZT4gbWV0aG9kIHdpbGwgdGFrZVxuICogcmF3IHRleHQgKGZvciBleGFtcGxlOiA8aT4kezB9IHNvbWUgJHsxOnRleHR9PC9pPiksIGZpbmQgYWxsIHRhYnN0b3BzIFxuICogb2NjdXJyZW5jZXMsIHJlcGxhY2UgdGhlbSB3aXRoIHRva2VucyBzdWl0YWJsZSBmb3IgeW91ciBlZGl0b3Igb2YgY2hvaWNlIGFuZCBcbiAqIHJldHVybiBvYmplY3Qgd2l0aCBwcm9jZXNzZWQgdGV4dCBhbmQgbGlzdCBvZiBmb3VuZCB0YWJzdG9wcyBhbmQgdGhlaXIgcmFuZ2VzLlxuICogRm9yIHNha2Ugb2YgcG9ydGFiaWxpdHkgKE9iamVjdGl2ZS1DL0phdmEpIHRoZSB0YWJzdG9wcyBsaXN0IGlzIGEgcGxhaW4gXG4gKiBzb3J0ZWQgYXJyYXkgd2l0aCBwbGFpbiBvYmplY3RzLlxuICogXG4gKiBQbGFjZWhvbGRlcnMgd2l0aCB0aGUgc2FtZSBhcmUgbWVhbnQgdG8gYmUgPGk+bGlua2VkPC9pPiBpbiB5b3VyIGVkaXRvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gXyAgXG4gKi9cbmVtbWV0LmRlZmluZSgndGFiU3RvcHMnLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBHbG9iYWwgcGxhY2Vob2xkZXIgdmFsdWUsIGF1dG9tYXRpY2FsbHkgaW5jcmVtZW50ZWQgYnkgXG5cdCAqIDxjb2RlPnZhcmlhYmxlc1Jlc29sdmVyKCk8L2NvZGU+IGZ1bmN0aW9uXG5cdCAqL1xuXHR2YXIgc3RhcnRQbGFjZWhvbGRlck51bSA9IDEwMDtcblx0XG5cdHZhciB0YWJzdG9wSW5kZXggPSAwO1xuXHRcblx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdHJlcGxhY2VDYXJldHM6IGZhbHNlLFxuXHRcdGVzY2FwZTogZnVuY3Rpb24oY2gpIHtcblx0XHRcdHJldHVybiAnXFxcXCcgKyBjaDtcblx0XHR9LFxuXHRcdHRhYnN0b3A6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLnRva2VuO1xuXHRcdH0sXG5cdFx0dmFyaWFibGU6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLnRva2VuO1xuXHRcdH1cblx0fTtcblx0XG5cdC8vIFhYWCByZWdpc3RlciBvdXRwdXQgcHJvY2Vzc29yIHRoYXQgd2lsbCB1cGdyYWRlIHRhYnN0b3BzIG9mIHBhcnNlZCBub2RlXG5cdC8vIGluIG9yZGVyIHRvIHByZXZlbnQgdGFic3RvcCBpbmRleCBjb25mbGljdHNcblx0cmVxdWlyZSgnYWJicmV2aWF0aW9uUGFyc2VyJykuYWRkT3V0cHV0UHJvY2Vzc29yKGZ1bmN0aW9uKHRleHQsIG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgbWF4TnVtID0gMDtcblx0XHR2YXIgdGFic3RvcHMgPSByZXF1aXJlKCd0YWJTdG9wcycpO1xuXHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0XG5cdFx0dmFyIHRzT3B0aW9ucyA9IHtcblx0XHRcdHRhYnN0b3A6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0dmFyIGdyb3VwID0gcGFyc2VJbnQoZGF0YS5ncm91cCk7XG5cdFx0XHRcdGlmIChncm91cCA9PSAwKVxuXHRcdFx0XHRcdHJldHVybiAnJHswfSc7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZ3JvdXAgPiBtYXhOdW0pIG1heE51bSA9IGdyb3VwO1xuXHRcdFx0XHRpZiAoZGF0YS5wbGFjZWhvbGRlcikge1xuXHRcdFx0XHRcdC8vIHJlc3BlY3QgbmVzdGVkIHBsYWNlaG9sZGVyc1xuXHRcdFx0XHRcdHZhciBpeCA9IGdyb3VwICsgdGFic3RvcEluZGV4O1xuXHRcdFx0XHRcdHZhciBwbGFjZWhvbGRlciA9IHRhYnN0b3BzLnByb2Nlc3NUZXh0KGRhdGEucGxhY2Vob2xkZXIsIHRzT3B0aW9ucyk7XG5cdFx0XHRcdFx0cmV0dXJuICckeycgKyBpeCArICc6JyArIHBsYWNlaG9sZGVyICsgJ30nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAnJHsnICsgKGdyb3VwICsgdGFic3RvcEluZGV4KSArICd9Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdXBncmFkZSB0YWJzdG9wc1xuXHRcdHRleHQgPSB0YWJzdG9wcy5wcm9jZXNzVGV4dCh0ZXh0LCB0c09wdGlvbnMpO1xuXHRcdFxuXHRcdC8vIHJlc29sdmUgdmFyaWFibGVzXG5cdFx0dGV4dCA9IHV0aWxzLnJlcGxhY2VWYXJpYWJsZXModGV4dCwgdGFic3RvcHMudmFyaWFibGVzUmVzb2x2ZXIobm9kZSkpO1xuXHRcdFxuXHRcdHRhYnN0b3BJbmRleCArPSBtYXhOdW0gKyAxO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9KTtcblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogTWFpbiBmdW5jdGlvbiB0aGF0IGxvb2tzIGZvciBhIHRhYnN0b3BzIGluIHByb3ZpZGVkIDxjb2RlPnRleHQ8L2NvZGU+XG5cdFx0ICogYW5kIHJldHVybnMgYSBwcm9jZXNzZWQgdmVyc2lvbiBvZiA8Y29kZT50ZXh0PC9jb2RlPiB3aXRoIGV4cGFuZGVkIFxuXHRcdCAqIHBsYWNlaG9sZGVycyBhbmQgbGlzdCBvZiB0YWJzdG9wcyBmb3VuZC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHRvIHByb2Nlc3Ncblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBMaXN0IG9mIHByb2Nlc3NvciBvcHRpb25zOjxicj5cblx0XHQgKiBcblx0XHQgKiA8Yj5yZXBsYWNlQ2FyZXRzPC9iPiA6IDxjb2RlPkJvb2xlYW48L2NvZGU+IOKAlCByZXBsYWNlIGFsbCBkZWZhdWx0XG5cdFx0ICogY2FyZXQgcGxhY2Vob2xkZXJzIChsaWtlIDxpPnslOjplbW1ldC1jYXJldDo6JX08L2k+KSB3aXRoIDxpPiR7MDpjYXJldH08L2k+PGJyPlxuXHRcdCAqIFxuXHRcdCAqIDxiPmVzY2FwZTwvYj4gOiA8Y29kZT5GdW5jdGlvbjwvY29kZT4g4oCUIGZ1bmN0aW9uIHRoYXQgaGFuZGxlIGVzY2FwZWRcblx0XHQgKiBjaGFyYWN0ZXJzIChtb3N0bHkgJyQnKS4gQnkgZGVmYXVsdCwgaXQgcmV0dXJucyB0aGUgY2hhcmFjdGVyIGl0c2VsZiBcblx0XHQgKiB0byBiZSBkaXNwbGF5ZWQgYXMgaXMgaW4gb3V0cHV0LCBidXQgc29tZXRpbWVzIHlvdSB3aWxsIHVzZSBcblx0XHQgKiA8Y29kZT5leHRyYWN0PC9jb2RlPiBtZXRob2QgYXMgaW50ZXJtZWRpYXRlIHNvbHV0aW9uIGZvciBmdXJ0aGVyIFxuXHRcdCAqIHByb2Nlc3NpbmcgYW5kIHdhbnQgdG8ga2VlcCBjaGFyYWN0ZXIgZXNjYXBlZC4gVGh1cywgeW91IHNob3VsZCBvdmVycmlkZVxuXHRcdCAqIDxjb2RlPmVzY2FwZTwvY29kZT4gbWV0aG9kIHRvIHJldHVybiBlc2NhcGVkIHN5bWJvbCAoZS5nLiAnXFxcXCQnKTxicj5cblx0XHQgKiBcblx0XHQgKiA8Yj50YWJzdG9wPC9iPiA6IDxjb2RlPkZ1bmN0aW9uPC9jb2RlPiDigJMgYSB0YWJzdG9wIGhhbmRsZXIuIFJlY2VpdmVzIFxuXHRcdCAqIGEgc2luZ2xlIGFyZ3VtZW50IOKAkyBhbiBvYmplY3QgZGVzY3JpYmluZyB0b2tlbjogaXRzIHBvc2l0aW9uLCBudW1iZXIgXG5cdFx0ICogZ3JvdXAsIHBsYWNlaG9sZGVyIGFuZCB0b2tlbiBpdHNlbGYuIFNob3VsZCByZXR1cm4gYSByZXBsYWNlbWVudCBcblx0XHQgKiBzdHJpbmcgdGhhdCB3aWxsIGFwcGVhciBpbiBmaW5hbCBvdXRwdXRcblx0XHQgKiBcblx0XHQgKiA8Yj52YXJpYWJsZTwvYj4gOiA8Y29kZT5GdW5jdGlvbjwvY29kZT4g4oCTIHZhcmlhYmxlIGhhbmRsZXIuIFJlY2VpdmVzIFxuXHRcdCAqIGEgc2luZ2xlIGFyZ3VtZW50IOKAkyBhbiBvYmplY3QgZGVzY3JpYmluZyB0b2tlbjogaXRzIHBvc2l0aW9uLCBuYW1lIFxuXHRcdCAqIGFuZCBvcmlnaW5hbCB0b2tlbiBpdHNlbGYuIFNob3VsZCByZXR1cm4gYSByZXBsYWNlbWVudCBcblx0XHQgKiBzdHJpbmcgdGhhdCB3aWxsIGFwcGVhciBpbiBmaW5hbCBvdXRwdXRcblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCBwcm9jZXNzZWQgPGNvZGU+dGV4dDwvY29kZT4gcHJvcGVydHlcblx0XHQgKiBhbmQgYXJyYXkgb2YgPGNvZGU+dGFic3RvcHM8L2NvZGU+IGZvdW5kXG5cdFx0ICogQG1lbWJlck9mIHRhYlN0b3BzXG5cdFx0ICovXG5cdFx0ZXh0cmFjdDogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuXHRcdFx0Ly8gcHJlcGFyZSBkZWZhdWx0c1xuXHRcdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcdHZhciBwbGFjZWhvbGRlcnMgPSB7Y2FyZXRzOiAnJ307XG5cdFx0XHR2YXIgbWFya3MgPSBbXTtcblx0XHRcdFxuXHRcdFx0b3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucywge1xuXHRcdFx0XHR0YWJzdG9wOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0dmFyIHRva2VuID0gZGF0YS50b2tlbjtcblx0XHRcdFx0XHR2YXIgcmV0ID0gJyc7XG5cdFx0XHRcdFx0aWYgKGRhdGEucGxhY2Vob2xkZXIgPT0gJ2N1cnNvcicpIHtcblx0XHRcdFx0XHRcdG1hcmtzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRzdGFydDogZGF0YS5zdGFydCxcblx0XHRcdFx0XHRcdFx0ZW5kOiBkYXRhLnN0YXJ0ICsgdG9rZW4ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRncm91cDogJ2NhcmV0cycsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiAnJ1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHVuaWZ5IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBzaW5nbGUgZ3JvdXBcblx0XHRcdFx0XHRcdGlmICgncGxhY2Vob2xkZXInIGluIGRhdGEpXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyc1tkYXRhLmdyb3VwXSA9IGRhdGEucGxhY2Vob2xkZXI7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChkYXRhLmdyb3VwIGluIHBsYWNlaG9sZGVycylcblx0XHRcdFx0XHRcdFx0cmV0ID0gcGxhY2Vob2xkZXJzW2RhdGEuZ3JvdXBdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRtYXJrcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0c3RhcnQ6IGRhdGEuc3RhcnQsXG5cdFx0XHRcdFx0XHRcdGVuZDogZGF0YS5zdGFydCArIHRva2VuLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0Z3JvdXA6IGRhdGEuZ3JvdXAsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiByZXRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAob3B0aW9ucy5yZXBsYWNlQ2FyZXRzKSB7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cCggdXRpbHMuZXNjYXBlRm9yUmVnZXhwKCB1dGlscy5nZXRDYXJldFBsYWNlaG9sZGVyKCkgKSwgJ2cnKSwgJyR7MDpjdXJzb3J9Jyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGxvY2F0ZSB0YWJzdG9wcyBhbmQgdW5pZnkgZ3JvdXAncyBwbGFjZWhvbGRlcnNcblx0XHRcdHRleHQgPSB0aGlzLnByb2Nlc3NUZXh0KHRleHQsIG9wdGlvbnMpO1xuXHRcdFx0XG5cdFx0XHQvLyBub3csIHJlcGxhY2UgYWxsIHRhYnN0b3BzIHdpdGggcGxhY2Vob2xkZXJzXG5cdFx0XHR2YXIgYnVmID0gdXRpbHMuc3RyaW5nQnVpbGRlcigpLCBsYXN0SXggPSAwO1xuXHRcdFx0dmFyIHRhYlN0b3BzID0gXy5tYXAobWFya3MsIGZ1bmN0aW9uKG1hcmspIHtcblx0XHRcdFx0YnVmLmFwcGVuZCh0ZXh0LnN1YnN0cmluZyhsYXN0SXgsIG1hcmsuc3RhcnQpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBwb3MgPSBidWYubGVuZ3RoO1xuXHRcdFx0XHR2YXIgcGggPSBwbGFjZWhvbGRlcnNbbWFyay5ncm91cF0gfHwgJyc7XG5cdFx0XHRcdFxuXHRcdFx0XHRidWYuYXBwZW5kKHBoKTtcblx0XHRcdFx0bGFzdEl4ID0gbWFyay5lbmQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGdyb3VwOiBtYXJrLmdyb3VwLFxuXHRcdFx0XHRcdHN0YXJ0OiBwb3MsXG5cdFx0XHRcdFx0ZW5kOiAgcG9zICsgcGgubGVuZ3RoXG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0YnVmLmFwcGVuZCh0ZXh0LnN1YnN0cmluZyhsYXN0SXgpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dGV4dDogYnVmLnRvU3RyaW5nKCksXG5cdFx0XHRcdHRhYnN0b3BzOiBfLnNvcnRCeSh0YWJTdG9wcywgJ3N0YXJ0Jylcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBUZXh0IHByb2Nlc3Npbmcgcm91dGluZS4gTG9jYXRlcyBlc2NhcGVkIGNoYXJhY3RlcnMgYW5kIHRhYnN0b3BzIGFuZFxuXHRcdCAqIHJlcGxhY2VzIHRoZW0gd2l0aCB2YWx1ZXMgcmV0dXJuZWQgYnkgaGFuZGxlcnMgZGVmaW5lZCBpbiBcblx0XHQgKiA8Y29kZT5vcHRpb25zPC9jb2RlPlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU2VlIDxjb2RlPmV4dHJhY3Q8L2NvZGU+IG1ldGhvZCBvcHRpb25zIFxuXHRcdCAqIGRlc2NyaXB0aW9uXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRwcm9jZXNzVGV4dDogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0XHRcblx0XHRcdHZhciBidWYgPSByZXF1aXJlKCd1dGlscycpLnN0cmluZ0J1aWxkZXIoKTtcblx0XHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHRcdHZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJpbmdTdHJlYW0nKS5jcmVhdGUodGV4dCk7XG5cdFx0XHR2YXIgY2gsIG0sIGE7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcblx0XHRcdFx0aWYgKGNoID09ICdcXFxcJyAmJiAhc3RyZWFtLmVvbCgpKSB7XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGVzY2FwZWQgY2hhcmFjdGVyXG5cdFx0XHRcdFx0YnVmLmFwcGVuZChvcHRpb25zLmVzY2FwZShzdHJlYW0ubmV4dCgpKSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGEgPSBjaDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaCA9PSAnJCcpIHtcblx0XHRcdFx0XHQvLyBsb29rcyBsaWtlIGEgdGFic3RvcFxuXHRcdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgLSAxO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtID0gc3RyZWFtLm1hdGNoKC9eWzAtOV0rLykpIHtcblx0XHRcdFx0XHRcdC8vIGl0J3MgJE5cblx0XHRcdFx0XHRcdGEgPSBvcHRpb25zLnRhYnN0b3Aoe1xuXHRcdFx0XHRcdFx0XHRzdGFydDogYnVmLmxlbmd0aCwgXG5cdFx0XHRcdFx0XHRcdGdyb3VwOiBzdHJlYW0uY3VycmVudCgpLnN1YnN0cigxKSxcblx0XHRcdFx0XHRcdFx0dG9rZW46IHN0cmVhbS5jdXJyZW50KClcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobSA9IHN0cmVhbS5tYXRjaCgvXlxceyhbYS16X1xcLV1bXFx3XFwtXSopXFx9LykpIHtcblx0XHRcdFx0XHRcdC8vICR7dmFyaWFibGV9XG5cdFx0XHRcdFx0XHRhID0gb3B0aW9ucy52YXJpYWJsZSh7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiBidWYubGVuZ3RoLCBcblx0XHRcdFx0XHRcdFx0bmFtZTogbVsxXSxcblx0XHRcdFx0XHRcdFx0dG9rZW46IHN0cmVhbS5jdXJyZW50KClcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobSA9IHN0cmVhbS5tYXRjaCgvXlxceyhbMC05XSspKDouKz8pP1xcfS8sIGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0Ly8gJHtOOnZhbHVlfSBvciAke059IHBsYWNlaG9sZGVyXG5cdFx0XHRcdFx0XHQvLyBwYXJzZSBwbGFjZWhvbGRlciwgaW5jbHVkaW5nIG5lc3RlZCBvbmVzXG5cdFx0XHRcdFx0XHRzdHJlYW0uc2tpcFRvUGFpcigneycsICd9Jyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciBvYmogPSB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiBidWYubGVuZ3RoLCBcblx0XHRcdFx0XHRcdFx0Z3JvdXA6IG1bMV0sXG5cdFx0XHRcdFx0XHRcdHRva2VuOiBzdHJlYW0uY3VycmVudCgpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXIgPSBvYmoudG9rZW4uc3Vic3RyaW5nKG9iai5ncm91cC5sZW5ndGggKyAyLCBvYmoudG9rZW4ubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChwbGFjZWhvbGRlcikge1xuXHRcdFx0XHRcdFx0XHRvYmoucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlci5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGEgPSBvcHRpb25zLnRhYnN0b3Aob2JqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGJ1Zi5hcHBlbmQoYSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBidWYudG9TdHJpbmcoKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVwZ3JhZGVzIHRhYnN0b3BzIGluIG91dHB1dCBub2RlIGluIG9yZGVyIHRvIHByZXZlbnQgbmFtaW5nIGNvbmZsaWN0c1xuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGFiIGluZGV4IG9mZnNldFxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IE1heGltdW0gdGFic3RvcCBpbmRleCBpbiBlbGVtZW50XG5cdFx0ICovXG5cdFx0dXBncmFkZTogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG5cdFx0XHR2YXIgbWF4TnVtID0gMDtcblx0XHRcdHZhciBvcHRpb25zID0ge1xuXHRcdFx0XHR0YWJzdG9wOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gcGFyc2VJbnQoZGF0YS5ncm91cCk7XG5cdFx0XHRcdFx0aWYgKGdyb3VwID4gbWF4TnVtKSBtYXhOdW0gPSBncm91cDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChkYXRhLnBsYWNlaG9sZGVyKVxuXHRcdFx0XHRcdFx0cmV0dXJuICckeycgKyAoZ3JvdXAgKyBvZmZzZXQpICsgJzonICsgZGF0YS5wbGFjZWhvbGRlciArICd9Jztcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gJyR7JyArIChncm91cCArIG9mZnNldCkgKyAnfSc7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdF8uZWFjaChbJ3N0YXJ0JywgJ2VuZCcsICdjb250ZW50J10sIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0bm9kZVtwXSA9IHRoaXMucHJvY2Vzc1RleHQobm9kZVtwXSwgb3B0aW9ucyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG1heE51bTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIFxuXHRcdCAqIDxjb2RlPnJlcGxhY2VWYXJpYWJsZXMoKTwvY29kZT4gbWV0aG9kIGZyb20ge0BsaW5rIHV0aWxzfVxuXHRcdCAqIG1vZHVsZS4gVGhpcyBjYWxsYmFjayB3aWxsIHJlcGxhY2UgdmFyaWFibGUgZGVmaW5pdGlvbnMgKGxpa2UgXG5cdFx0ICogJHt2YXJfbmFtZX0pIHdpdGggdGhlaXIgdmFsdWUgZGVmaW5lZCBpbiA8aT5yZXNvdXJjZTwvaT4gbW9kdWxlLFxuXHRcdCAqIG9yIG91dHB1dHMgdGFic3RvcCB3aXRoIHZhcmlhYmxlIG5hbWUgb3RoZXJ3aXNlLlxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZSBDb250ZXh0IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XG5cdFx0ICovXG5cdFx0dmFyaWFibGVzUmVzb2x2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwbGFjZWhvbGRlck1lbW8gPSB7fTtcblx0XHRcdHZhciByZXMgPSByZXF1aXJlKCdyZXNvdXJjZXMnKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbihzdHIsIHZhck5hbWUpIHtcblx0XHRcdFx0Ly8gZG8gbm90IG1hcmsgYGNoaWxkYCB2YXJpYWJsZSBhcyBwbGFjZWhvbGRlciDigJMgaXTigJhzIGEgcmVzZXJ2ZWRcblx0XHRcdFx0Ly8gdmFyaWFibGUgbmFtZVxuXHRcdFx0XHRpZiAodmFyTmFtZSA9PSAnY2hpbGQnKVxuXHRcdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodmFyTmFtZSA9PSAnY3Vyc29yJylcblx0XHRcdFx0XHRyZXR1cm4gcmVxdWlyZSgndXRpbHMnKS5nZXRDYXJldFBsYWNlaG9sZGVyKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlKHZhck5hbWUpO1xuXHRcdFx0XHRpZiAoIV8uaXNVbmRlZmluZWQoYXR0cikgJiYgYXR0ciAhPT0gc3RyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHZhciB2YXJWYWx1ZSA9IHJlcy5nZXRWYXJpYWJsZSh2YXJOYW1lKTtcblx0XHRcdFx0aWYgKHZhclZhbHVlKVxuXHRcdFx0XHRcdHJldHVybiB2YXJWYWx1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIG91dHB1dCBhcyBwbGFjZWhvbGRlclxuXHRcdFx0XHRpZiAoIXBsYWNlaG9sZGVyTWVtb1t2YXJOYW1lXSlcblx0XHRcdFx0XHRwbGFjZWhvbGRlck1lbW9bdmFyTmFtZV0gPSBzdGFydFBsYWNlaG9sZGVyTnVtKys7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAnJHsnICsgcGxhY2Vob2xkZXJNZW1vW3Zhck5hbWVdICsgJzonICsgdmFyTmFtZSArICd9Jztcblx0XHRcdH07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXNldHMgZ2xvYmFsIHRhYnN0b3AgaW5kZXguIFdoZW4gcGFyc2VkIHRyZWUgaXMgY29udmVydGVkIHRvIG91dHB1dFxuXHRcdCAqIHN0cmluZyAoPGNvZGU+QWJicmV2aWF0aW9uTm9kZS50b1N0cmluZygpPC9jb2RlPiksIGFsbCB0YWJzdG9wcyBcblx0XHQgKiBkZWZpbmVkIGluIHNuaXBwZXRzIGFuZCBlbGVtZW50cyBhcmUgdXBncmFkZWQgaW4gb3JkZXIgdG8gcHJldmVudFxuXHRcdCAqIG5hbWluZyBjb25mbGljdHMgb2YgbmVzdGVkLiBGb3IgZXhhbXBsZSwgPGNvZGU+JHsxfTwvY29kZT4gb2YgYSBub2RlXG5cdFx0ICogc2hvdWxkIG5vdCBiZSBsaW5rZWQgd2l0aCB0aGUgc2FtZSBwbGFjZWhpbGRlciBvZiB0aGUgY2hpbGQgbm9kZS5cblx0XHQgKiBCeSBkZWZhdWx0LCA8Y29kZT5BYmJyZXZpYXRpb25Ob2RlLnRvU3RyaW5nKCk8L2NvZGU+IGF1dG9tYXRpY2FsbHlcblx0XHQgKiB1cGdyYWRlcyB0YWJzdG9wcyBvZiB0aGUgc2FtZSBpbmRleCBmb3IgZWFjaCBub2RlIGFuZCB3cml0ZXMgbWF4aW11bVxuXHRcdCAqIHRhYnN0b3AgaW5kZXggaW50byB0aGUgPGNvZGU+dGFic3RvcEluZGV4PC9jb2RlPiB2YXJpYWJsZS4gVG8ga2VlcFxuXHRcdCAqIHRoaXMgdmFyaWFibGUgYXQgcmVhc29uYWJsZSB2YWx1ZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCBcblx0XHQgKiA8Y29kZT5yZXNldFRhYnN0b3BJbmRleCgpPC9jb2RlPiBtZXRob2QgZWFjaCB0aW1lIHlvdSBleHBhbmQgdmFyaWFibGUgXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRyZXNldFRhYnN0b3BJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0YWJzdG9wSW5kZXggPSAwO1xuXHRcdFx0c3RhcnRQbGFjZWhvbGRlck51bSA9IDEwMDtcblx0XHR9XG5cdH07XG59KTsvKipcbiAqIENvbW1vbiBtb2R1bGUncyBwcmVmZXJlbmNlcyBzdG9yYWdlLiBUaGlzIG1vZHVsZSBcbiAqIHByb3ZpZGVzIGdlbmVyYWwgc3RvcmFnZSBmb3IgYWxsIG1vZHVsZSBwcmVmZXJlbmNlcywgdGhlaXIgZGVzY3JpcHRpb24gYW5kXG4gKiBkZWZhdWx0IHZhbHVlcy48YnI+PGJyPlxuICogXG4gKiBUaGlzIG1vZHVsZSBjYW4gYWxzbyBiZSB1c2VkIHRvIGxpc3QgYWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBcbiAqIFVJIGZvciB1cGRhdGluZyBwcm9wZXJ0aWVzXG4gKiBcbiAqIEBtZW1iZXJPZiBfX3ByZWZlcmVuY2VzRGVmaW5lXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gXyBcbiAqL1xuZW1tZXQuZGVmaW5lKCdwcmVmZXJlbmNlcycsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIHByZWZlcmVuY2VzID0ge307XG5cdHZhciBkZWZhdWx0cyA9IHt9O1xuXHR2YXIgX2RiZ0RlZmF1bHRzID0gbnVsbDtcblx0dmFyIF9kYmdQcmVmZXJlbmNlcyA9IG51bGw7XG5cblx0ZnVuY3Rpb24gdG9Cb29sZWFuKHZhbCkge1xuXHRcdGlmIChfLmlzU3RyaW5nKHZhbCkpIHtcblx0XHRcdHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSAneWVzJyB8fCB2YWwgPT0gJ3RydWUnIHx8IHZhbCA9PSAnMSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICEhdmFsO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc1ZhbHVlT2JqKG9iaikge1xuXHRcdHJldHVybiBfLmlzT2JqZWN0KG9iaikgXG5cdFx0XHQmJiAndmFsdWUnIGluIG9iaiBcblx0XHRcdCYmIF8ua2V5cyhvYmopLmxlbmd0aCA8IDM7XG5cdH1cblx0XG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBuZXcgcHJlZmVyZW5jZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByZWZlcmVuY2UgbmFtZS4gWW91IGNhbiBhbHNvIHBhc3Mgb2JqZWN0XG5cdFx0ICogd2l0aCBtYW55IG9wdGlvbnNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgUHJlZmVyZW5jZSBkZWZhdWx0IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIEl0ZW0gdGV4dHVhbCBkZXNjcmlwdGlvblxuXHRcdCAqIEBtZW1iZXJPZiBwcmVmZXJlbmNlc1xuXHRcdCAqL1xuXHRcdGRlZmluZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIGRlc2NyaXB0aW9uKSB7XG5cdFx0XHR2YXIgcHJlZnMgPSBuYW1lO1xuXHRcdFx0aWYgKF8uaXNTdHJpbmcobmFtZSkpIHtcblx0XHRcdFx0cHJlZnMgPSB7fTtcblx0XHRcdFx0cHJlZnNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRfLmVhY2gocHJlZnMsIGZ1bmN0aW9uKHYsIGspIHtcblx0XHRcdFx0ZGVmYXVsdHNba10gPSBpc1ZhbHVlT2JqKHYpID8gdiA6IHt2YWx1ZTogdn07XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgcHJlZmVyZW5jZSBpdGVtIHZhbHVlLiBQcmVmZXJlbmNlIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkXG5cdFx0ICogZmlyc3Qgd2l0aCA8Y29kZT5kZWZpbmU8L2NvZGU+IG1ldGhvZC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcmVmZXJlbmNlIG5hbWUuIFlvdSBjYW4gYWxzbyBwYXNzIG9iamVjdFxuXHRcdCAqIHdpdGggbWFueSBvcHRpb25zXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFByZWZlcmVuY2UgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqIEBtZW1iZXJPZiBwcmVmZXJlbmNlc1xuXHRcdCAqL1xuXHRcdHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHRcdHZhciBwcmVmcyA9IG5hbWU7XG5cdFx0XHRpZiAoXy5pc1N0cmluZyhuYW1lKSkge1xuXHRcdFx0XHRwcmVmcyA9IHt9O1xuXHRcdFx0XHRwcmVmc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRfLmVhY2gocHJlZnMsIGZ1bmN0aW9uKHYsIGspIHtcblx0XHRcdFx0aWYgKCEoayBpbiBkZWZhdWx0cykpIHtcblx0XHRcdFx0XHR0aHJvdyAnUHJvcGVydHkgXCInICsgayArICdcIiBpcyBub3QgZGVmaW5lZC4gWW91IHNob3VsZCBkZWZpbmUgaXQgZmlyc3Qgd2l0aCBgZGVmaW5lYCBtZXRob2Qgb2YgY3VycmVudCBtb2R1bGUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkbyBub3Qgc2V0IHZhbHVlIGlmIGl0IGVxdWFscyB0byBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGlmICh2ICE9PSBkZWZhdWx0c1trXS52YWx1ZSkge1xuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHZhbHVlIG9mIGNvcnJlY3QgdHlwZVxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZW9mIGRlZmF1bHRzW2tdLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0XHRcdFx0diA9IHRvQm9vbGVhbih2KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdudW1iZXInOlxuXHRcdFx0XHRcdFx0XHR2ID0gcGFyc2VJbnQodiArICcnLCAxMCkgfHwgMDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OiAvLyBjb252ZXJ0IHRvIHN0cmluZ1xuXHRcdFx0XHRcdFx0XHRpZiAodiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHYgKz0gJyc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcmVmZXJlbmNlc1trXSA9IHY7XG5cdFx0XHRcdH0gZWxzZSBpZiAgKGsgaW4gcHJlZmVyZW5jZXMpIHtcblx0XHRcdFx0XHRkZWxldGUgcHJlZmVyZW5jZXNba107XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBwcmVmZXJlbmNlIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gaWYgcHJlZmVyZW5jZSBpcyBcblx0XHQgKiBub3QgZGVmaW5lZFxuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0aWYgKG5hbWUgaW4gcHJlZmVyZW5jZXMpXG5cdFx0XHRcdHJldHVybiBwcmVmZXJlbmNlc1tuYW1lXTtcblx0XHRcdFxuXHRcdFx0aWYgKG5hbWUgaW4gZGVmYXVsdHMpXG5cdFx0XHRcdHJldHVybiBkZWZhdWx0c1tuYW1lXS52YWx1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgY29tbWEtc2VwYXJhdGVkIHByZWZlcmVuY2UgdmFsdWUgYXMgYXJyYXkgb2YgdmFsdWVzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBpZiBwcmVmZXJlbmNlIGlzIFxuXHRcdCAqIG5vdCBkZWZpbmVkLCA8Y29kZT5udWxsPC9jb2RlPiBpZiBzdHJpbmcgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhcnJheVxuXHRcdCAqL1xuXHRcdGdldEFycmF5OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgdmFsID0gdGhpcy5nZXQobmFtZSk7XG5cdFx0XHRpZiAoXy5pc1VuZGVmaW5lZCh2YWwpIHx8IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09ICcnKSAge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dmFsID0gXy5tYXAodmFsLnNwbGl0KCcsJyksIHJlcXVpcmUoJ3V0aWxzJykudHJpbSk7XG5cdFx0XHRpZiAoIXZhbC5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGNvbW1hIGFuZCBjb2xvbi1zZXBhcmF0ZWQgcHJlZmVyZW5jZSB2YWx1ZSBhcyBkaWN0aW9uYXJ5XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldERpY3Q6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRcdF8uZWFjaCh0aGlzLmdldEFycmF5KG5hbWUpLCBmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gdmFsLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdHJlc3VsdFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBkZXNjcmlwdGlvbiBvZiBwcmVmZXJlbmNlIGl0ZW1cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcmVmZXJlbmNlIG5hbWVcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGRlc2NyaXB0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZSBpbiBkZWZhdWx0cyA/IGRlZmF1bHRzW25hbWVdLmRlc2NyaXB0aW9uIDogdm9pZCAwO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29tcGxldGVseSByZW1vdmVzIHNwZWNpZmllZCBwcmVmZXJlbmNlKHMpXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJlZmVyZW5jZSBuYW1lIChvciBhcnJheSBvZiBuYW1lcylcblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdGlmICghXy5pc0FycmF5KG5hbWUpKVxuXHRcdFx0XHRuYW1lID0gW25hbWVdO1xuXHRcdFx0XG5cdFx0XHRfLmVhY2gobmFtZSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gcHJlZmVyZW5jZXMpXG5cdFx0XHRcdFx0ZGVsZXRlIHByZWZlcmVuY2VzW2tleV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoa2V5IGluIGRlZmF1bHRzKVxuXHRcdFx0XHRcdGRlbGV0ZSBkZWZhdWx0c1trZXldO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHNvcnRlZCBsaXN0IG9mIGFsbCBhdmFpbGFibGUgcHJvcGVydGllc1xuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKi9cblx0XHRsaXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfLm1hcChfLmtleXMoZGVmYXVsdHMpLnNvcnQoKSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bmFtZToga2V5LFxuXHRcdFx0XHRcdHZhbHVlOiB0aGlzLmdldChrZXkpLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGVvZiBkZWZhdWx0c1trZXldLnZhbHVlLFxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBkZWZhdWx0c1trZXldLmRlc2NyaXB0aW9uXG5cdFx0XHRcdH07XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIExvYWRzIHVzZXItZGVmaW5lZCBwcmVmZXJlbmNlcyBmcm9tIEpTT05cblx0XHQgKiBAcGFyYW0ge09iamVjdH0ganNvblxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0bG9hZDogZnVuY3Rpb24oanNvbikge1xuXHRcdFx0Xy5lYWNoKGpzb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBoYXNoIG9mIHVzZXItbW9kaWZpZWQgcHJlZmVyZW5jZXNcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGV4cG9ydE1vZGlmaWVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfLmNsb25lKHByZWZlcmVuY2VzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IHRvIGRlZmF1bHRzXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRwcmVmZXJlbmNlcyA9IHt9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIHVuaXQgdGVzdGluZzogdXNlIGVtcHR5IHN0b3JhZ2Vcblx0XHQgKi9cblx0XHRfc3RhcnRUZXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdF9kYmdEZWZhdWx0cyA9IGRlZmF1bHRzO1xuXHRcdFx0X2RiZ1ByZWZlcmVuY2VzID0gcHJlZmVyZW5jZXM7XG5cdFx0XHRkZWZhdWx0cyA9IHt9O1xuXHRcdFx0cHJlZmVyZW5jZXMgPSB7fTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEZvciB1bml0IHRlc3Rpbmc6IHJlc3RvcmUgb3JpZ2luYWwgc3RvcmFnZVxuXHRcdCAqL1xuXHRcdF9zdG9wVGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWZhdWx0cyA9IF9kYmdEZWZhdWx0cztcblx0XHRcdHByZWZlcmVuY2VzID0gX2RiZ1ByZWZlcmVuY2VzO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogTW9kdWxlIGZvciBoYW5kbGluZyBmaWx0ZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pIDxodHRwOi8vY2hpa3V5b25vay5ydT5cbiAqL1xuZW1tZXQuZGVmaW5lKCdmaWx0ZXJzJywgZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKiogTGlzdCBvZiByZWdpc3RlcmVkIGZpbHRlcnMgKi9cblx0dmFyIHJlZ2lzdGVyZWRGaWx0ZXJzID0ge307XG5cdFxuXHQvKiogRmlsdGVycyB0aGF0IHdpbGwgYmUgYXBwbGllZCBmb3IgdW5rbm93biBzeW50YXggKi9cblx0dmFyIGJhc2ljRmlsdGVycyA9ICdodG1sJztcblx0XG5cdGZ1bmN0aW9uIGxpc3QoZmlsdGVycykge1xuXHRcdGlmICghZmlsdGVycylcblx0XHRcdHJldHVybiBbXTtcblx0XHRcblx0XHRpZiAoXy5pc1N0cmluZyhmaWx0ZXJzKSlcblx0XHRcdHJldHVybiBmaWx0ZXJzLnNwbGl0KC9bXFx8LF0vZyk7XG5cdFx0XG5cdFx0cmV0dXJuIGZpbHRlcnM7XG5cdH1cblx0XG5cdHJldHVybiAge1xuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVyIG5ldyBmaWx0ZXJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBGaWx0ZXIgbmFtZVxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZpbHRlciBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24obmFtZSwgZm4pIHtcblx0XHRcdHJlZ2lzdGVyZWRGaWx0ZXJzW25hbWVdID0gZm47XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBcHBseSBmaWx0ZXJzIGZvciBmaW5hbCBvdXRwdXQgdHJlZVxuXHRcdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZSBPdXRwdXQgdHJlZVxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgTGlzdCBvZiBmaWx0ZXJzIHRvIGFwcGx5LiBNaWdodCBiZSBhIFxuXHRcdCAqIDxjb2RlPlN0cmluZzwvY29kZT5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZSBPdXRwdXQgcHJvZmlsZSwgZGVmaW5lZCBpbiA8aT5wcm9maWxlPC9pPiBcblx0XHQgKiBtb2R1bGUuIEZpbHRlcnMgZGVmaW5lZCBpdCBwcm9maWxlIGFyZSBub3QgdXNlZCwgPGNvZGU+cHJvZmlsZTwvY29kZT5cblx0XHQgKiBpcyBwYXNzZWQgdG8gZmlsdGVyIGZ1bmN0aW9uXG5cdFx0ICogQG1lbWJlck9mIGVtbWV0LmZpbHRlcnNcblx0XHQgKiBAcmV0dXJucyB7QWJicmV2aWF0aW9uTm9kZX1cblx0XHQgKi9cblx0XHRhcHBseTogZnVuY3Rpb24odHJlZSwgZmlsdGVycywgcHJvZmlsZSkge1xuXHRcdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcdHByb2ZpbGUgPSByZXF1aXJlKCdwcm9maWxlJykuZ2V0KHByb2ZpbGUpO1xuXHRcdFx0XG5cdFx0XHRfLmVhY2gobGlzdChmaWx0ZXJzKSwgZnVuY3Rpb24oZmlsdGVyKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdXRpbHMudHJpbShmaWx0ZXIudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdGlmIChuYW1lICYmIG5hbWUgaW4gcmVnaXN0ZXJlZEZpbHRlcnMpIHtcblx0XHRcdFx0XHR0cmVlID0gcmVnaXN0ZXJlZEZpbHRlcnNbbmFtZV0odHJlZSwgcHJvZmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJlZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbXBvc2VzIGxpc3Qgb2YgZmlsdGVycyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGEgdHJlZSwgYmFzZWQgb24gXG5cdFx0ICogcGFzc2VkIGRhdGFcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IFN5bnRheCBuYW1lICgnaHRtbCcsICdjc3MnLCBldGMuKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlIE91dHB1dCBwcm9maWxlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFkZGl0aW9uYWxGaWx0ZXJzIExpc3Qgb3IgcGlwZS1zZXBhcmF0ZWRcblx0XHQgKiBzdHJpbmcgb2YgYWRkaXRpb25hbCBmaWx0ZXJzIHRvIGFwcGx5XG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGNvbXBvc2VMaXN0OiBmdW5jdGlvbihzeW50YXgsIHByb2ZpbGUsIGFkZGl0aW9uYWxGaWx0ZXJzKSB7XG5cdFx0XHRwcm9maWxlID0gcmVxdWlyZSgncHJvZmlsZScpLmdldChwcm9maWxlKTtcblx0XHRcdHZhciBmaWx0ZXJzID0gbGlzdChwcm9maWxlLmZpbHRlcnMgfHwgcmVxdWlyZSgncmVzb3VyY2VzJykuZmluZEl0ZW0oc3ludGF4LCAnZmlsdGVycycpIHx8IGJhc2ljRmlsdGVycyk7XG5cdFx0XHRcblx0XHRcdGlmIChwcm9maWxlLmV4dHJhRmlsdGVycykge1xuXHRcdFx0XHRmaWx0ZXJzID0gZmlsdGVycy5jb25jYXQobGlzdChwcm9maWxlLmV4dHJhRmlsdGVycykpO1xuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdGlmIChhZGRpdGlvbmFsRmlsdGVycykge1xuXHRcdFx0XHRmaWx0ZXJzID0gZmlsdGVycy5jb25jYXQobGlzdChhZGRpdGlvbmFsRmlsdGVycykpO1xuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdGlmICghZmlsdGVycyB8fCAhZmlsdGVycy5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gbG9va3MgbGlrZSB1bmtub3duIHN5bnRheCwgYXBwbHkgYmFzaWMgZmlsdGVyc1xuXHRcdFx0XHRmaWx0ZXJzID0gbGlzdChiYXNpY0ZpbHRlcnMpO1xuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdHJldHVybiBmaWx0ZXJzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdHMgZmlsdGVyIGxpc3QgZnJvbSBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBjbGVhbmVkIGFiYnJldmlhdGlvbiBhbmQgbGlzdCBvZiBcblx0XHQgKiBleHRyYWN0ZWQgZmlsdGVyc1xuXHRcdCAqL1xuXHRcdGV4dHJhY3RGcm9tQWJicmV2aWF0aW9uOiBmdW5jdGlvbihhYmJyKSB7XG5cdFx0XHR2YXIgZmlsdGVycyA9ICcnO1xuXHRcdFx0YWJiciA9IGFiYnIucmVwbGFjZSgvXFx8KFtcXHdcXHxcXC1dKykkLywgZnVuY3Rpb24oc3RyLCBwMSl7XG5cdFx0XHRcdGZpbHRlcnMgPSBwMTtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBbYWJiciwgbGlzdChmaWx0ZXJzKV07XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBNb2R1bGUgdGhhdCBjb250YWlucyBmYWN0b3JpZXMgZm9yIGVsZW1lbnQgdHlwZXMgdXNlZCBieSBFbW1ldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmRlZmluZSgnZWxlbWVudHMnLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciBmYWN0b3JpZXMgPSB7fTtcblx0dmFyIHJlQXR0cnMgPSAvKFtcXHdcXC06XSspXFxzKj1cXHMqKFsnXCJdKSguKj8pXFwyL2c7XG5cdFxuXHR2YXIgcmVzdWx0ID0ge1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBuZXcgZWxlbWVudCBmYWN0b3J5XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgRWxlbWVudCBpZGVudGlmaWVyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZmFjdG9yeSBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGVsZW1lbnQgb2Ygc3BlY2lmaWVkIFxuXHRcdCAqIHR5cGUuIFRoZSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHRoaXMgZmFjdG9yeSBpcyBhdXRvbWF0aWNhbGx5IFxuXHRcdCAqIGF1Z21lbnRlZCB3aXRoIDxjb2RlPnR5cGU8L2NvZGU+IHByb3BlcnR5IHBvaW50aW5nIHRvIGVsZW1lbnRcblx0XHQgKiA8Y29kZT5uYW1lPC9jb2RlPlxuXHRcdCAqIEBtZW1iZXJPZiBlbGVtZW50c1xuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24obmFtZSwgZmFjdG9yeSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0ZmFjdG9yaWVzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gZmFjdG9yeS5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAoZWxlbSlcblx0XHRcdFx0XHRlbGVtLnR5cGUgPSBuYW1lO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBmYWN0b3J5IGZvciBzcGVjaWZpZWQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdFx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIGZhY3Rvcmllc1tuYW1lXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgbmV3IGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgdHlwZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdFx0ICogQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdFx0dmFyIGZhY3RvcnkgPSB0aGlzLmdldChuYW1lKTtcblx0XHRcdHJldHVybiBmYWN0b3J5ID8gZmFjdG9yeS5hcHBseSh0aGlzLCBhcmdzKSA6IG51bGw7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBpcyBvZiBzcGVjaWZpZWQgdHlwZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpczogZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xuXHRcdFx0cmV0dXJuIGVsZW0gJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHRcdH1cblx0fTtcblx0XG5cdC8vIHJlZ2lzdGVyIHJlc291cmNlIHJlZmVyZW5jZXNcblx0ZnVuY3Rpb24gY29tbW9uRmFjdG9yeSh2YWx1ZSkge1xuXHRcdHJldHVybiB7ZGF0YTogdmFsdWV9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogRWxlbWVudCBmYWN0b3J5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtZW50TmFtZSBOYW1lIG9mIG91dHB1dCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBBdHRyaWJ1dGVzIGRlZmluaXRpb24uIFlvdSBtYXkgYWxzbyBwYXNzXG5cdCAqIDxjb2RlPkFycmF5PC9jb2RlPiB3aGVyZSBlYWNoIGNvbnRhaW5zIG9iamVjdCB3aXRoIDxjb2RlPm5hbWU8L2NvZGU+IFxuXHQgKiBhbmQgPGNvZGU+dmFsdWU8L2NvZGU+IHByb3BlcnRpZXMsIG9yIDxjb2RlPk9iamVjdDwvY29kZT5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0VtcHR5IElzIGV4cGFuZGVkIGVsZW1lbnQgc2hvdWxkIGJlIGVtcHR5XG5cdCAqL1xuXHRyZXN1bHQuYWRkKCdlbGVtZW50JywgZnVuY3Rpb24oZWxlbWVudE5hbWUsIGF0dHJzLCBpc0VtcHR5KSB7XG5cdFx0dmFyIHJldCA9IHtcblx0XHRcdC8qKiBAbWVtYmVyT2YgX19lbW1ldERhdGFFbGVtZW50ICovXG5cdFx0XHRuYW1lOiBlbGVtZW50TmFtZSxcblx0XHRcdGlzX2VtcHR5OiAhIWlzRW1wdHlcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChhdHRycykge1xuXHRcdFx0cmV0LmF0dHJpYnV0ZXMgPSBbXTtcblx0XHRcdGlmIChfLmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0XHRcdHJldC5hdHRyaWJ1dGVzID0gYXR0cnM7XG5cdFx0XHR9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXR0cnMpKSB7XG5cdFx0XHRcdHZhciBtO1xuXHRcdFx0XHR3aGlsZSAobSA9IHJlQXR0cnMuZXhlYyhhdHRycykpIHtcblx0XHRcdFx0XHRyZXQuYXR0cmlidXRlcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IG1bMV0sXG5cdFx0XHRcdFx0XHR2YWx1ZTogbVszXVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfLmVhY2goYXR0cnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdFx0cmV0LmF0dHJpYnV0ZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLCBcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJldDtcblx0fSk7XG5cdFxuXHRyZXN1bHQuYWRkKCdzbmlwcGV0JywgY29tbW9uRmFjdG9yeSk7XG5cdHJlc3VsdC5hZGQoJ3JlZmVyZW5jZScsIGNvbW1vbkZhY3RvcnkpO1xuXHRyZXN1bHQuYWRkKCdlbXB0eScsIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gcmVzdWx0O1xufSk7LyoqXG4gKiBBYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBlZGl0IHRyZWUgaW50ZXJmYWNlLlxuICogRWRpdCB0cmVlIGlzIGEgbmFtZWQgY29udGFpbmVyIG9mIGVkaXRhYmxlIOKAnG5hbWUtdmFsdWXigJ0gY2hpbGQgZWxlbWVudHMsIFxuICogcGFyc2VkIGZyb20gPGNvZGU+c291cmNlPC9jb2RlPi4gVGhpcyBjb250YWluZXIgcHJvdmlkZXMgY29udmVuaWVudCBtZXRob2RzXG4gKiBmb3IgZWRpdGluZy9hZGRpbmcvcmVtb3ZpbmcgY2hpbGQgZWxlbWVudHMuIEFsbCB0aGVzZSB1cGRhdGUgYWN0aW9ucyBhcmVcbiAqIGluc3RhbnRseSByZWZsZWN0ZWQgaW4gdGhlIDxjb2RlPnNvdXJjZTwvY29kZT4gY29kZSB3aXRoIHJlc3BlY3Qgb2YgZm9ybWF0dGluZy5cbiAqIDxicj48YnI+XG4gKiBGb3IgZXhhbXBsZSwgZGV2ZWxvcGVyIGNhbiBjcmVhdGUgYW4gZWRpdCB0cmVlIGZyb20gQ1NTIHJ1bGUgYW5kIGFkZCBvciBcbiAqIHJlbW92ZSBwcm9wZXJ0aWVzIGZyb20gaXTigJNhbGwgY2hhbmdlcyB3aWxsIGJlIGltbWVkaWF0ZWx5IHJlZmxlY3RlZCBpbiB0aGUgXG4gKiBvcmlnaW5hbCBzb3VyY2UuXG4gKiA8YnI+PGJyPlxuICogQWxsIGNsYXNzZXMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSBzaG91bGQgYmUgZXh0ZW5kZWQgdGhlIHNhbWUgd2F5IGFzIGluXG4gKiBCYWNrYm9uZSBmcmFtZXdvcms6IHVzaW5nIDxjb2RlPmV4dGVuZDwvY29kZT4gbWV0aG9kIHRvIGNyZWF0ZSBuZXcgY2xhc3MgYW5kIFxuICogPGNvZGU+aW5pdGlhbGl6ZTwvY29kZT4gbWV0aG9kIHRvIGRlZmluZSBjdXN0b20gY2xhc3MgY29uc3RydWN0b3IuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiA8cHJlPjxjb2RlPlxuICogdmFyIE15Q2xhc3MgPSByZXF1aXJlKCdlZGl0VHJlZScpLkVkaXRFbGVtZW50LmV4dGVuZCh7XG4gKiBcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICogXHRcdC8vIGNvbnN0cnVjdG9yIGNvZGUgaGVyZVxuICogXHR9XG4gKiB9KTtcbiAqIFxuICogdmFyIGVsZW0gPSBuZXcgTXlDbGFzcygpOyBcbiAqIDwvY29kZT48L3ByZT5cbiAqIFxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqIEBjb25zdHJ1Y3RvclxuICogQG1lbWJlck9mIF9fZWRpdFRyZWVEZWZpbmVcbiAqL1xuZW1tZXQuZGVmaW5lKCdlZGl0VHJlZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8sIGNvcmUpIHtcblx0dmFyIHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGU7XG5cdFxuXHQvKipcblx0ICogTmFtZWQgY29udGFpbmVyIG9mIGVkaXRlZCBzb3VyY2Vcblx0ICogQHR5cGUgRWRpdENvbnRhaW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBFZGl0Q29udGFpbmVyKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHtvZmZzZXQ6IDB9LCBvcHRpb25zKTtcblx0XHQvKipcblx0XHQgKiBTb3VyY2UgY29kZSBvZiBlZGl0ZWQgc3RydWN0dXJlLiBBbGwgY2hhbmdlcyBpbiB0aGUgc3RydWN0dXJlIGFyZSBcblx0XHQgKiBpbW1lZGlhdGVseSByZWZsZWN0ZWQgaW50byB0aGlzIHByb3BlcnR5XG5cdFx0ICovXG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIExpc3Qgb2YgYWxsIGVkaXRhYmxlIGNoaWxkcmVuXG5cdFx0ICogQHByaXZhdGUgXG5cdFx0ICovXG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBIYXNoIG9mIGFsbCBwb3NpdGlvbnMgb2YgY29udGFpbmVyXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb3NpdGlvbnMgPSB7XG5cdFx0XHRuYW1lOiAwXG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRoZSBzZWxmLXByb3BhZ2F0aW5nIGV4dGVuZCBmdW5jdGlvbiBmb3IgY2xhc3Nlcy5cblx0ICogQHR5cGUgRnVuY3Rpb25cblx0ICovXG5cdEVkaXRDb250YWluZXIuZXh0ZW5kID0gY29yZS5leHRlbmQ7XG5cdFxuXHRFZGl0Q29udGFpbmVyLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBDaGlsZCBjbGFzcyBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZSBzdWJzdHJpbmcgb2YgdGFnJ3Mgc291cmNlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3VwZGF0ZVNvdXJjZTogZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcblx0XHRcdC8vIGNyZWF0ZSBtb2RpZmljYXRpb24gcmFuZ2Vcblx0XHRcdHZhciByID0gcmFuZ2Uoc3RhcnQsIF8uaXNVbmRlZmluZWQoZW5kKSA/IDAgOiBlbmQgLSBzdGFydCk7XG5cdFx0XHR2YXIgZGVsdGEgPSB2YWx1ZS5sZW5ndGggLSByLmxlbmd0aCgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgdXBkYXRlID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGspIHtcblx0XHRcdFx0XHRpZiAodiA+PSByLmVuZClcblx0XHRcdFx0XHRcdG9ialtrXSArPSBkZWx0YTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyB1cGRhdGUgYWZmZWN0ZWQgcG9zaXRpb25zIG9mIGN1cnJlbnQgY29udGFpbmVyXG5cdFx0XHR1cGRhdGUodGhpcy5fcG9zaXRpb25zKTtcblx0XHRcdFxuXHRcdFx0Ly8gdXBkYXRlIGFmZmVjdGVkIHBvc2l0aW9ucyBvZiBjaGlsZHJlblxuXHRcdFx0Xy5lYWNoKHRoaXMubGlzdCgpLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHVwZGF0ZShpdGVtLl9wb3NpdGlvbnMpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuc291cmNlID0gcmVxdWlyZSgndXRpbHMnKS5yZXBsYWNlU3Vic3RyaW5nKHRoaXMuc291cmNlLCB2YWx1ZSwgcik7XG5cdFx0fSxcblx0XHRcdFxuXHRcdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBuZXcgYXR0cmlidXRlIFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgUHJvcGVydHkgdmFsdWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zIFBvc2l0aW9uIGF0IHdoaWNoIHRvIGluc2VydCBuZXcgcHJvcGVydHkuIEJ5IFxuXHRcdCAqIGRlZmF1bHQgdGhlIHByb3BlcnR5IGlzIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgcnVsZSBcblx0XHQgKiBAcmV0dXJucyB7RWRpdEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHBvcykge1xuXHRcdFx0Ly8gdGhpcyBpcyBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvblxuXHRcdFx0dmFyIGl0ZW0gPSBuZXcgRWRpdEVsZW1lbnQobmFtZSwgdmFsdWUpO1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucHVzaChpdGVtKTtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhdHRyaWJ1dGUgb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWUgb3IgaXRzIGluZGV4XG5cdFx0ICogQHJldHVybnMge0VkaXRFbGVtZW50fVxuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0aWYgKF8uaXNOdW1iZXIobmFtZSkpXG5cdFx0XHRcdHJldHVybiB0aGlzLmxpc3QoKVtuYW1lXTtcblx0XHRcdFxuXHRcdFx0aWYgKF8uaXNTdHJpbmcobmFtZSkpXG5cdFx0XHRcdHJldHVybiBfLmZpbmQodGhpcy5saXN0KCksIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvcC5uYW1lKCkgPT09IG5hbWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWxsIGNoaWxkcmVuIGJ5IG5hbWUgb3IgaW5kZXhlc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lIEVsZW1lbnQgbmFtZShzKSBvciBpbmRleGVzICg8Y29kZT5TdHJpbmc8L2NvZGU+LFxuXHRcdCAqIDxjb2RlPkFycmF5PC9jb2RlPiwgPGNvZGU+TnVtYmVyPC9jb2RlPilcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0QWxsOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRpZiAoIV8uaXNBcnJheShuYW1lKSlcblx0XHRcdFx0bmFtZSA9IFtuYW1lXTtcblx0XHRcdFxuXHRcdFx0Ly8gc3BsaXQgbmFtZXMgYW5kIGluZGV4ZXNcblx0XHRcdHZhciBuYW1lcyA9IFtdLCBpbmRleGVzID0gW107XG5cdFx0XHRfLmVhY2gobmFtZSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRpZiAoXy5pc1N0cmluZyhpdGVtKSlcblx0XHRcdFx0XHRuYW1lcy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRlbHNlIGlmIChfLmlzTnVtYmVyKGl0ZW0pKVxuXHRcdFx0XHRcdGluZGV4ZXMucHVzaChpdGVtKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXy5maWx0ZXIodGhpcy5saXN0KCksIGZ1bmN0aW9uKGF0dHJpYnV0ZSwgaSkge1xuXHRcdFx0XHRyZXR1cm4gXy5pbmNsdWRlKGluZGV4ZXMsIGkpIHx8IF8uaW5jbHVkZShuYW1lcywgYXR0cmlidXRlLm5hbWUoKSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgb3IgdXBkYXRlcyBlbGVtZW50IHZhbHVlLiBJZiBzdWNoIGVsZW1lbnQgZG9lc24ndCBleGlzdHMsXG5cdFx0ICogaXQgd2lsbCBiZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgYW5kIGFkZGVkIGF0IHRoZSBlbmQgb2YgY2hpbGQgbGlzdC5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBFbGVtZW50IG5hbWUgb3IgaXRzIGluZGV4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIE5ldyBlbGVtZW50IHZhbHVlXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHBvcykge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldChuYW1lKTtcblx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRyZXR1cm4gZWxlbWVudC52YWx1ZSh2YWx1ZSk7XG5cdFx0XHRcblx0XHRcdGlmICghXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcblx0XHRcdFx0Ly8gbm8gc3VjaCBlbGVtZW50IOKAlCBjcmVhdGUgaXRcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkKG5hbWUsIHZhbHVlLCBwb3MpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbGwgdmFsdWVzIG9mIGNoaWxkIGVsZW1lbnRzIGZvdW5kIGJ5IDxjb2RlPmdldEFsbCgpPC9jb2RlPlxuXHRcdCAqIG1ldGhvZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lIEVsZW1lbnQgbmFtZShzKSBvciBpbmRleGVzICg8Y29kZT5TdHJpbmc8L2NvZGU+LFxuXHRcdCAqIDxjb2RlPkFycmF5PC9jb2RlPiwgPGNvZGU+TnVtYmVyPC9jb2RlPilcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0dmFsdWVzOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gXy5tYXAodGhpcy5nZXRBbGwobmFtZSksIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudmFsdWUoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGNoaWxkIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIG9yIGl0cyBpbmRleFxuXHRcdCAqL1xuXHRcdHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldChuYW1lKTtcblx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZSgnJywgZWxlbWVudC5mdWxsUmFuZ2UoKSk7XG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuID0gXy53aXRob3V0KHRoaXMuX2NoaWxkcmVuLCBlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBhbGwgZWRpdGFibGUgY2hpbGQgZWxlbWVudHNcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGluZGV4IG9mIGVkaXRibGUgY2hpbGQgaW4gbGlzdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdFx0ICogQHJldHVybnMge051bWJlcn1cblx0XHQgKi9cblx0XHRpbmRleE9mOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRyZXR1cm4gXy5pbmRleE9mKHRoaXMubGlzdCgpLCB0aGlzLmdldChpdGVtKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBTZXRzIG9yIGdldHMgY29udGFpbmVyIG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsIE5ldyBuYW1lLiBJZiBub3QgcGFzc2VkLCBjdXJyZW50IFxuXHRcdCAqIG5hbWUgaXMgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0bmFtZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZiAoIV8uaXNVbmRlZmluZWQodmFsKSAmJiB0aGlzLl9uYW1lICE9PSAodmFsID0gU3RyaW5nKHZhbCkpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZSh2YWwsIHRoaXMuX3Bvc2l0aW9ucy5uYW1lLCB0aGlzLl9wb3NpdGlvbnMubmFtZSArIHRoaXMuX25hbWUubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy5fbmFtZSA9IHZhbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG5hbWUgcmFuZ2Ugb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlIFJldHVybiBhYnNvbHV0ZSByYW5nZSAod2l0aCByZXNwZWN0IG9mIFxuXHRcdCAqIHJ1bGUgb2Zmc2V0KVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRuYW1lUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiByYW5nZSh0aGlzLl9wb3NpdGlvbnMubmFtZSArIChpc0Fic29sdXRlID8gdGhpcy5vcHRpb25zLm9mZnNldCA6IDApLCB0aGlzLm5hbWUoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHJhbmdlIG9mIGN1cnJlbnQgc291cmNlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlXG5cdFx0ICovXG5cdFx0cmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiByYW5nZShpc0Fic29sdXRlID8gdGhpcy5vcHRpb25zLm9mZnNldCA6IDAsIHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGVsZW1lbnQgdGhhdCBiZWxvbmdzIHRvIHNwZWNpZmllZCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3Ncblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGVcblx0XHQgKiBAcmV0dXJucyB7RWRpdEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0aXRlbUZyb21Qb3NpdGlvbjogZnVuY3Rpb24ocG9zLCBpc0Fic29sdXRlKSB7XG5cdFx0XHRyZXR1cm4gXy5maW5kKHRoaXMubGlzdCgpLCBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLnJhbmdlKGlzQWJzb2x1dGUpLmluc2lkZShwb3MpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHNvdXJjZSBjb2RlIG9mIGN1cnJlbnQgY29udGFpbmVyIFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc291cmNlO1xuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VkaXRDb250YWluZXJ9IHBhcmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbmFtZVRva2VuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVRva2VuXG5cdCAqL1xuXHRmdW5jdGlvbiBFZGl0RWxlbWVudChwYXJlbnQsIG5hbWVUb2tlbiwgdmFsdWVUb2tlbikge1xuXHRcdC8qKiBAdHlwZSBFZGl0Q29udGFpbmVyICovXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWVUb2tlbi52YWx1ZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlVG9rZW4gPyB2YWx1ZVRva2VuLnZhbHVlIDogJyc7XG5cdFx0XG5cdFx0dGhpcy5fcG9zaXRpb25zID0ge1xuXHRcdFx0bmFtZTogbmFtZVRva2VuLnN0YXJ0LFxuXHRcdFx0dmFsdWU6IHZhbHVlVG9rZW4gPyB2YWx1ZVRva2VuLnN0YXJ0IDogLTFcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGhlIHNlbGYtcHJvcGFnYXRpbmcgZXh0ZW5kIGZ1bmN0aW9uIGZvciBjbGFzc2VzLlxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKi9cblx0RWRpdEVsZW1lbnQuZXh0ZW5kID0gY29yZS5leHRlbmQ7XG5cdFxuXHRFZGl0RWxlbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQ2hpbGQgY2xhc3MgY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHt9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE1ha2UgcG9zaXRpb24gYWJzb2x1dGVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRfcG9zOiBmdW5jdGlvbihudW0sIGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiBudW0gKyAoaXNBYnNvbHV0ZSA/IHRoaXMucGFyZW50Lm9wdGlvbnMub2Zmc2V0IDogMCk7XG5cdFx0fSxcblx0XHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgb2YgZ2V0cyBlbGVtZW50IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbCBOZXcgZWxlbWVudCB2YWx1ZS4gSWYgbm90IHBhc3NlZCwgY3VycmVudCBcblx0XHQgKiB2YWx1ZSBpcyByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0aWYgKCFfLmlzVW5kZWZpbmVkKHZhbCkgJiYgdGhpcy5fdmFsdWUgIT09ICh2YWwgPSBTdHJpbmcodmFsKSkpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQuX3VwZGF0ZVNvdXJjZSh2YWwsIHRoaXMudmFsdWVSYW5nZSgpKTtcblx0XHRcdFx0dGhpcy5fdmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgb2YgZ2V0cyBlbGVtZW50IG5hbWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsIE5ldyBlbGVtZW50IG5hbWUuIElmIG5vdCBwYXNzZWQsIGN1cnJlbnQgXG5cdFx0ICogbmFtZSBpcyByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0bmFtZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZiAoIV8uaXNVbmRlZmluZWQodmFsKSAmJiB0aGlzLl9uYW1lICE9PSAodmFsID0gU3RyaW5nKHZhbCkpKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Ll91cGRhdGVTb3VyY2UodmFsLCB0aGlzLm5hbWVSYW5nZSgpKTtcblx0XHRcdFx0dGhpcy5fbmFtZSA9IHZhbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHBvc2l0aW9uIG9mIGVsZW1lbnQgbmFtZSB0b2tlblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcG9zaXRpb25cblx0XHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdG5hbWVQb3NpdGlvbjogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Bvcyh0aGlzLl9wb3NpdGlvbnMubmFtZSwgaXNBYnNvbHV0ZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHBvc2l0aW9uIG9mIGVsZW1lbnQgdmFsdWUgdG9rZW5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHBvc2l0aW9uXG5cdFx0ICogQHJldHVybnMge051bWJlcn1cblx0XHQgKi9cblx0XHR2YWx1ZVBvc2l0aW9uOiBmdW5jdGlvbihpc0Fic29sdXRlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcG9zKHRoaXMuX3Bvc2l0aW9ucy52YWx1ZSwgaXNBYnNvbHV0ZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGVsZW1lbnQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcmFuZ2UgXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqL1xuXHRcdHJhbmdlOiBmdW5jdGlvbihpc0Fic29sdXRlKSB7XG5cdFx0XHRyZXR1cm4gcmFuZ2UodGhpcy5uYW1lUG9zaXRpb24oaXNBYnNvbHV0ZSksIHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGZ1bGwgZWxlbWVudCByYW5nZSwgaW5jbHVkaW5nIHBvc3NpYmxlIGluZGVudGF0aW9uXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc0Fic29sdXRlIFJldHVybiBhYnNvbHV0ZSByYW5nZVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRmdWxsUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiB0aGlzLnJhbmdlKGlzQWJzb2x1dGUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBlbGVtZW50IG5hbWUgcmFuZ2Vcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHJhbmdlXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqL1xuXHRcdG5hbWVSYW5nZTogZnVuY3Rpb24oaXNBYnNvbHV0ZSkge1xuXHRcdFx0cmV0dXJuIHJhbmdlKHRoaXMubmFtZVBvc2l0aW9uKGlzQWJzb2x1dGUpLCB0aGlzLm5hbWUoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGVsZW1lbnQgdmFsdWUgcmFuZ2Vcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHJhbmdlXG5cdFx0ICogQHJldHVybnMge1JhbmdlfVxuXHRcdCAqL1xuXHRcdHZhbHVlUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHJldHVybiByYW5nZSh0aGlzLnZhbHVlUG9zaXRpb24oaXNBYnNvbHV0ZSksIHRoaXMudmFsdWUoKSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGN1cnJlbnQgZWxlbWVudCBzdHJpbmcgcmVwcmVzZW50YXRpb25cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm5hbWUoKSArIHRoaXMudmFsdWUoKTtcblx0XHR9LFxuXHRcdFxuXHRcdHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcblx0XHR9XG5cdH07XG5cdFxuXHRyZXR1cm4ge1xuXHRcdEVkaXRDb250YWluZXI6IEVkaXRDb250YWluZXIsXG5cdFx0RWRpdEVsZW1lbnQ6IEVkaXRFbGVtZW50LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgdG9rZW4gdGhhdCBjYW4gYmUgZmVkIHRvIDxjb2RlPkVkaXRFbGVtZW50PC9jb2RlPlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRjcmVhdGVUb2tlbjogZnVuY3Rpb24oc3RhcnQsIHZhbHVlLCB0eXBlKSB7XG5cdFx0XHR2YXIgb2JqID0ge1xuXHRcdFx0XHRzdGFydDogc3RhcnQgfHwgMCxcblx0XHRcdFx0dmFsdWU6IHZhbHVlIHx8ICcnLFxuXHRcdFx0XHR0eXBlOiB0eXBlXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRvYmouZW5kID0gb2JqLnN0YXJ0ICsgb2JqLnZhbHVlLmxlbmd0aDtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXHR9O1xufSk7LyoqXG4gKiBDU1MgRWRpdFRyZWUgaXMgYSBtb2R1bGUgdGhhdCBjYW4gcGFyc2UgYSBDU1MgcnVsZSBpbnRvIGEgdHJlZSB3aXRoIFxuICogY29udmVuaWVudCBtZXRob2RzIGZvciBhZGRpbmcsIG1vZGlmeWluZyBhbmQgcmVtb3ZpbmcgQ1NTIHByb3BlcnRpZXMuIFRoZXNlIFxuICogY2hhbmdlcyBjYW4gYmUgd3JpdHRlbiBiYWNrIHRvIHN0cmluZyB3aXRoIHJlc3BlY3Qgb2YgY29kZSBmb3JtYXR0aW5nLlxuICogXG4gKiBAbWVtYmVyT2YgX19jc3NFZGl0VHJlZURlZmluZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF8gXG4gKi9cbmVtbWV0LmRlZmluZSgnY3NzRWRpdFRyZWUnLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRzdHlsZUJlZm9yZTogJ1xcblxcdCcsXG5cdFx0c3R5bGVTZXBhcmF0b3I6ICc6ICcsXG5cdFx0b2Zmc2V0OiAwXG5cdH07XG5cdFxuXHR2YXIgV0hJVEVTUEFDRV9SRU1PVkVfRlJPTV9TVEFSVCA9IDE7XG5cdHZhciBXSElURVNQQUNFX1JFTU9WRV9GUk9NX0VORCAgID0gMjtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJhbmdlIG9iamVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlbiBcblx0ICogQHJldHVybnMge1JhbmdlfVxuXHQgKi9cblx0ZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGxlbikge1xuXHRcdHJldHVybiByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShzdGFydCwgbGVuKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlbW92ZXMgd2hpdGVzcGFjZSB0b2tlbnMgZnJvbSB0aGUgYXJyYXkgZW5kc1xuXHQgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1hc2sgTWFzayBpbmRpY2F0aW5nIGZyb20gd2hpY2ggZW5kIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIFxuXHQgKiByZW1vdmVkIFxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRmdW5jdGlvbiB0cmltV2hpdGVzcGFjZVRva2Vucyh0b2tlbnMsIG1hc2spIHtcblx0XHRtYXNrID0gbWFzayB8fCAoV0hJVEVTUEFDRV9SRU1PVkVfRlJPTV9TVEFSVCB8IFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fRU5EKTtcblx0XHR2YXIgd2hpdGVzcGFjZSA9IFsnd2hpdGUnLCAnbGluZSddO1xuXHRcdFxuXHRcdGlmICgobWFzayAmIFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fRU5EKSA9PSBXSElURVNQQUNFX1JFTU9WRV9GUk9NX0VORClcblx0XHRcdHdoaWxlICh0b2tlbnMubGVuZ3RoICYmIF8uaW5jbHVkZSh3aGl0ZXNwYWNlLCBfLmxhc3QodG9rZW5zKS50eXBlKSkge1xuXHRcdFx0XHR0b2tlbnMucG9wKCk7XG5cdCBcdFx0fVxuXHRcdFxuXHRcdGlmICgobWFzayAmIFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fU1RBUlQpID09IFdISVRFU1BBQ0VfUkVNT1ZFX0ZST01fU1RBUlQpXG5cdFx0XHR3aGlsZSAodG9rZW5zLmxlbmd0aCAmJiBfLmluY2x1ZGUod2hpdGVzcGFjZSwgdG9rZW5zWzBdLnR5cGUpKSB7XG5cdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0b2tlbnM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBmb3Igc2VsZWN0b3IgcmFuZ2UgZm9yIDxjb2RlPkNTU0VkaXRSdWxlPC9jb2RlPlxuXHQgKiBAcGFyYW0ge1Rva2VuSXRlcmF0b3J9IGl0XG5cdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRTZWxlY3RvclJhbmdlKGl0KSB7XG5cdFx0dmFyIHRva2VucyA9IFtdLCB0b2tlbjtcbiBcdFx0dmFyIHN0YXJ0ID0gaXQucG9zaXRpb24oKSwgZW5kO1xuIFx0XHRcbiBcdFx0d2hpbGUgKHRva2VuID0gaXQubmV4dCgpKSB7XG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PSAneycpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0dG9rZW5zLnB1c2godG9rZW4pO1xuXHRcdH1cbiBcdFx0XG4gXHRcdHRyaW1XaGl0ZXNwYWNlVG9rZW5zKHRva2Vucyk7XG4gXHRcdFxuIFx0XHRpZiAodG9rZW5zLmxlbmd0aCkge1xuIFx0XHRcdHN0YXJ0ID0gdG9rZW5zWzBdLnN0YXJ0O1xuIFx0XHRcdGVuZCA9IF8ubGFzdCh0b2tlbnMpLmVuZDtcbiBcdFx0fSBlbHNlIHtcbiBcdFx0XHRlbmQgPSBzdGFydDtcbiBcdFx0fVxuIFx0XHRcbiBcdFx0cmV0dXJuIHJhbmdlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBmb3IgQ1NTIHByb3BlcnR5IHZhbHVlIHJhbmdlIG5leHQgdG9cblx0ICogaXRlcmF0b3IncyBjdXJyZW50IHBvc2l0aW9uICBcblx0ICogQHBhcmFtIHtUb2tlbkl0ZXJhdG9yfSBpdFxuXHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kVmFsdWVSYW5nZShpdCkge1xuXHRcdC8vIGZpbmQgdmFsdWUgc3RhcnQgcG9zaXRpb25cblx0XHR2YXIgc2tpcFRva2VucyA9IFsnd2hpdGUnLCAnbGluZScsICc6J107XG5cdFx0dmFyIHRva2VucyA9IFtdLCB0b2tlbiwgc3RhcnQsIGVuZDtcblx0XHRcblx0XHRpdC5uZXh0VW50aWwoZnVuY3Rpb24odG9rKSB7XG5cdFx0XHRyZXR1cm4gIV8uaW5jbHVkZShza2lwVG9rZW5zLCB0aGlzLml0ZW1OZXh0KCkudHlwZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0c3RhcnQgPSBpdC5jdXJyZW50KCkuZW5kO1xuXHRcdC8vIGNvbnN1bWUgdmFsdWVcblx0XHR3aGlsZSAodG9rZW4gPSBpdC5uZXh0KCkpIHtcblx0XHRcdGlmICh0b2tlbi50eXBlID09ICd9JyB8fCB0b2tlbi50eXBlID09ICc7Jykge1xuXHRcdFx0XHQvLyBmb3VuZCB2YWx1ZSBlbmRcblx0XHRcdFx0dHJpbVdoaXRlc3BhY2VUb2tlbnModG9rZW5zLCBXSElURVNQQUNFX1JFTU9WRV9GUk9NX1NUQVJUIFxuXHRcdFx0XHRcdFx0fCAodG9rZW4udHlwZSA9PSAnfScgPyBXSElURVNQQUNFX1JFTU9WRV9GUk9NX0VORCA6IDApKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0c3RhcnQgPSB0b2tlbnNbMF0uc3RhcnQ7XG5cdFx0XHRcdFx0ZW5kID0gXy5sYXN0KHRva2VucykuZW5kO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVuZCA9IHN0YXJ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dG9rZW5zLnB1c2godG9rZW4pO1xuXHRcdH1cblx0XHRcblx0XHQvLyByZWFjaGVkIHRoZSBlbmQgb2YgdG9rZW5zIGxpc3Rcblx0XHRpZiAodG9rZW5zLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHJhbmdlKHRva2Vuc1swXS5zdGFydCwgXy5sYXN0KHRva2VucykuZW5kIC0gdG9rZW5zWzBdLnN0YXJ0KTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBGaW5kcyBwYXJ0cyBvZiBjb21wbGV4IENTUyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBsaXN0IG9mIDxjb2RlPlJhbmdlPC9jb2RlPidzXG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kUGFydHMoc3RyKSB7XG5cdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdHZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJpbmdTdHJlYW0nKS5jcmVhdGUoc3RyKTtcblx0XHR2YXIgY2g7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBzZXAgPSAvW1xcc1xcdTAwYTAsXS87XG5cdFx0XG5cdFx0dmFyIGFkZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlKHN0cmVhbS5zdGFydCwgc3RyZWFtLmN1cnJlbnQoKSkpO1xuXHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNraXAgd2hpdGVzcGFjZVxuXHRcdHN0cmVhbS5lYXRTcGFjZSgpO1xuXHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XG5cdFx0d2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuXHRcdFx0aWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcblx0XHRcdFx0c3RyZWFtLm5leHQoKTtcblx0XHRcdFx0aWYgKCFzdHJlYW0uc2tpcFRvKGNoKSkgYnJlYWs7XG5cdFx0XHRcdGFkZCgpO1xuXHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnKCcpIHtcblx0XHRcdFx0Ly8gZnVuY3Rpb24gZm91bmQsIG1heSBoYXZlIG5lc3RlZCBmdW5jdGlvblxuXHRcdFx0XHRzdHJlYW0uYmFja1VwKDEpO1xuXHRcdFx0XHRpZiAoIXN0cmVhbS5za2lwVG9QYWlyKCcoJywgJyknKSkgYnJlYWs7XG5cdFx0XHRcdHN0cmVhbS5iYWNrVXAoMSk7XG5cdFx0XHRcdGFkZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNlcC50ZXN0KGNoKSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlKHN0cmVhbS5zdGFydCwgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggLSAxKSk7XG5cdFx0XHRcdFx0c3RyZWFtLmVhdFdoaWxlKHNlcCk7XG5cdFx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRhZGQoKTtcblx0XHRcblx0XHRyZXR1cm4gXy5jaGFpbihyZXN1bHQpXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuICEhaXRlbS5sZW5ndGgoKTtcblx0XHRcdH0pXG5cdFx0XHQudW5pcShmYWxzZSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbS50b1N0cmluZygpO1xuXHRcdFx0fSlcblx0XHRcdC52YWx1ZSgpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQSBiaXQgaGFja3kgd2F5IHRvIGlkZW50aWZ5IGludmFsaWQgQ1NTIHByb3BlcnR5IGRlZmluaXRpb246IHdoZW4gdXNlclxuXHQgKiBzdGFydHMgd3JpdGluZyBuZXcgYWJicmV2aWF0aW9uIGluIENTUyBydWxlLCBoZSBhY3R1YWxseSBjcmVhdGVzIGludmFsaWRcblx0ICogQ1NTIHByb3BlcnR5IGRlZmluaXRpb24gYW5kIHRoaXMgbWV0aG9kIHRyaWVzIHRvIGlkZW50aWZ5IHN1Y2ggYWJicmV2aWF0aW9uXG5cdCAqIGFuZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgdG8gQ1NTIGVkaXQgdHJlZSBcblx0ICogQHBhcmFtIHtUb2tlbkl0ZXJhdG9yfSBpdFxuXHQgKi9cblx0ZnVuY3Rpb24gaXNWYWxpZElkZW50aWZpZXIoaXQpIHtcbi8vXHRcdHJldHVybiB0cnVlO1xuXHRcdHZhciB0b2tlbnMgPSBpdC50b2tlbnM7XG5cdFx0Zm9yICh2YXIgaSA9IGl0Ll9pICsgMSwgaWwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0aWYgKHRva2Vuc1tpXS50eXBlID09ICc6Jylcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSAnaWRlbnRpZmllcicgfHwgdG9rZW5zW2ldLnR5cGUgPT0gJ2xpbmUnKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBjbGFzc1xuXHQgKiBAZXh0ZW5kcyBFZGl0Q29udGFpbmVyXG5cdCAqL1xuXHR2YXIgQ1NTRWRpdENvbnRhaW5lciA9IHJlcXVpcmUoJ2VkaXRUcmVlJykuRWRpdENvbnRhaW5lci5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0Xy5kZWZhdWx0cyh0aGlzLm9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcblx0XHRcdHZhciBlZGl0VHJlZSA9IHJlcXVpcmUoJ2VkaXRUcmVlJyk7XG5cdFx0XHRcblx0XHRcdC8qKiBAdHlwZSBUb2tlbkl0ZXJhdG9yICovXG5cdCBcdFx0dmFyIGl0ID0gcmVxdWlyZSgndG9rZW5JdGVyYXRvcicpLmNyZWF0ZShcblx0IFx0XHRcdFx0cmVxdWlyZSgnY3NzUGFyc2VyJykucGFyc2Uoc291cmNlKSk7XG5cdCBcdFx0XG5cdCBcdFx0dmFyIHNlbGVjdG9yUmFuZ2UgPSBmaW5kU2VsZWN0b3JSYW5nZShpdCk7XG5cdCBcdFx0dGhpcy5fcG9zaXRpb25zLm5hbWUgPSBzZWxlY3RvclJhbmdlLnN0YXJ0O1xuXHQgXHRcdHRoaXMuX25hbWUgPSBzZWxlY3RvclJhbmdlLnN1YnN0cmluZyhzb3VyY2UpO1xuXHQgXHRcdFxuXHQgXHRcdGlmICghaXQuY3VycmVudCgpIHx8IGl0LmN1cnJlbnQoKS50eXBlICE9ICd7Jylcblx0IFx0XHRcdHRocm93ICdJbnZhbGlkIENTUyBydWxlJztcblx0IFx0XHRcblx0IFx0XHR0aGlzLl9wb3NpdGlvbnMuY29udGVudFN0YXJ0ID0gaXQucG9zaXRpb24oKSArIDE7XG5cdCBcdFx0XG5cdCBcdFx0Ly8gY29uc3VtZSBwcm9wZXJ0aWVzXG5cdCBcdFx0dmFyIHByb3BlcnR5UmFuZ2UsIHZhbHVlUmFuZ2UsIHRva2VuO1xuXHRcdFx0d2hpbGUgKHRva2VuID0gaXQubmV4dCgpKSB7XG5cdFx0XHRcdGlmICh0b2tlbi50eXBlID09ICdpZGVudGlmaWVyJyAmJiBpc1ZhbGlkSWRlbnRpZmllcihpdCkpIHtcblx0XHRcdFx0XHRwcm9wZXJ0eVJhbmdlID0gcmFuZ2UodG9rZW4pO1xuXHRcdFx0XHRcdHZhbHVlUmFuZ2UgPSBmaW5kVmFsdWVSYW5nZShpdCk7XG5cdFx0XHRcdFx0dmFyIGVuZCA9IChpdC5jdXJyZW50KCkgJiYgaXQuY3VycmVudCgpLnR5cGUgPT0gJzsnKSBcblx0XHRcdFx0XHRcdD8gcmFuZ2UoaXQuY3VycmVudCgpKVxuXHRcdFx0XHRcdFx0OiByYW5nZSh2YWx1ZVJhbmdlLmVuZCwgMCk7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRyZW4ucHVzaChuZXcgQ1NTRWRpdEVsZW1lbnQodGhpcyxcblx0XHRcdFx0XHRcdFx0ZWRpdFRyZWUuY3JlYXRlVG9rZW4ocHJvcGVydHlSYW5nZS5zdGFydCwgcHJvcGVydHlSYW5nZS5zdWJzdHJpbmcoc291cmNlKSksXG5cdFx0XHRcdFx0XHRcdGVkaXRUcmVlLmNyZWF0ZVRva2VuKHZhbHVlUmFuZ2Uuc3RhcnQsIHZhbHVlUmFuZ2Uuc3Vic3RyaW5nKHNvdXJjZSkpLFxuXHRcdFx0XHRcdFx0XHRlZGl0VHJlZS5jcmVhdGVUb2tlbihlbmQuc3RhcnQsIGVuZC5zdWJzdHJpbmcoc291cmNlKSlcblx0XHRcdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5fc2F2ZVN0eWxlKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1lbWJlcnMgYWxsIHN0eWxlcyBvZiBwcm9wZXJ0aWVzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMuX3Bvc2l0aW9ucy5jb250ZW50U3RhcnQ7XG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cdFx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdFx0XG5cdFx0XHRfLmVhY2godGhpcy5saXN0KCksIC8qKiBAcGFyYW0ge0NTU0VkaXRQcm9wZXJ0eX0gcCAqLyBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHAuc3R5bGVCZWZvcmUgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LCBwLm5hbWVQb3NpdGlvbigpKTtcblx0XHRcdFx0Ly8gYSBzbWFsbCBoYWNrIGhlcmU6XG5cdFx0XHRcdC8vIFNvbWV0aW1lcyB1c2VycyBhZGQgZW1wdHkgbGluZXMgYmVmb3JlIHByb3BlcnRpZXMgdG8gbG9naWNhbGx5XG5cdFx0XHRcdC8vIHNlcGFyYXRlIGdyb3VwcyBvZiBwcm9wZXJ0aWVzLiBJbiB0aGlzIGNhc2UsIGEgYmxpbmQgY29weSBvZlxuXHRcdFx0XHQvLyBjaGFyYWN0ZXJzIGJldHdlZW4gcnVsZXMgbWF5IGxlYWQgdG8gdW5kZXNpcmVkIGJlaGF2aW9yLFxuXHRcdFx0XHQvLyBlc3BlY2lhbGx5IHdoZW4gY3VycmVudCBydWxlIGlzIGR1cGxpY2F0ZWQgb3IgdXNlZCBhcyBhIGRvbm9yXG5cdFx0XHRcdC8vIHRvIGNyZWF0ZSBuZXcgcnVsZS5cblx0XHRcdFx0Ly8gVG8gc29sdmUgdGhpcyBpc3N1ZSwgd2XigJhsbCB0YWtlIG9ubHkgbGFzdCBuZXdsaW5lIGluZGVudGF0aW9uXG5cdFx0XHRcdHZhciBsaW5lcyA9IHV0aWxzLnNwbGl0QnlMaW5lcyhwLnN0eWxlQmVmb3JlKTtcblx0XHRcdFx0aWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRwLnN0eWxlQmVmb3JlID0gJ1xcbicgKyBfLmxhc3QobGluZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRwLnN0eWxlU2VwYXJhdG9yID0gc291cmNlLnN1YnN0cmluZyhwLm5hbWVSYW5nZSgpLmVuZCwgcC52YWx1ZVBvc2l0aW9uKCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZ3JhY2VmdWwgYW5kIG5haXZlIGNvbW1lbnRzIHJlbW92YWwgXG5cdFx0XHRcdHAuc3R5bGVCZWZvcmUgPSBfLmxhc3QocC5zdHlsZUJlZm9yZS5zcGxpdCgnKi8nKSk7XG5cdFx0XHRcdHAuc3R5bGVTZXBhcmF0b3IgPSBwLnN0eWxlU2VwYXJhdG9yLnJlcGxhY2UoL1xcL1xcKi4qP1xcKlxcLy9nLCAnJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFydCA9IHAucmFuZ2UoKS5lbmQ7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgbmV3IENTUyBwcm9wZXJ0eSBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFByb3BlcnR5IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBQb3NpdGlvbiBhdCB3aGljaCB0byBpbnNlcnQgbmV3IHByb3BlcnR5LiBCeSBcblx0XHQgKiBkZWZhdWx0IHRoZSBwcm9wZXJ0eSBpcyBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHJ1bGUgXG5cdFx0ICogQHJldHVybnMge0NTU0VkaXRQcm9wZXJ0eX1cblx0XHQgKi9cblx0XHRhZGQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwb3MpIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5saXN0KCk7XG5cdFx0XHR2YXIgc3RhcnQgPSB0aGlzLl9wb3NpdGlvbnMuY29udGVudFN0YXJ0O1xuXHRcdFx0dmFyIHN0eWxlcyA9IF8ucGljayh0aGlzLm9wdGlvbnMsICdzdHlsZUJlZm9yZScsICdzdHlsZVNlcGFyYXRvcicpO1xuXHRcdFx0dmFyIGVkaXRUcmVlID0gcmVxdWlyZSgnZWRpdFRyZWUnKTtcblx0XHRcdFxuXHRcdFx0aWYgKF8uaXNVbmRlZmluZWQocG9zKSlcblx0XHRcdFx0cG9zID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdC8qKiBAdHlwZSBDU1NFZGl0UHJvcGVydHkgKi9cblx0XHRcdHZhciBkb25vciA9IGxpc3RbcG9zXTtcblx0XHRcdGlmIChkb25vcikge1xuXHRcdFx0XHRzdGFydCA9IGRvbm9yLmZ1bGxSYW5nZSgpLnN0YXJ0O1xuXHRcdFx0fSBlbHNlIGlmIChkb25vciA9IGxpc3RbcG9zIC0gMV0pIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgZG9ub3IgaGFzIHRlcm1pbmF0aW5nIHNlbWljb2xvblxuXHRcdFx0XHRkb25vci5lbmQoJzsnKTtcblx0XHRcdFx0c3RhcnQgPSBkb25vci5yYW5nZSgpLmVuZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGRvbm9yKSB7XG5cdFx0XHRcdHN0eWxlcyA9IF8ucGljayhkb25vciwgJ3N0eWxlQmVmb3JlJywgJ3N0eWxlU2VwYXJhdG9yJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBuYW1lVG9rZW4gPSBlZGl0VHJlZS5jcmVhdGVUb2tlbihzdGFydCArIHN0eWxlcy5zdHlsZUJlZm9yZS5sZW5ndGgsIG5hbWUpO1xuXHRcdFx0dmFyIHZhbHVlVG9rZW4gPSBlZGl0VHJlZS5jcmVhdGVUb2tlbihuYW1lVG9rZW4uZW5kICsgc3R5bGVzLnN0eWxlU2VwYXJhdG9yLmxlbmd0aCwgdmFsdWUpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJvcGVydHkgPSBuZXcgQ1NTRWRpdEVsZW1lbnQodGhpcywgbmFtZVRva2VuLCB2YWx1ZVRva2VuLFxuXHRcdFx0XHRcdGVkaXRUcmVlLmNyZWF0ZVRva2VuKHZhbHVlVG9rZW4uZW5kLCAnOycpKTtcblx0XHRcdFxuXHRcdFx0Xy5leHRlbmQocHJvcGVydHksIHN0eWxlcyk7XG5cdFx0XHRcblx0XHRcdC8vIHdyaXRlIG5ldyBwcm9wZXJ0eSBpbnRvIHRoZSBzb3VyY2Vcblx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZShwcm9wZXJ0eS5zdHlsZUJlZm9yZSArIHByb3BlcnR5LnRvU3RyaW5nKCksIHN0YXJ0KTtcblx0XHRcdFxuXHRcdFx0Ly8gaW5zZXJ0IG5ldyBwcm9wZXJ0eVxuXHRcdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKHBvcywgMCwgcHJvcGVydHkpO1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICogQGNsYXNzXG5cdCAqIEB0eXBlIENTU0VkaXRFbGVtZW50XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIENTU0VkaXRFbGVtZW50ID0gcmVxdWlyZSgnZWRpdFRyZWUnKS5FZGl0RWxlbWVudC5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKHJ1bGUsIG5hbWUsIHZhbHVlLCBlbmQpIHtcblx0XHRcdHRoaXMuc3R5bGVCZWZvcmUgPSBydWxlLm9wdGlvbnMuc3R5bGVCZWZvcmU7XG5cdFx0XHR0aGlzLnN0eWxlU2VwYXJhdG9yID0gcnVsZS5vcHRpb25zLnN0eWxlU2VwYXJhdG9yO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9lbmQgPSBlbmQudmFsdWU7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuZW5kID0gZW5kLnN0YXJ0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyByYW5nZXMgb2YgY29tcGxleCB2YWx1ZSBwYXJ0c1xuXHRcdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyA8Y29kZT5udWxsPC9jb2RlPiBpZiB2YWx1ZSBpcyBub3QgY29tcGxleFxuXHRcdCAqL1xuXHRcdHZhbHVlUGFydHM6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGZpbmRQYXJ0cyh0aGlzLnZhbHVlKCkpO1xuXHRcdFx0aWYgKGlzQWJzb2x1dGUpIHtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMudmFsdWVQb3NpdGlvbih0cnVlKTtcblx0XHRcdFx0Xy5lYWNoKHBhcnRzLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cC5zaGlmdChvZmZzZXQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHBhcnRzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBvZiBnZXRzIHByb3BlcnR5IGVuZCB2YWx1ZSAoYmFzaWNhbGx5LCBpdCdzIGEgc2VtaWNvbG9uKVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgTmV3IGVuZCB2YWx1ZS4gSWYgbm90IHBhc3NlZCwgY3VycmVudCBcblx0XHQgKiB2YWx1ZSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGVuZDogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZiAoIV8uaXNVbmRlZmluZWQodmFsKSAmJiB0aGlzLl9lbmQgIT09IHZhbCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5fdXBkYXRlU291cmNlKHZhbCwgdGhpcy5fcG9zaXRpb25zLmVuZCwgdGhpcy5fcG9zaXRpb25zLmVuZCArIHRoaXMuX2VuZC5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLl9lbmQgPSB2YWw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9lbmQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGZ1bGwgcnVsZSByYW5nZSwgd2l0aCBpbmRlbnRhdGlvblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBYnNvbHV0ZSBSZXR1cm4gYWJzb2x1dGUgcmFuZ2UgKHdpdGggcmVzcGVjdCBvZlxuXHRcdCAqIHJ1bGUgb2Zmc2V0KVxuXHRcdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0XHQgKi9cblx0XHRmdWxsUmFuZ2U6IGZ1bmN0aW9uKGlzQWJzb2x1dGUpIHtcblx0XHRcdHZhciByID0gdGhpcy5yYW5nZShpc0Fic29sdXRlKTtcblx0XHRcdHIuc3RhcnQgLT0gdGhpcy5zdHlsZUJlZm9yZS5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbSBzdHJpbmcgcmVwcmVzZW50YXRpb25cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm5hbWUoKSArIHRoaXMuc3R5bGVTZXBhcmF0b3IgKyB0aGlzLnZhbHVlKCkgKyB0aGlzLmVuZCgpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBDU1MgcnVsZSBpbnRvIGVkaXRhYmxlIHRyZWVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKiBAbWVtYmVyT2YgZW1tZXQuY3NzRWRpdFRyZWVcblx0XHQgKiBAcmV0dXJucyB7RWRpdENvbnRhaW5lcn1cblx0XHQgKi9cblx0XHRwYXJzZTogZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENTU0VkaXRDb250YWluZXIoc291cmNlLCBvcHRpb25zKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dHJhY3QgYW5kIHBhcnNlIENTUyBydWxlIGZyb20gc3BlY2lmaWVkIHBvc2l0aW9uIGluIDxjb2RlPmNvbnRlbnQ8L2NvZGU+IFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50IENTUyBzb3VyY2UgY29kZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgQ2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRvIHN0YXJ0IHNvdXJjZSBjb2RlIGV4dHJhY3Rpb25cblx0XHQgKiBAcmV0dXJucyB7RWRpdENvbnRhaW5lcn1cblx0XHQgKi9cblx0XHRwYXJzZUZyb21Qb3NpdGlvbjogZnVuY3Rpb24oY29udGVudCwgcG9zLCBpc0JhY2t3YXJkKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5leHRyYWN0UnVsZShjb250ZW50LCBwb3MsIGlzQmFja3dhcmQpO1xuXHRcdFx0aWYgKCFib3VuZHMgfHwgIWJvdW5kcy5pbnNpZGUocG9zKSlcblx0XHRcdFx0Ly8gbm8gbWF0Y2hpbmcgQ1NTIHJ1bGUgb3IgY2FyZXQgb3V0c2lkZSBydWxlIGJvdW5kc1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2UoYm91bmRzLnN1YnN0cmluZyhjb250ZW50KSwge1xuXHRcdFx0XHRvZmZzZXQ6IGJvdW5kcy5zdGFydFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBzaW5nbGUgQ1NTIHNlbGVjdG9yIGRlZmluaXRpb24gZnJvbSBzb3VyY2UgY29kZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50IENTUyBzb3VyY2UgY29kZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgQ2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRvIHN0YXJ0IHNvdXJjZSBjb2RlIGV4dHJhY3Rpb25cblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0ZXh0cmFjdFJ1bGU6IGZ1bmN0aW9uKGNvbnRlbnQsIHBvcywgaXNCYWNrd2FyZCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdFx0dmFyIGxlbiA9IGNvbnRlbnQubGVuZ3RoO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBvcztcblx0XHRcdHZhciBzdG9wQ2hhcnMgPSAne30vXFxcXDw+XFxuXFxyJztcblx0XHRcdHZhciBicmFjZVBvcyA9IC0xLCBjaDtcblx0XHRcdFxuXHRcdFx0Ly8gc2VhcmNoIGxlZnQgdW50aWwgd2UgZmluZCBydWxlIGVkZ2Vcblx0XHRcdHdoaWxlIChvZmZzZXQgPj0gMCkge1xuXHRcdFx0XHRjaCA9IGNvbnRlbnQuY2hhckF0KG9mZnNldCk7XG5cdFx0XHRcdGlmIChjaCA9PSAneycpIHtcblx0XHRcdFx0XHRicmFjZVBvcyA9IG9mZnNldDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChjaCA9PSAnfScgJiYgIWlzQmFja3dhcmQpIHtcblx0XHRcdFx0XHRvZmZzZXQrKztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0b2Zmc2V0LS07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIHNlYXJjaCByaWdodCBmb3IgZnVsbCBydWxlIHNldFxuXHRcdFx0d2hpbGUgKG9mZnNldCA8IGxlbikge1xuXHRcdFx0XHRjaCA9IGNvbnRlbnQuY2hhckF0KG9mZnNldCk7XG5cdFx0XHRcdGlmIChjaCA9PSAneycpIHtcblx0XHRcdFx0XHRicmFjZVBvcyA9IG9mZnNldDtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnfScpIHtcblx0XHRcdFx0XHRpZiAoYnJhY2VQb3MgIT0gLTEpXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBjb250ZW50LnN1YnN0cmluZyhicmFjZVBvcywgb2Zmc2V0ICsgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG9mZnNldCsrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdC8vIGZpbmQgQ1NTIHNlbGVjdG9yXG5cdFx0XHRcdG9mZnNldCA9IGJyYWNlUG9zIC0gMTtcblx0XHRcdFx0dmFyIHNlbGVjdG9yID0gJyc7XG5cdFx0XHRcdHdoaWxlIChvZmZzZXQgPj0gMCkge1xuXHRcdFx0XHRcdGNoID0gY29udGVudC5jaGFyQXQob2Zmc2V0KTtcblx0XHRcdFx0XHRpZiAoc3RvcENoYXJzLmluZGV4T2YoY2gpICE9IC0xKSBicmVhaztcblx0XHRcdFx0XHRvZmZzZXQtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gYWxzbyB0cmltIHdoaXRlc3BhY2Vcblx0XHRcdFx0c2VsZWN0b3IgPSBjb250ZW50LnN1YnN0cmluZyhvZmZzZXQgKyAxLCBicmFjZVBvcykucmVwbGFjZSgvXltcXHNcXG5cXHJdKy9tLCAnJyk7XG5cdFx0XHRcdHJldHVybiByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShicmFjZVBvcyAtIHNlbGVjdG9yLmxlbmd0aCwgcmVzdWx0Lmxlbmd0aCArIHNlbGVjdG9yLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdCBcdCAqIFJlbW92ZXMgdmVuZG9yIHByZWZpeCBmcm9tIENTUyBwcm9wZXJ0eVxuXHQgXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHlcblx0IFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgXHQgKi9cblx0IFx0YmFzZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0IFx0XHRyZXR1cm4gbmFtZS5yZXBsYWNlKC9eXFxzKlxcLVxcdytcXC0vLCAnJyk7XG5cdCBcdH0sXG5cdCBcdFxuXHQgXHQvKipcblx0IFx0ICogRmluZHMgcGFydHMgb2YgY29tcGxleCBDU1MgdmFsdWVcblx0IFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCBcdCAqL1xuXHQgXHRmaW5kUGFydHM6IGZpbmRQYXJ0c1xuXHR9O1xufSk7LyoqXG4gKiBYTUwgRWRpdFRyZWUgaXMgYSBtb2R1bGUgdGhhdCBjYW4gcGFyc2UgYW4gWE1ML0hUTUwgZWxlbWVudCBpbnRvIGEgdHJlZSB3aXRoIFxuICogY29udmVuaWVudCBtZXRob2RzIGZvciBhZGRpbmcsIG1vZGlmeWluZyBhbmQgcmVtb3ZpbmcgYXR0cmlidXRlcy4gVGhlc2UgXG4gKiBjaGFuZ2VzIGNhbiBiZSB3cml0dGVuIGJhY2sgdG8gc3RyaW5nIHdpdGggcmVzcGVjdCBvZiBjb2RlIGZvcm1hdHRpbmcuXG4gKiBcbiAqIEBtZW1iZXJPZiBfX3htbEVkaXRUcmVlRGVmaW5lXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gXyBcbiAqL1xuZW1tZXQuZGVmaW5lKCd4bWxFZGl0VHJlZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdHN0eWxlQmVmb3JlOiAnICcsXG5cdFx0c3R5bGVTZXBhcmF0b3I6ICc9Jyxcblx0XHRzdHlsZVF1b3RlOiAnXCInLFxuXHRcdG9mZnNldDogMFxuXHR9O1xuXHRcblx0dmFyIHN0YXJ0VGFnID0gL148KFtcXHdcXDpcXC1dKykoKD86XFxzK1tcXHdcXC06XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKykpPykqKVxccyooXFwvPyk+L207XG5cdFxuXHR2YXIgWE1MRWRpdENvbnRhaW5lciA9IHJlcXVpcmUoJ2VkaXRUcmVlJykuRWRpdENvbnRhaW5lci5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0Xy5kZWZhdWx0cyh0aGlzLm9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5uYW1lID0gMTtcblx0XHRcdFxuXHRcdFx0dmFyIGF0dHJUb2tlbiA9IG51bGw7XG5cdFx0XHR2YXIgdG9rZW5zID0gcmVxdWlyZSgneG1sUGFyc2VyJykucGFyc2Uoc291cmNlKTtcblx0XHRcdHZhciByYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJyk7XG5cdFx0XHRcblx0XHRcdF8uZWFjaCh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gcmFuZ2UuY3JlYXRlKHRva2VuKS5zdWJzdHJpbmcoc291cmNlKTtcblx0XHRcdFx0c3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAndGFnJzpcblx0XHRcdFx0XHRcdGlmICgvXjxbXlxcL10rLy50ZXN0KHRva2VuLnZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9uYW1lID0gdG9rZW4udmFsdWUuc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlICdhdHRyaWJ1dGUnOlxuXHRcdFx0XHRcdFx0Ly8gYWRkIGVtcHR5IGF0dHJpYnV0ZVxuXHRcdFx0XHRcdFx0aWYgKGF0dHJUb2tlbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG5ldyBYTUxFZGl0RWxlbWVudCh0aGlzLCBhdHRyVG9rZW4pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0YXR0clRva2VuID0gdG9rZW47XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdFx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG5ldyBYTUxFZGl0RWxlbWVudCh0aGlzLCBhdHRyVG9rZW4sIHRva2VuKSk7XG5cdFx0XHRcdFx0XHRhdHRyVG9rZW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRpZiAoYXR0clRva2VuKSB7XG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobmV3IFhNTEVkaXRFbGVtZW50KHRoaXMsIGF0dHJUb2tlbikpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLl9zYXZlU3R5bGUoKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbWVtYmVycyBhbGwgc3R5bGVzIG9mIHByb3BlcnRpZXNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9zYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gdGhpcy5uYW1lUmFuZ2UoKS5lbmQ7XG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cdFx0XHRcblx0XHRcdF8uZWFjaCh0aGlzLmxpc3QoKSwgLyoqIEBwYXJhbSB7RWRpdEVsZW1lbnR9IHAgKi8gZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRwLnN0eWxlQmVmb3JlID0gc291cmNlLnN1YnN0cmluZyhzdGFydCwgcC5uYW1lUG9zaXRpb24oKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocC52YWx1ZVBvc2l0aW9uKCkgIT09IC0xKSB7XG5cdFx0XHRcdFx0cC5zdHlsZVNlcGFyYXRvciA9IHNvdXJjZS5zdWJzdHJpbmcocC5uYW1lUG9zaXRpb24oKSArIHAubmFtZSgpLmxlbmd0aCwgcC52YWx1ZVBvc2l0aW9uKCkgLSBwLnN0eWxlUXVvdGUubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0c3RhcnQgPSBwLnJhbmdlKCkuZW5kO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIG5ldyBhdHRyaWJ1dGUgXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgUG9zaXRpb24gYXQgd2hpY2ggdG8gaW5zZXJ0IG5ldyBwcm9wZXJ0eS4gQnkgXG5cdFx0ICogZGVmYXVsdCB0aGUgcHJvcGVydHkgaXMgaW5zZXJ0ZWQgYXQgdGhlIGVuZCBvZiBydWxlIFxuXHRcdCAqL1xuXHRcdGFkZDogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHBvcykge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLmxpc3QoKTtcblx0XHRcdHZhciBzdGFydCA9IHRoaXMubmFtZVJhbmdlKCkuZW5kO1xuXHRcdFx0dmFyIGVkaXRUcmVlID0gcmVxdWlyZSgnZWRpdFRyZWUnKTtcblx0XHRcdHZhciBzdHlsZXMgPSBfLnBpY2sodGhpcy5vcHRpb25zLCAnc3R5bGVCZWZvcmUnLCAnc3R5bGVTZXBhcmF0b3InLCAnc3R5bGVRdW90ZScpO1xuXHRcdFx0XG5cdFx0XHRpZiAoXy5pc1VuZGVmaW5lZChwb3MpKVxuXHRcdFx0XHRwb3MgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvKiogQHR5cGUgWE1MRWRpdEF0dHJpYnV0ZSAqL1xuXHRcdFx0dmFyIGRvbm9yID0gbGlzdFtwb3NdO1xuXHRcdFx0aWYgKGRvbm9yKSB7XG5cdFx0XHRcdHN0YXJ0ID0gZG9ub3IuZnVsbFJhbmdlKCkuc3RhcnQ7XG5cdFx0XHR9IGVsc2UgaWYgKGRvbm9yID0gbGlzdFtwb3MgLSAxXSkge1xuXHRcdFx0XHRzdGFydCA9IGRvbm9yLnJhbmdlKCkuZW5kO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoZG9ub3IpIHtcblx0XHRcdFx0c3R5bGVzID0gXy5waWNrKGRvbm9yLCAnc3R5bGVCZWZvcmUnLCAnc3R5bGVTZXBhcmF0b3InLCAnc3R5bGVRdW90ZScpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YWx1ZSA9IHN0eWxlcy5zdHlsZVF1b3RlICsgdmFsdWUgKyBzdHlsZXMuc3R5bGVRdW90ZTtcblx0XHRcdFxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBYTUxFZGl0RWxlbWVudCh0aGlzLCBcblx0XHRcdFx0XHRlZGl0VHJlZS5jcmVhdGVUb2tlbihzdGFydCArIHN0eWxlcy5zdHlsZUJlZm9yZS5sZW5ndGgsIG5hbWUpLFxuXHRcdFx0XHRcdGVkaXRUcmVlLmNyZWF0ZVRva2VuKHN0YXJ0ICsgc3R5bGVzLnN0eWxlQmVmb3JlLmxlbmd0aCArIG5hbWUubGVuZ3RoIFxuXHRcdFx0XHRcdFx0XHQrIHN0eWxlcy5zdHlsZVNlcGFyYXRvci5sZW5ndGgsIHZhbHVlKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcblx0XHRcdF8uZXh0ZW5kKGF0dHJpYnV0ZSwgc3R5bGVzKTtcblx0XHRcdFxuXHRcdFx0Ly8gd3JpdGUgbmV3IGF0dHJpYnV0ZSBpbnRvIHRoZSBzb3VyY2Vcblx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZShhdHRyaWJ1dGUuc3R5bGVCZWZvcmUgKyBhdHRyaWJ1dGUudG9TdHJpbmcoKSwgc3RhcnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBpbnNlcnQgbmV3IGF0dHJpYnV0ZVxuXHRcdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKHBvcywgMCwgYXR0cmlidXRlKTtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cdFx0fVxuXHR9KTtcblx0XG5cdHZhciBYTUxFZGl0RWxlbWVudCA9IHJlcXVpcmUoJ2VkaXRUcmVlJykuRWRpdEVsZW1lbnQuZXh0ZW5kKHtcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXJlbnQsIG5hbWVUb2tlbiwgdmFsdWVUb2tlbikge1xuXHRcdFx0dGhpcy5zdHlsZUJlZm9yZSA9IHBhcmVudC5vcHRpb25zLnN0eWxlQmVmb3JlO1xuXHRcdFx0dGhpcy5zdHlsZVNlcGFyYXRvciA9IHBhcmVudC5vcHRpb25zLnN0eWxlU2VwYXJhdG9yO1xuXHRcdFx0XG5cdFx0XHR2YXIgdmFsdWUgPSAnJywgcXVvdGUgPSBwYXJlbnQub3B0aW9ucy5zdHlsZVF1b3RlO1xuXHRcdFx0aWYgKHZhbHVlVG9rZW4pIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVRva2VuLnZhbHVlO1xuXHRcdFx0XHRxdW90ZSA9IHZhbHVlLmNoYXJBdCgwKTtcblx0XHRcdFx0aWYgKHF1b3RlID09ICdcIicgfHwgcXVvdGUgPT0gXCInXCIpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdW90ZSA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocXVvdGUgJiYgdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpID09IHF1b3RlKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5zdHlsZVF1b3RlID0gcXVvdGU7XG5cdFx0XHRcblx0XHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMudmFsdWUgPSB2YWx1ZVRva2VuID8gdmFsdWVUb2tlbi5zdGFydCArIHF1b3RlLmxlbmd0aCA6IC0xO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBmdWxsIHJ1bGUgcmFuZ2UsIHdpdGggaW5kZW50YXRpb25cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWJzb2x1dGUgUmV0dXJuIGFic29sdXRlIHJhbmdlICh3aXRoIHJlc3BlY3Qgb2Zcblx0XHQgKiBydWxlIG9mZnNldClcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0ZnVsbFJhbmdlOiBmdW5jdGlvbihpc0Fic29sdXRlKSB7XG5cdFx0XHR2YXIgciA9IHRoaXMucmFuZ2UoaXNBYnNvbHV0ZSk7XG5cdFx0XHRyLnN0YXJ0IC09IHRoaXMuc3R5bGVCZWZvcmUubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fSxcblx0XHRcblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lKCkgKyB0aGlzLnN0eWxlU2VwYXJhdG9yXG5cdFx0XHRcdCsgdGhpcy5zdHlsZVF1b3RlICsgdGhpcy52YWx1ZSgpICsgdGhpcy5zdHlsZVF1b3RlO1xuXHRcdH1cblx0fSk7XG5cdFxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBIVE1MIGVsZW1lbnQgaW50byBlZGl0YWJsZSB0cmVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICogQG1lbWJlck9mIGVtbWV0Lmh0bWxFZGl0VHJlZVxuXHRcdCAqIEByZXR1cm5zIHtFZGl0Q29udGFpbmVyfVxuXHRcdCAqL1xuXHRcdHBhcnNlOiBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgWE1MRWRpdENvbnRhaW5lcihzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdCBhbmQgcGFyc2UgSFRNTCBmcm9tIHNwZWNpZmllZCBwb3NpdGlvbiBpbiA8Y29kZT5jb250ZW50PC9jb2RlPiBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBDU1Mgc291cmNlIGNvZGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zIENoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCBzb3VyY2UgY29kZSBleHRyYWN0aW9uXG5cdFx0ICogQHJldHVybnMge1hNTEVkaXRFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHBhcnNlRnJvbVBvc2l0aW9uOiBmdW5jdGlvbihjb250ZW50LCBwb3MsIGlzQmFja3dhcmQpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmV4dHJhY3RUYWcoY29udGVudCwgcG9zLCBpc0JhY2t3YXJkKTtcblx0XHRcdGlmICghYm91bmRzIHx8ICFib3VuZHMuaW5zaWRlKHBvcykpXG5cdFx0XHRcdC8vIG5vIG1hdGNoaW5nIEhUTUwgdGFnIG9yIGNhcmV0IG91dHNpZGUgdGFnIGJvdW5kc1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2UoYm91bmRzLnN1YnN0cmluZyhjb250ZW50KSwge1xuXHRcdFx0XHRvZmZzZXQ6IGJvdW5kcy5zdGFydFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBuZWFyZXN0IEhUTUwgdGFnIHJhbmdlIGZyb20gPGNvZGU+Y29udGVudDwvY29kZT4sIHN0YXJ0aW5nIGF0IFxuXHRcdCAqIDxjb2RlPnBvczwvY29kZT4gcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3Ncblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFja3dhcmRcblx0XHQgKiBAcmV0dXJucyB7UmFuZ2V9XG5cdFx0ICovXG5cdFx0ZXh0cmFjdFRhZzogZnVuY3Rpb24oY29udGVudCwgcG9zLCBpc0JhY2t3YXJkKSB7XG5cdFx0XHR2YXIgbGVuID0gY29udGVudC5sZW5ndGgsIGk7XG5cdFx0XHR2YXIgcmFuZ2UgPSByZXF1aXJlKCdyYW5nZScpO1xuXHRcdFx0XG5cdFx0XHQvLyBtYXggZXh0cmFjdGlvbiBsZW5ndGguIEkgZG9uJ3QgdGhpbmsgdGhlcmUgbWF5IGJlIHRhZ3MgbGFyZ2VyIFxuXHRcdFx0Ly8gdGhhbiAyMDAwIGNoYXJhY3RlcnMgbGVuZ3RoXG5cdFx0XHR2YXIgbWF4TGVuID0gTWF0aC5taW4oMjAwMCwgbGVuKTtcblx0XHRcdFxuXHRcdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0XHR2YXIgciA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHZhciBtYXRjaCA9IGZ1bmN0aW9uKHBvcykge1xuXHRcdFx0XHR2YXIgbTtcblx0XHRcdFx0aWYgKGNvbnRlbnQuY2hhckF0KHBvcykgPT0gJzwnICYmIChtID0gY29udGVudC5zdWJzdHIocG9zLCBtYXhMZW4pLm1hdGNoKHN0YXJ0VGFnKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJhbmdlLmNyZWF0ZShwb3MsIG1bMF0pO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9va3VwIGJhY2t3YXJkLCBpbiBjYXNlIHdlIGFyZSBpbnNpZGUgdGFnIGFscmVhZHlcblx0XHRcdGZvciAoaSA9IHBvczsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHIgPSBtYXRjaChpKSkgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChyICYmIChyLmluc2lkZShwb3MpIHx8IGlzQmFja3dhcmQpKVxuXHRcdFx0XHRyZXR1cm4gcjtcblx0XHRcdFxuXHRcdFx0aWYgKCFyICYmIGlzQmFja3dhcmQpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHQvLyBzZWFyY2ggZm9yd2FyZFxuXHRcdFx0Zm9yIChpID0gcG9zOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYgKHIgPSBtYXRjaChpKSlcblx0XHRcdFx0XHRyZXR1cm4gcjtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTsvKipcbiAqICdFeHBhbmQgYWJicmV2aWF0aW9uJyBlZGl0b3IgYWN0aW9uOiBleHRyYWN0cyBhYmJyZXZpYXRpb24gZnJvbSBjdXJyZW50IGNhcmV0IFxuICogcG9zaXRpb24gYW5kIHJlcGxhY2VzIGl0IHdpdGggZm9ybWF0dGVkIG91dHB1dC4gXG4gKiA8YnI+PGJyPlxuICogVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoIGN1c3RvbSBoYW5kbGVycyB3aGljaCBjYW4gcGVyZm9ybSBcbiAqIGRpZmZlcmVudCBhY3Rpb25zIHdoZW4gJ0V4cGFuZCBBYmJyZXZpYXRpb24nIGFjdGlvbiBpcyBjYWxsZWQuXG4gKiBGb3IgZXhhbXBsZSwgYSBDU1MgZ3JhZGllbnQgaGFuZGxlciB0aGF0IHByb2R1Y2VzIHZlbmRvci1wcmVmaXhlZCBncmFkaWVudFxuICogZGVmaW5pdGlvbnMgcmVnaXN0ZXJzIGl0cyBvd24gZXhwYW5kIGFiYnJldmlhdGlvbiBoYW5kbGVyLiAgXG4gKiAgXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX2V4cGFuZEFiYnJldmlhdGlvbkFjdGlvbkRlZmluZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmRlZmluZSgnZXhwYW5kQWJicmV2aWF0aW9uJywgZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKipcblx0ICogQHR5cGUgSGFuZGxlckxpc3QgTGlzdCBvZiByZWdpc3RlcmVkIGhhbmRsZXJzXG5cdCAqL1xuXHR2YXIgaGFuZGxlcnMgPSByZXF1aXJlKCdoYW5kbGVyTGlzdCcpLmNyZWF0ZSgpO1xuXHRcblx0LyoqIEJhY2stcmVmZXJlbmNlIHRvIG1vZHVsZSAqL1xuXHR2YXIgbW9kdWxlID0gbnVsbDtcblx0XG5cdHZhciBhY3Rpb25zID0gcmVxdWlyZSgnYWN0aW9ucycpO1xuXHQvKipcblx0ICogJ0V4cGFuZCBhYmJyZXZpYXRpb24nIGVkaXRvciBhY3Rpb24gXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggU3ludGF4IHR5cGUgKGh0bWwsIGNzcywgZXRjLilcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUgbmFtZSAoaHRtbCwgeG1sLCB4aHRtbClcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBhYmJyZXZpYXRpb24gd2FzIGV4cGFuZGVkIFxuXHQgKiBzdWNjZXNzZnVsbHlcblx0ICovXG5cdGFjdGlvbnMuYWRkKCdleHBhbmRfYWJicmV2aWF0aW9uJywgZnVuY3Rpb24oZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHR2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMpO1xuXHRcdFxuXHRcdC8vIG5vcm1hbGl6ZSBpbmNvbWluZyBhcmd1bWVudHNcblx0XHR2YXIgaW5mbyA9IHJlcXVpcmUoJ2VkaXRvclV0aWxzJykub3V0cHV0SW5mbyhlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSk7XG5cdFx0YXJnc1sxXSA9IGluZm8uc3ludGF4O1xuXHRcdGFyZ3NbMl0gPSBpbmZvLnByb2ZpbGU7XG5cdFx0XG5cdFx0cmV0dXJuIGhhbmRsZXJzLmV4ZWMoZmFsc2UsIGFyZ3MpO1xuXHR9KTtcblx0XG5cdC8qKlxuXHQgKiBBIHNwZWNpYWwgdmVyc2lvbiBvZiA8Y29kZT5leHBhbmRBYmJyZXZpYXRpb248L2NvZGU+IGZ1bmN0aW9uOiBpZiBpdCBjYW4ndFxuXHQgKiBmaW5kIGFiYnJldmlhdGlvbiwgaXQgd2lsbCBwbGFjZSBUYWIgY2hhcmFjdGVyIGF0IGNhcmV0IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggU3ludGF4IHR5cGUgKGh0bWwsIGNzcywgZXRjLilcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUgbmFtZSAoaHRtbCwgeG1sLCB4aHRtbClcblx0ICovXG5cdGFjdGlvbnMuYWRkKCdleHBhbmRfYWJicmV2aWF0aW9uX3dpdGhfdGFiJywgZnVuY3Rpb24oZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHR2YXIgc2VsID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdHZhciBpbmRlbnQgPSByZXF1aXJlKCdyZXNvdXJjZXMnKS5nZXRWYXJpYWJsZSgnaW5kZW50YXRpb24nKTtcblx0XHRpZiAoc2VsKSB7XG5cdFx0XHQvLyBpbmRlbnQgc2VsZWN0aW9uXG5cdFx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdFx0dmFyIHNlbFJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdFx0dmFyIGNvbnRlbnQgPSB1dGlscy5wYWRTdHJpbmcoc2VsLCBpbmRlbnQpO1xuXHRcdFx0XG5cdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoaW5kZW50ICsgJyR7MH0nLCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0XHR2YXIgcmVwbGFjZVJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoZWRpdG9yLmdldENhcmV0UG9zKCksIHNlbFJhbmdlLmxlbmd0aCgpKTtcblx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChjb250ZW50LCByZXBsYWNlUmFuZ2Uuc3RhcnQsIHJlcGxhY2VSYW5nZS5lbmQsIHRydWUpO1xuXHRcdFx0ZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbihyZXBsYWNlUmFuZ2Uuc3RhcnQsIHJlcGxhY2VSYW5nZS5zdGFydCArIGNvbnRlbnQubGVuZ3RoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoIWFjdGlvbnMucnVuKCdleHBhbmRfYWJicmV2aWF0aW9uJywgZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpKSB7XG5cdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoaW5kZW50LCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9LCB7aGlkZGVuOiB0cnVlfSk7XG5cdFxuXHQvLyBYWFggc2V0dXAgZGVmYXVsdCBoYW5kbGVyXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBhYmJyZXZpYXRpb24gZnJvbSBjdXJyZW50IGNhcmV0IFxuXHQgKiBwb3NpdGlvbiBhbmQgcmVwbGFjZXMgaXQgd2l0aCBmb3JtYXR0ZWQgb3V0cHV0IFxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yIEVkaXRvciBpbnN0YW5jZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IFN5bnRheCB0eXBlIChodG1sLCBjc3MsIGV0Yy4pXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9maWxlIE91dHB1dCBwcm9maWxlIG5hbWUgKGh0bWwsIHhtbCwgeGh0bWwpXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYWJicmV2aWF0aW9uIHdhcyBleHBhbmRlZCBcblx0ICogc3VjY2Vzc2Z1bGx5XG5cdCAqL1xuXHRoYW5kbGVycy5hZGQoZnVuY3Rpb24oZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKS5lbmQ7XG5cdFx0dmFyIGFiYnIgPSBtb2R1bGUuZmluZEFiYnJldmlhdGlvbihlZGl0b3IpO1xuXHRcdFx0XG5cdFx0aWYgKGFiYnIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gZW1tZXQuZXhwYW5kQWJicmV2aWF0aW9uKGFiYnIsIHN5bnRheCwgcHJvZmlsZSwgXG5cdFx0XHRcdFx0cmVxdWlyZSgnYWN0aW9uVXRpbHMnKS5jYXB0dXJlQ29udGV4dChlZGl0b3IpKTtcblx0XHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChjb250ZW50LCBjYXJldFBvcyAtIGFiYnIubGVuZ3RoLCBjYXJldFBvcyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sIHtvcmRlcjogLTF9KTtcblx0XG5cdHJldHVybiBtb2R1bGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBjdXN0b20gZXhwYW5kIGFiYnJldmlhdGlvbiBoYW5kbGVyLiBUaGUgcGFzc2VkIGZ1bmN0aW9uIHNob3VsZCBcblx0XHQgKiByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgaXQgd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHksIFxuXHRcdCAqIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG5cdFx0ICogXG5cdFx0ICogQWRkZWQgaGFuZGxlcnMgd2lsbCBiZSBjYWxsZWQgd2hlbiAnRXhwYW5kIEFiYnJldmlhdGlvbicgaXMgY2FsbGVkXG5cdFx0ICogaW4gb3JkZXIgdGhleSB3ZXJlIGFkZGVkXG5cdFx0ICogQG1lbWJlck9mIGV4cGFuZEFiYnJldmlhdGlvblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKi9cblx0XHRhZGRIYW5kbGVyOiBmdW5jdGlvbihmbiwgb3B0aW9ucykge1xuXHRcdFx0aGFuZGxlcnMuYWRkKGZuLCBvcHRpb25zKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgcmVnaXN0ZXJlZCBoYW5kbGVyXG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRyZW1vdmVIYW5kbGVyOiBmdW5jdGlvbihmbikge1xuXHRcdFx0aGFuZGxlcnMucmVtb3ZlKGZuLCBvcHRpb25zKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBmb3IgYWJicmV2aWF0aW9uIGluIGVkaXRvciBmcm9tIGN1cnJlbnQgY2FyZXQgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yIEVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRmaW5kQWJicmV2aWF0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0dmFyIHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0XHRpZiAocmFuZ2UubGVuZ3RoKCkpIHtcblx0XHRcdFx0Ly8gYWJicmV2aWF0aW9uIGlzIHNlbGVjdGVkIGJ5IHVzZXJcblx0XHRcdFx0cmV0dXJuIHJhbmdlLnN1YnN0cmluZyhjb250ZW50KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gc2VhcmNoIGZvciBuZXcgYWJicmV2aWF0aW9uIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdFx0dmFyIGN1ckxpbmUgPSBlZGl0b3IuZ2V0Q3VycmVudExpbmVSYW5nZSgpO1xuXHRcdFx0cmV0dXJuIHJlcXVpcmUoJ2FjdGlvblV0aWxzJykuZXh0cmFjdEFiYnJldmlhdGlvbihjb250ZW50LnN1YnN0cmluZyhjdXJMaW5lLnN0YXJ0LCByYW5nZS5zdGFydCkpO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogQWN0aW9uIHRoYXQgd3JhcHMgY29udGVudCB3aXRoIGFiYnJldmlhdGlvbi4gRm9yIGNvbnZlbmllbmNlLCBhY3Rpb24gaXMgXG4gKiBkZWZpbmVkIGFzIHJldXNhYmxlIG1vZHVsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX193cmFwV2l0aEFiYnJldmlhdGlvbkRlZmluZVxuICovXG5lbW1ldC5kZWZpbmUoJ3dyYXBXaXRoQWJicmV2aWF0aW9uJywgZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKiogQmFjay1yZWZlcmVuY2VzIHRvIGN1cnJlbnQgbW9kdWxlICovXG5cdHZhciBtb2R1bGUgPSBudWxsO1xuXHRcblx0LyoqXG5cdCAqIFdyYXBzIGNvbnRlbnQgd2l0aCBhYmJyZXZpYXRpb25cblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IEVkaXRvciBpbnN0YW5jZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiciBBYmJyZXZpYXRpb24gdG8gd3JhcCB3aXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXggU3ludGF4IHR5cGUgKGh0bWwsIGNzcywgZXRjLilcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUgbmFtZSAoaHRtbCwgeG1sLCB4aHRtbClcblx0ICovXG5cdHJlcXVpcmUoJ2FjdGlvbnMnKS5hZGQoJ3dyYXBfd2l0aF9hYmJyZXZpYXRpb24nLCBmdW5jdGlvbiAoZWRpdG9yLCBhYmJyLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHR2YXIgaW5mbyA9IHJlcXVpcmUoJ2VkaXRvclV0aWxzJykub3V0cHV0SW5mbyhlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSk7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHQvKiogQHR5cGUgZW1tZXQuZWRpdG9yVXRpbHMgKi9cblx0XHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCdlZGl0b3JVdGlscycpO1xuXHRcdGFiYnIgPSBhYmJyIHx8IGVkaXRvci5wcm9tcHQoXCJFbnRlciBhYmJyZXZpYXRpb25cIik7XG5cdFx0XG5cdFx0aWYgKCFhYmJyKSBcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdFxuXHRcdGFiYnIgPSBTdHJpbmcoYWJicik7XG5cdFx0XG5cdFx0dmFyIHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdFxuXHRcdGlmICghcmFuZ2UubGVuZ3RoKCkpIHtcblx0XHRcdC8vIG5vIHNlbGVjdGlvbiwgZmluZCB0YWcgcGFpclxuXHRcdFx0dmFyIG1hdGNoID0gcmVxdWlyZSgnaHRtbE1hdGNoZXInKS50YWcoaW5mby5jb250ZW50LCByYW5nZS5zdGFydCk7XG5cdFx0XHRpZiAoIW1hdGNoKSB7ICAvLyBub3RoaW5nIHRvIHdyYXBcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyYW5nZSA9IHV0aWxzLm5hcnJvd1RvTm9uU3BhY2UoaW5mby5jb250ZW50LCBtYXRjaC5yYW5nZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBuZXdDb250ZW50ID0gdXRpbHMuZXNjYXBlVGV4dChyYW5nZS5zdWJzdHJpbmcoaW5mby5jb250ZW50KSk7XG5cdFx0dmFyIHJlc3VsdCA9IG1vZHVsZVxuXHRcdFx0LndyYXAoYWJiciwgZWRpdG9yVXRpbHMudW5pbmRlbnQoZWRpdG9yLCBuZXdDb250ZW50KSwgaW5mby5zeW50YXgsIFxuXHRcdFx0XHRcdGluZm8ucHJvZmlsZSwgcmVxdWlyZSgnYWN0aW9uVXRpbHMnKS5jYXB0dXJlQ29udGV4dChlZGl0b3IpKTtcblx0XHRcblx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQocmVzdWx0LCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pO1xuXHRcblx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHQvKipcblx0XHQgKiBXcmFwcyBwYXNzZWQgdGV4dCB3aXRoIGFiYnJldmlhdGlvbi4gVGV4dCB3aWxsIGJlIHBsYWNlZCBpbnNpZGUgbGFzdFxuXHRcdCAqIGV4cGFuZGVkIGVsZW1lbnRcblx0XHQgKiBAbWVtYmVyT2Ygd3JhcFdpdGhBYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiciBBYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHRvIHdyYXBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4IERvY3VtZW50IHR5cGUgKGh0bWwsIHhtbCwgZXRjLikuIERlZmF1bHQgaXMgJ2h0bWwnXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGUgT3V0cHV0IHByb2ZpbGUncyBuYW1lLiBEZWZhdWx0IGlzICdwbGFpbidcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE5vZGUgQ29udGV4dCBub2RlIGluc2lkZSB3aGljaCBhYmJyZXZpYXRpb25cblx0XHQgKiBpcyB3cmFwcGVkLiBJdCB3aWxsIGJlIHVzZWQgYXMgYSByZWZlcmVuY2UgZm9yIG5vZGUgbmFtZSByZXNvbHZlcnNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0d3JhcDogZnVuY3Rpb24oYWJiciwgdGV4dCwgc3ludGF4LCBwcm9maWxlLCBjb250ZXh0Tm9kZSkge1xuXHRcdFx0LyoqIEB0eXBlIGVtbWV0LmZpbHRlcnMgKi9cblx0XHRcdHZhciBmaWx0ZXJzID0gcmVxdWlyZSgnZmlsdGVycycpO1xuXHRcdFx0LyoqIEB0eXBlIGVtbWV0LnV0aWxzICovXG5cdFx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdFx0XG5cdFx0XHRzeW50YXggPSBzeW50YXggfHwgZW1tZXQuZGVmYXVsdFN5bnRheCgpO1xuXHRcdFx0cHJvZmlsZSA9IHJlcXVpcmUoJ3Byb2ZpbGUnKS5nZXQocHJvZmlsZSwgc3ludGF4KTtcblx0XHRcdFxuXHRcdFx0cmVxdWlyZSgndGFiU3RvcHMnKS5yZXNldFRhYnN0b3BJbmRleCgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgZGF0YSA9IGZpbHRlcnMuZXh0cmFjdEZyb21BYmJyZXZpYXRpb24oYWJicik7XG5cdFx0XHR2YXIgcGFyc2VkVHJlZSA9IHJlcXVpcmUoJ2FiYnJldmlhdGlvblBhcnNlcicpLnBhcnNlKGRhdGFbMF0sIHtcblx0XHRcdFx0c3ludGF4OiBzeW50YXgsXG5cdFx0XHRcdHBhc3RlZENvbnRlbnQ6IHRleHQsXG5cdFx0XHRcdGNvbnRleHROb2RlOiBjb250ZXh0Tm9kZVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocGFyc2VkVHJlZSkge1xuXHRcdFx0XHR2YXIgZmlsdGVyc0xpc3QgPSBmaWx0ZXJzLmNvbXBvc2VMaXN0KHN5bnRheCwgcHJvZmlsZSwgZGF0YVsxXSk7XG5cdFx0XHRcdGZpbHRlcnMuYXBwbHkocGFyc2VkVHJlZSwgZmlsdGVyc0xpc3QsIHByb2ZpbGUpO1xuXHRcdFx0XHRyZXR1cm4gdXRpbHMucmVwbGFjZVZhcmlhYmxlcyhwYXJzZWRUcmVlLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG59KTsvKipcbiAqIFRvZ2dsZXMgSFRNTCBhbmQgQ1NTIGNvbW1lbnRzIGRlcGVuZGluZyBvbiBjdXJyZW50IGNhcmV0IGNvbnRleHQuIFVubGlrZVxuICogdGhlIHNhbWUgYWN0aW9uIGluIG1vc3QgZWRpdG9ycywgdGhpcyBhY3Rpb24gdG9nZ2xlcyBjb21tZW50IG9uIGN1cnJlbnRseVxuICogbWF0Y2hlZCBpdGVt4oCUSFRNTCB0YWcgb3IgQ1NTIHNlbGVjdG9y4oCUd2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLlxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqIEBtZW1iZXJPZiBfX3RvZ2dsZUNvbW1lbnRBY3Rpb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0LyoqXG5cdCAqIFRvZ2dsZSBIVE1MIGNvbW1lbnQgb24gY3VycmVudCBzZWxlY3Rpb24gb3IgdGFnXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21tZW50IHdhcyB0b2dnbGVkXG5cdCAqL1xuXHRmdW5jdGlvbiB0b2dnbGVIVE1MQ29tbWVudChlZGl0b3IpIHtcblx0XHQvKiogQHR5cGUgUmFuZ2UgKi9cblx0XHR2YXIgcmFuZ2UgPSByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG5cdFx0dmFyIGluZm8gPSByZXF1aXJlKCdlZGl0b3JVdGlscycpLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHRcdFxuXHRcdGlmICghcmFuZ2UubGVuZ3RoKCkpIHtcblx0XHRcdC8vIG5vIHNlbGVjdGlvbiwgZmluZCBtYXRjaGluZyB0YWdcblx0XHRcdHZhciB0YWcgPSByZXF1aXJlKCdodG1sTWF0Y2hlcicpLnRhZyhpbmZvLmNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdGlmICh0YWcpIHsgLy8gZm91bmQgcGFpclxuXHRcdFx0XHRyYW5nZSA9IHRhZy5vdXRlclJhbmdlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZ2VuZXJpY0NvbW1lbnRUb2dnbGUoZWRpdG9yLCAnPCEtLScsICctLT4nLCByYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2ltcGxlIENTUyBjb21tZW50aW5nXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21tZW50IHdhcyB0b2dnbGVkXG5cdCAqL1xuXHRmdW5jdGlvbiB0b2dnbGVDU1NDb21tZW50KGVkaXRvcikge1xuXHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdHZhciByYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJykuY3JlYXRlKGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcblx0XHR2YXIgaW5mbyA9IHJlcXVpcmUoJ2VkaXRvclV0aWxzJykub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdFx0XG5cdFx0aWYgKCFyYW5nZS5sZW5ndGgoKSkge1xuXHRcdFx0Ly8gbm8gc2VsZWN0aW9uLCB0cnkgdG8gZ2V0IGN1cnJlbnQgcnVsZVxuXHRcdFx0LyoqIEB0eXBlIENTU1J1bGUgKi9cblx0XHRcdHZhciBydWxlID0gcmVxdWlyZSgnY3NzRWRpdFRyZWUnKS5wYXJzZUZyb21Qb3NpdGlvbihpbmZvLmNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdGlmIChydWxlKSB7XG5cdFx0XHRcdHZhciBwcm9wZXJ0eSA9IGNzc0l0ZW1Gcm9tUG9zaXRpb24ocnVsZSwgZWRpdG9yLmdldENhcmV0UG9zKCkpO1xuXHRcdFx0XHRyYW5nZSA9IHByb3BlcnR5IFxuXHRcdFx0XHRcdD8gcHJvcGVydHkucmFuZ2UodHJ1ZSkgXG5cdFx0XHRcdFx0OiByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShydWxlLm5hbWVSYW5nZSh0cnVlKS5zdGFydCwgcnVsZS5zb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoIXJhbmdlLmxlbmd0aCgpKSB7XG5cdFx0XHQvLyBzdGlsbCBubyBzZWxlY3Rpb24sIGdldCBjdXJyZW50IGxpbmVcblx0XHRcdHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoZWRpdG9yLmdldEN1cnJlbnRMaW5lUmFuZ2UoKSk7XG5cdFx0XHRyZXF1aXJlKCd1dGlscycpLm5hcnJvd1RvTm9uU3BhY2UoaW5mby5jb250ZW50LCByYW5nZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBnZW5lcmljQ29tbWVudFRvZ2dsZShlZGl0b3IsICcvKicsICcqLycsIHJhbmdlKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgQ1NTIHByb3BlcnR5IGZyb20gPGNvZGU+cnVsZTwvY29kZT4gdGhhdCBtYXRjaGVzIHBhc3NlZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge0VkaXRDb250YWluZXJ9IHJ1bGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFic1Bvc1xuXHQgKiBAcmV0dXJucyB7RWRpdEVsZW1lbnR9XG5cdCAqL1xuXHRmdW5jdGlvbiBjc3NJdGVtRnJvbVBvc2l0aW9uKHJ1bGUsIGFic1Bvcykge1xuXHRcdC8vIGRvIG5vdCB1c2UgZGVmYXVsdCBFZGl0Q29udGFpbmVyLml0ZW1Gcm9tUG9zaXRpb24oKSBoZXJlLCBiZWNhdXNlXG5cdFx0Ly8gd2UgbmVlZCB0byBtYWtlIGEgZmV3IGFzc3VtcHRpb25zIHRvIG1ha2UgQ1NTIGNvbW1lbnRpbmcgbW9yZSByZWxpYWJsZVxuXHRcdHZhciByZWxQb3MgPSBhYnNQb3MgLSAocnVsZS5vcHRpb25zLm9mZnNldCB8fCAwKTtcblx0XHR2YXIgcmVTYWZlQ2hhciA9IC9eW1xcc1xcblxccl0vO1xuXHRcdHJldHVybiBfLmZpbmQocnVsZS5saXN0KCksIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChpdGVtLnJhbmdlKCkuZW5kID09PSByZWxQb3MpIHtcblx0XHRcdFx0Ly8gYXQgdGhlIGVuZCBvZiBwcm9wZXJ0eSwgYnV0IG91dHNpZGUgb2YgaXRcblx0XHRcdFx0Ly8gaWYgdGhlcmXigJlzIGEgc3BhY2UgY2hhcmFjdGVyIGF0IGN1cnJlbnQgcG9zaXRpb24sXG5cdFx0XHRcdC8vIHVzZSBjdXJyZW50IHByb3BlcnR5XG5cdFx0XHRcdHJldHVybiByZVNhZmVDaGFyLnRlc3QocnVsZS5zb3VyY2UuY2hhckF0KHJlbFBvcykpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gaXRlbS5yYW5nZSgpLmluc2lkZShyZWxQb3MpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaCBmb3IgbmVhcmVzdCBjb21tZW50IGluIDxjb2RlPnN0cjwvY29kZT4sIHN0YXJ0aW5nIGZyb20gaW5kZXggPGNvZGU+ZnJvbTwvY29kZT5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgV2hlcmUgdG8gc2VhcmNoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIFNlYXJjaCBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RhcnRfdG9rZW4gQ29tbWVudCBzdGFydCBzdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVuZF90b2tlbiBDb21tZW50IGVuZCBzdHJpbmdcblx0ICogQHJldHVybiB7UmFuZ2V9IFJldHVybnMgbnVsbCBpZiBjb21tZW50IHdhc24ndCBmb3VuZFxuXHQgKi9cblx0ZnVuY3Rpb24gc2VhcmNoQ29tbWVudCh0ZXh0LCBmcm9tLCBzdGFydFRva2VuLCBlbmRUb2tlbikge1xuXHRcdHZhciBjb21tZW50U3RhcnQgPSAtMTtcblx0XHR2YXIgY29tbWVudEVuZCA9IC0xO1xuXHRcdFxuXHRcdHZhciBoYXNNYXRjaCA9IGZ1bmN0aW9uKHN0ciwgc3RhcnQpIHtcblx0XHRcdHJldHVybiB0ZXh0LnN1YnN0cihzdGFydCwgc3RyLmxlbmd0aCkgPT0gc3RyO1xuXHRcdH07XG5cdFx0XHRcblx0XHQvLyBzZWFyY2ggZm9yIGNvbW1lbnQgc3RhcnRcblx0XHR3aGlsZSAoZnJvbS0tKSB7XG5cdFx0XHRpZiAoaGFzTWF0Y2goc3RhcnRUb2tlbiwgZnJvbSkpIHtcblx0XHRcdFx0Y29tbWVudFN0YXJ0ID0gZnJvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjb21tZW50U3RhcnQgIT0gLTEpIHtcblx0XHRcdC8vIHNlYXJjaCBmb3IgY29tbWVudCBlbmRcblx0XHRcdGZyb20gPSBjb21tZW50U3RhcnQ7XG5cdFx0XHR2YXIgY29udGVudExlbiA9IHRleHQubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGNvbnRlbnRMZW4gPj0gZnJvbSsrKSB7XG5cdFx0XHRcdGlmIChoYXNNYXRjaChlbmRUb2tlbiwgZnJvbSkpIHtcblx0XHRcdFx0XHRjb21tZW50RW5kID0gZnJvbSArIGVuZFRva2VuLmxlbmd0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gKGNvbW1lbnRTdGFydCAhPSAtMSAmJiBjb21tZW50RW5kICE9IC0xKSBcblx0XHRcdD8gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoY29tbWVudFN0YXJ0LCBjb21tZW50RW5kIC0gY29tbWVudFN0YXJ0KSBcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmljIGNvbW1lbnQgdG9nZ2xpbmcgcm91dGluZVxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50U3RhcnQgQ29tbWVudCBzdGFydCB0b2tlblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudEVuZCBDb21tZW50IGVuZCB0b2tlblxuXHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSBTZWxlY3Rpb24gcmFuZ2Vcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGdlbmVyaWNDb21tZW50VG9nZ2xlKGVkaXRvciwgY29tbWVudFN0YXJ0LCBjb21tZW50RW5kLCByYW5nZSkge1xuXHRcdHZhciBlZGl0b3JVdGlscyA9IHJlcXVpcmUoJ2VkaXRvclV0aWxzJyk7XG5cdFx0dmFyIGNvbnRlbnQgPSBlZGl0b3JVdGlscy5vdXRwdXRJbmZvKGVkaXRvcikuY29udGVudDtcblx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHR2YXIgbmV3Q29udGVudCA9IG51bGw7XG5cdFx0XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBjb21tZW50IG1hcmtlcnMgZnJvbSBzdHJpbmdcblx0XHQgKiBAcGFyYW0ge1N0aW5nfSBzdHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlQ29tbWVudChzdHIpIHtcblx0XHRcdHJldHVybiBzdHJcblx0XHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyB1dGlscy5lc2NhcGVGb3JSZWdleHAoY29tbWVudFN0YXJ0KSArICdcXFxccyonKSwgZnVuY3Rpb24oc3RyKXtcblx0XHRcdFx0XHRjYXJldFBvcyAtPSBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fSkucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxccyonICsgdXRpbHMuZXNjYXBlRm9yUmVnZXhwKGNvbW1lbnRFbmQpICsgJyQnKSwgJycpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBmaXJzdCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIHN1YnN0cmluZyBpcyBub3QgaW5zaWRlIFxuXHRcdC8vIGNvbW1lbnRcblx0XHR2YXIgY29tbWVudFJhbmdlID0gc2VhcmNoQ29tbWVudChjb250ZW50LCBjYXJldFBvcywgY29tbWVudFN0YXJ0LCBjb21tZW50RW5kKTtcblx0XHRpZiAoY29tbWVudFJhbmdlICYmIGNvbW1lbnRSYW5nZS5vdmVybGFwKHJhbmdlKSkge1xuXHRcdFx0Ly8gd2UncmUgaW5zaWRlIGNvbW1lbnQsIHJlbW92ZSBpdFxuXHRcdFx0cmFuZ2UgPSBjb21tZW50UmFuZ2U7XG5cdFx0XHRuZXdDb250ZW50ID0gcmVtb3ZlQ29tbWVudChyYW5nZS5zdWJzdHJpbmcoY29udGVudCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBzaG91bGQgYWRkIGNvbW1lbnRcblx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IHRoZXJlJ3Mgbm8gY29tbWVudCBpbnNpZGUgc2VsZWN0aW9uXG5cdFx0XHRuZXdDb250ZW50ID0gY29tbWVudFN0YXJ0ICsgJyAnICtcblx0XHRcdFx0cmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnQpXG5cdFx0XHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cCh1dGlscy5lc2NhcGVGb3JSZWdleHAoY29tbWVudFN0YXJ0KSArICdcXFxccyp8XFxcXHMqJyArIHV0aWxzLmVzY2FwZUZvclJlZ2V4cChjb21tZW50RW5kKSwgJ2cnKSwgJycpICtcblx0XHRcdFx0JyAnICsgY29tbWVudEVuZDtcblx0XHRcdFx0XG5cdFx0XHQvLyBhZGp1c3QgY2FyZXQgcG9zaXRpb25cblx0XHRcdGNhcmV0UG9zICs9IGNvbW1lbnRTdGFydC5sZW5ndGggKyAxO1xuXHRcdH1cblxuXHRcdC8vIHJlcGxhY2UgZWRpdG9yIGNvbnRlbnRcblx0XHRpZiAobmV3Q29udGVudCAhPT0gbnVsbCkge1xuXHRcdFx0bmV3Q29udGVudCA9IHV0aWxzLmVzY2FwZVRleHQobmV3Q29udGVudCk7XG5cdFx0XHRlZGl0b3Iuc2V0Q2FyZXRQb3MocmFuZ2Uuc3RhcnQpO1xuXHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGVkaXRvclV0aWxzLnVuaW5kZW50KGVkaXRvciwgbmV3Q29udGVudCksIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuXHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKGNhcmV0UG9zKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUb2dnbGUgY29tbWVudCBvbiBjdXJyZW50IGVkaXRvcidzIHNlbGVjdGlvbiBvciBIVE1MIHRhZy9DU1MgcnVsZVxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqL1xuXHRyZXF1aXJlKCdhY3Rpb25zJykuYWRkKCd0b2dnbGVfY29tbWVudCcsIGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdHZhciBpbmZvID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0aWYgKGluZm8uc3ludGF4ID09ICdjc3MnKSB7XG5cdFx0XHQvLyBpbiBjYXNlIG91ciBlZGl0b3IgaXMgZ29vZCBlbm91Z2ggYW5kIGNhbiByZWNvZ25pemUgc3ludGF4IGZyb20gXG5cdFx0XHQvLyBjdXJyZW50IHRva2VuLCB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGN1cnNvciBpcyBub3QgaW5zaWRlXG5cdFx0XHQvLyAnc3R5bGUnIGF0dHJpYnV0ZSBvZiBodG1sIGVsZW1lbnRcblx0XHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFx0dmFyIHRhZyA9IHJlcXVpcmUoJ2h0bWxNYXRjaGVyJykudGFnKGluZm8uY29udGVudCwgY2FyZXRQb3MpO1xuXHRcdFx0aWYgKHRhZyAmJiB0YWcub3Blbi5yYW5nZS5pbnNpZGUoY2FyZXRQb3MpKSB7XG5cdFx0XHRcdGluZm8uc3ludGF4ID0gJ2h0bWwnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoaW5mby5zeW50YXggPT0gJ2NzcycpXG5cdFx0XHRyZXR1cm4gdG9nZ2xlQ1NTQ29tbWVudChlZGl0b3IpO1xuXHRcdFxuXHRcdHJldHVybiB0b2dnbGVIVE1MQ29tbWVudChlZGl0b3IpO1xuXHR9KTtcbn0pOy8qKlxuICogTW92ZSBiZXR3ZWVuIG5leHQvcHJldiBlZGl0IHBvaW50cy4gJ0VkaXQgcG9pbnRzJyBhcmUgcGxhY2VzIGJldHdlZW4gdGFncyBcbiAqIGFuZCBxdW90ZXMgb2YgZW1wdHkgYXR0cmlidXRlcyBpbiBodG1sXG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQG1lbWJlck9mIF9fZWRpdFBvaW50QWN0aW9uRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBTZWFyY2ggZm9yIG5ldyBjYXJldCBpbnNlcnRpb24gcG9pbnRcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBFZGl0b3IgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluYyBTZWFyY2ggaW5jcmVtZW50OiAtMSDigJQgc2VhcmNoIGxlZnQsIDEg4oCUIHNlYXJjaCByaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IEluaXRpYWwgb2Zmc2V0IHJlbGF0aXZlIHRvIGN1cnJlbnQgY2FyZXQgcG9zaXRpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIC0xIGlmIGluc2VydGlvbiBwb2ludCB3YXNuJ3QgZm91bmRcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmROZXdFZGl0UG9pbnQoZWRpdG9yLCBpbmMsIG9mZnNldCkge1xuXHRcdGluYyA9IGluYyB8fCAxO1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdFxuXHRcdHZhciBjdXJQb2ludCA9IGVkaXRvci5nZXRDYXJldFBvcygpICsgb2Zmc2V0O1xuXHRcdHZhciBjb250ZW50ID0gU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpO1xuXHRcdHZhciBtYXhMZW4gPSBjb250ZW50Lmxlbmd0aDtcblx0XHR2YXIgbmV4dFBvaW50ID0gLTE7XG5cdFx0dmFyIHJlRW1wdHlMaW5lID0gL15cXHMrJC87XG5cdFx0XG5cdFx0ZnVuY3Rpb24gZ2V0TGluZShpeCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaXg7XG5cdFx0XHR3aGlsZSAoc3RhcnQgPj0gMCkge1xuXHRcdFx0XHR2YXIgYyA9IGNvbnRlbnQuY2hhckF0KHN0YXJ0KTtcblx0XHRcdFx0aWYgKGMgPT0gJ1xcbicgfHwgYyA9PSAnXFxyJylcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0c3RhcnQtLTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0LCBpeCk7XG5cdFx0fVxuXHRcdFx0XG5cdFx0d2hpbGUgKGN1clBvaW50IDw9IG1heExlbiAmJiBjdXJQb2ludCA+PSAwKSB7XG5cdFx0XHRjdXJQb2ludCArPSBpbmM7XG5cdFx0XHR2YXIgY3VyQ2hhciA9IGNvbnRlbnQuY2hhckF0KGN1clBvaW50KTtcblx0XHRcdHZhciBuZXh0Q2hhciA9IGNvbnRlbnQuY2hhckF0KGN1clBvaW50ICsgMSk7XG5cdFx0XHR2YXIgcHJldkNoYXIgPSBjb250ZW50LmNoYXJBdChjdXJQb2ludCAtIDEpO1xuXHRcdFx0XHRcblx0XHRcdHN3aXRjaCAoY3VyQ2hhcikge1xuXHRcdFx0XHRjYXNlICdcIic6XG5cdFx0XHRcdGNhc2UgJ1xcJyc6XG5cdFx0XHRcdFx0aWYgKG5leHRDaGFyID09IGN1ckNoYXIgJiYgcHJldkNoYXIgPT0gJz0nKSB7XG5cdFx0XHRcdFx0XHQvLyBlbXB0eSBhdHRyaWJ1dGVcblx0XHRcdFx0XHRcdG5leHRQb2ludCA9IGN1clBvaW50ICsgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJz4nOlxuXHRcdFx0XHRcdGlmIChuZXh0Q2hhciA9PSAnPCcpIHtcblx0XHRcdFx0XHRcdC8vIGJldHdlZW4gdGFnc1xuXHRcdFx0XHRcdFx0bmV4dFBvaW50ID0gY3VyUG9pbnQgKyAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnXFxuJzpcblx0XHRcdFx0Y2FzZSAnXFxyJzpcblx0XHRcdFx0XHQvLyBlbXB0eSBsaW5lXG5cdFx0XHRcdFx0aWYgKHJlRW1wdHlMaW5lLnRlc3QoZ2V0TGluZShjdXJQb2ludCAtIDEpKSkge1xuXHRcdFx0XHRcdFx0bmV4dFBvaW50ID0gY3VyUG9pbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobmV4dFBvaW50ICE9IC0xKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG5leHRQb2ludDtcblx0fVxuXHRcblx0LyoqIEB0eXBlIGVtbWV0LmFjdGlvbnMgKi9cblx0dmFyIGFjdGlvbnMgPSByZXF1aXJlKCdhY3Rpb25zJyk7XG5cdFxuXHQvKipcblx0ICogTW92ZSBjYXJldCB0byBwcmV2aW91cyBlZGl0IHBvaW50XG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdCAqL1xuXHRhY3Rpb25zLmFkZCgncHJldl9lZGl0X3BvaW50JywgZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0dmFyIGN1clBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdHZhciBuZXdQb2ludCA9IGZpbmROZXdFZGl0UG9pbnQoZWRpdG9yLCAtMSk7XG5cdFx0XHRcblx0XHRpZiAobmV3UG9pbnQgPT0gY3VyUG9zKVxuXHRcdFx0Ly8gd2UncmUgc3RpbGwgaW4gdGhlIHNhbWUgcG9pbnQsIHRyeSBzZWFyY2hpbmcgZnJvbSB0aGUgb3RoZXIgcGxhY2Vcblx0XHRcdG5ld1BvaW50ID0gZmluZE5ld0VkaXRQb2ludChlZGl0b3IsIC0xLCAtMik7XG5cdFx0XG5cdFx0aWYgKG5ld1BvaW50ICE9IC0xKSB7XG5cdFx0XHRlZGl0b3Iuc2V0Q2FyZXRQb3MobmV3UG9pbnQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fSwge2xhYmVsOiAnUHJldmlvdXMgRWRpdCBQb2ludCd9KTtcblx0XG5cdC8qKlxuXHQgKiBNb3ZlIGNhcmV0IHRvIG5leHQgZWRpdCBwb2ludFxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yIEVkaXRvciBpbnN0YW5jZVxuXHQgKi9cblx0YWN0aW9ucy5hZGQoJ25leHRfZWRpdF9wb2ludCcsIGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdHZhciBuZXdQb2ludCA9IGZpbmROZXdFZGl0UG9pbnQoZWRpdG9yLCAxKTtcblx0XHRpZiAobmV3UG9pbnQgIT0gLTEpIHtcblx0XHRcdGVkaXRvci5zZXRDYXJldFBvcyhuZXdQb2ludCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KTtcbn0pOy8qKlxuICogQWN0aW9ucyB0aGF0IHVzZSBzdHJlYW0gcGFyc2VycyBhbmQgdG9rZW5pemVycyBmb3IgdHJhdmVyc2luZzpcbiAqIC0tIFNlYXJjaCBmb3IgbmV4dC9wcmV2aW91cyBpdGVtcyBpbiBIVE1MXG4gKiAtLSBTZWFyY2ggZm9yIG5leHQvcHJldmlvdXMgaXRlbXMgaW4gQ1NTXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX3NlbGVjdEl0ZW1BY3Rpb25EZWZpbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIHN0YXJ0VGFnID0gL148KFtcXHdcXDpcXC1dKykoKD86XFxzK1tcXHdcXC06XSsoPzpcXHMqPVxccyooPzooPzpcIlteXCJdKlwiKXwoPzonW14nXSonKXxbXj5cXHNdKykpPykqKVxccyooXFwvPyk+Lztcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmljIGZ1bmN0aW9uIGZvciBzZWFyY2hpbmcgZm9yIGl0ZW1zIHRvIHNlbGVjdFxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCYWNrd2FyZCBTZWFyY2ggYmFja3dhcmQgKHNlYXJjaCBmb3J3YXJkIG90aGVyd2lzZSlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZXh0cmFjdEZuIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgaXRlbSBjb250ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJhbmdlRm4gRnVuY3Rpb24gdGhhdCBzZWFyY2ggZm9yIG5leHQgdG9rZW4gcmFuZ2Vcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRJdGVtKGVkaXRvciwgaXNCYWNrd2FyZCwgZXh0cmFjdEZuLCByYW5nZUZuKSB7XG5cdFx0dmFyIHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKTtcblx0XHR2YXIgY29udGVudCA9IHJlcXVpcmUoJ2VkaXRvclV0aWxzJykub3V0cHV0SW5mbyhlZGl0b3IpLmNvbnRlbnQ7XG5cdFx0XG5cdFx0dmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcblx0XHR2YXIgaXRlbVJhbmdlLCBybmc7XG5cdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0dmFyIHByZXZSYW5nZSA9IHJhbmdlLmNyZWF0ZSgtMSwgMCk7XG5cdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0dmFyIHNlbCA9IHJhbmdlLmNyZWF0ZShlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG5cdFx0XG5cdFx0dmFyIHNlYXJjaFBvcyA9IHNlbC5zdGFydCwgbG9vcCA9IDEwMDAwMDsgLy8gZW5kbGVzcyBsb29wIHByb3RlY3Rpb25cblx0XHR3aGlsZSAoc2VhcmNoUG9zID49IDAgJiYgc2VhcmNoUG9zIDwgY29udGVudExlbmd0aCAmJiAtLWxvb3AgPiAwKSB7XG5cdFx0XHRpZiAoIChpdGVtUmFuZ2UgPSBleHRyYWN0Rm4oY29udGVudCwgc2VhcmNoUG9zLCBpc0JhY2t3YXJkKSkgKSB7XG5cdFx0XHRcdGlmIChwcmV2UmFuZ2UuZXF1YWwoaXRlbVJhbmdlKSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRwcmV2UmFuZ2UgPSBpdGVtUmFuZ2UuY2xvbmUoKTtcblx0XHRcdFx0cm5nID0gcmFuZ2VGbihpdGVtUmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnQpLCBpdGVtUmFuZ2Uuc3RhcnQsIHNlbC5jbG9uZSgpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChybmcpIHtcblx0XHRcdFx0XHRlZGl0b3IuY3JlYXRlU2VsZWN0aW9uKHJuZy5zdGFydCwgcm5nLmVuZCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VhcmNoUG9zID0gaXNCYWNrd2FyZCA/IGl0ZW1SYW5nZS5zdGFydCA6IGl0ZW1SYW5nZS5lbmQgLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHNlYXJjaFBvcyArPSBpc0JhY2t3YXJkID8gLTEgOiAxO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdC8vIFhYWCBIVE1MIHNlY3Rpb25cblx0XG5cdC8qKlxuXHQgKiBGaW5kIG5leHQgSFRNTCBpdGVtXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmROZXh0SFRNTEl0ZW0oZWRpdG9yKSB7XG5cdFx0dmFyIGlzRmlyc3QgPSB0cnVlO1xuXHRcdHJldHVybiBmaW5kSXRlbShlZGl0b3IsIGZhbHNlLCBmdW5jdGlvbihjb250ZW50LCBzZWFyY2hQb3Mpe1xuXHRcdFx0aWYgKGlzRmlyc3QpIHtcblx0XHRcdFx0aXNGaXJzdCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gZmluZE9wZW5pbmdUYWdGcm9tUG9zaXRpb24oY29udGVudCwgc2VhcmNoUG9zKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBnZXRPcGVuaW5nVGFnRnJvbVBvc2l0aW9uKGNvbnRlbnQsIHNlYXJjaFBvcyk7XG5cdFx0XHR9XG5cdFx0fSwgZnVuY3Rpb24odGFnLCBvZmZzZXQsIHNlbFJhbmdlKSB7XG5cdFx0XHRyZXR1cm4gZ2V0UmFuZ2VGb3JIVE1MSXRlbSh0YWcsIG9mZnNldCwgc2VsUmFuZ2UsIGZhbHNlKTtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEZpbmQgcHJldmlvdXMgSFRNTCBpdGVtXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRQcmV2SFRNTEl0ZW0oZWRpdG9yKSB7XG5cdFx0cmV0dXJuIGZpbmRJdGVtKGVkaXRvciwgdHJ1ZSwgZ2V0T3BlbmluZ1RhZ0Zyb21Qb3NpdGlvbiwgZnVuY3Rpb24gKHRhZywgb2Zmc2V0LCBzZWxSYW5nZSkge1xuXHRcdFx0cmV0dXJuIGdldFJhbmdlRm9ySFRNTEl0ZW0odGFnLCBvZmZzZXQsIHNlbFJhbmdlLCB0cnVlKTtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgcG9zc2libGUgc2VsZWN0aW9uIHJhbmdlcyBmb3IgSFRNTCB0YWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSBPcmlnaW5hbCBIVE1MIHNvdXJjZSBmb3IgdG9rZW5zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBMaXN0IG9mIEhUTUwgdG9rZW5zXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIG1ha2VQb3NzaWJsZVJhbmdlc0hUTUwoc291cmNlLCB0b2tlbnMsIG9mZnNldCkge1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdHZhciByYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJyk7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBhdHRyU3RhcnQgPSAtMSwgYXR0ck5hbWUgPSAnJywgYXR0clZhbHVlID0gJycsIGF0dHJWYWx1ZVJhbmdlLCB0YWdOYW1lO1xuXHRcdF8uZWFjaCh0b2tlbnMsIGZ1bmN0aW9uKHRvaykge1xuXHRcdFx0c3dpdGNoICh0b2sudHlwZSkge1xuXHRcdFx0XHRjYXNlICd0YWcnOlxuXHRcdFx0XHRcdHRhZ05hbWUgPSBzb3VyY2Uuc3Vic3RyaW5nKHRvay5zdGFydCwgdG9rLmVuZCk7XG5cdFx0XHRcdFx0aWYgKC9ePFtcXHdcXDpcXC1dLy50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHQvLyBhZGQgdGFnIG5hbWVcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlLmNyZWF0ZSh7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiB0b2suc3RhcnQgKyAxLCBcblx0XHRcdFx0XHRcdFx0ZW5kOiB0b2suZW5kXG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdhdHRyaWJ1dGUnOlxuXHRcdFx0XHRcdGF0dHJTdGFydCA9IHRvay5zdGFydDtcblx0XHRcdFx0XHRhdHRyTmFtZSA9IHNvdXJjZS5zdWJzdHJpbmcodG9rLnN0YXJ0LCB0b2suZW5kKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0XHQvLyBhdHRyaWJ1dGUgdmFsdWVcblx0XHRcdFx0XHQvLyBwdXNoIGZ1bGwgYXR0cmlidXRlIGZpcnN0XG5cdFx0XHRcdFx0IHJlc3VsdC5wdXNoKHJhbmdlLmNyZWF0ZShhdHRyU3RhcnQsIHRvay5lbmQgLSBhdHRyU3RhcnQpKTtcblx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0IGF0dHJWYWx1ZVJhbmdlID0gcmFuZ2UuY3JlYXRlKHRvayk7XG5cdFx0XHRcdFx0IGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZVJhbmdlLnN1YnN0cmluZyhzb3VyY2UpO1xuXHRcdFx0XHRcdCBcblx0XHRcdFx0XHQgLy8gaXMgdGhpcyBhIHF1b3RlZCBhdHRyaWJ1dGU/XG5cdFx0XHRcdFx0IGlmIChpc1F1b3RlKGF0dHJWYWx1ZS5jaGFyQXQoMCkpKVxuXHRcdFx0XHRcdFx0IGF0dHJWYWx1ZVJhbmdlLnN0YXJ0Kys7XG5cdFx0XHRcdFx0IFxuXHRcdFx0XHRcdCBpZiAoaXNRdW90ZShhdHRyVmFsdWUuY2hhckF0KGF0dHJWYWx1ZS5sZW5ndGggLSAxKSkpXG5cdFx0XHRcdFx0XHQgYXR0clZhbHVlUmFuZ2UuZW5kLS07XG5cdFx0XHRcdFx0IFxuXHRcdFx0XHRcdCByZXN1bHQucHVzaChhdHRyVmFsdWVSYW5nZSk7XG5cdFx0XHRcdFx0IFxuXHRcdFx0XHRcdCBpZiAoYXR0ck5hbWUgPT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0IHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY2xhc3NOYW1lUmFuZ2VzKGF0dHJWYWx1ZVJhbmdlLnN1YnN0cmluZyhzb3VyY2UpLCBhdHRyVmFsdWVSYW5nZS5zdGFydCkpO1xuXHRcdFx0XHRcdCB9XG5cdFx0XHRcdFx0IFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdC8vIG9mZnNldCByYW5nZXNcblx0XHRfLmVhY2gocmVzdWx0LCBmdW5jdGlvbihyKSB7XG5cdFx0XHRyLnNoaWZ0KG9mZnNldCk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIF8uY2hhaW4ocmVzdWx0KVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7ICAgICAgICAvLyByZW1vdmUgZW1wdHlcblx0XHRcdFx0cmV0dXJuICEhaXRlbS5sZW5ndGgoKTtcblx0XHRcdH0pXG5cdFx0XHQudW5pcShmYWxzZSwgZnVuY3Rpb24oaXRlbSkgeyAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRcdHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnZhbHVlKCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJhbmdlcyBvZiBjbGFzcyBuYW1lcyBpbiBcImNsYXNzXCIgYXR0cmlidXRlIHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gY2xhc3NOYW1lUmFuZ2VzKGNsYXNzTmFtZSwgb2Zmc2V0KSB7XG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdC8qKiBAdHlwZSBTdHJpbmdTdHJlYW0gKi9cblx0XHR2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyaW5nU3RyZWFtJykuY3JlYXRlKGNsYXNzTmFtZSk7XG5cdFx0dmFyIHJhbmdlID0gcmVxdWlyZSgncmFuZ2UnKTtcblx0XHRcblx0XHQvLyBza2lwIHdoaXRlc3BhY2Vcblx0XHRzdHJlYW0uZWF0U3BhY2UoKTtcblx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFxuXHRcdHZhciBjaDtcblx0XHR3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG5cdFx0XHRpZiAoL1tcXHNcXHUwMGEwXS8udGVzdChjaCkpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2gocmFuZ2UuY3JlYXRlKHN0cmVhbS5zdGFydCArIG9mZnNldCwgc3RyZWFtLnBvcyAtIHN0cmVhbS5zdGFydCAtIDEpKTtcblx0XHRcdFx0c3RyZWFtLmVhdFNwYWNlKCk7XG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJlc3VsdC5wdXNoKHJhbmdlLmNyZWF0ZShzdHJlYW0uc3RhcnQgKyBvZmZzZXQsIHN0cmVhbS5wb3MgLSBzdHJlYW0uc3RhcnQpKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBiZXN0IEhUTUwgdGFnIHJhbmdlIG1hdGNoIGZvciBjdXJyZW50IHNlbGVjdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGFnIFRhZyBkZWNsYXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRhZydzIHBvc2l0aW9uIGluZGV4IGluc2lkZSBjb250ZW50XG5cdCAqIEBwYXJhbSB7UmFuZ2V9IHNlbFJhbmdlIFNlbGVjdGlvbiByYW5nZVxuXHQgKiBAcmV0dXJuIHtSYW5nZX0gUmV0dXJucyByYW5nZSBpZiBuZXh0IGl0ZW0gd2FzIGZvdW5kLCA8Y29kZT5udWxsPC9jb2RlPiBvdGhlcndpc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGdldFJhbmdlRm9ySFRNTEl0ZW0odGFnLCBvZmZzZXQsIHNlbFJhbmdlLCBpc0JhY2t3YXJkKSB7XG5cdFx0dmFyIHJhbmdlcyA9IG1ha2VQb3NzaWJsZVJhbmdlc0hUTUwodGFnLCByZXF1aXJlKCd4bWxQYXJzZXInKS5wYXJzZSh0YWcpLCBvZmZzZXQpO1xuXHRcdFxuXHRcdGlmIChpc0JhY2t3YXJkKVxuXHRcdFx0cmFuZ2VzLnJldmVyc2UoKTtcblx0XHRcblx0XHQvLyB0cnkgdG8gZmluZCBzZWxlY3RlZCByYW5nZVxuXHRcdHZhciBjdXJSYW5nZSA9IF8uZmluZChyYW5nZXMsIGZ1bmN0aW9uKHIpIHtcblx0XHRcdHJldHVybiByLmVxdWFsKHNlbFJhbmdlKTtcblx0XHR9KTtcblx0XHRcblx0XHRpZiAoY3VyUmFuZ2UpIHtcblx0XHRcdHZhciBpeCA9IF8uaW5kZXhPZihyYW5nZXMsIGN1clJhbmdlKTtcblx0XHRcdGlmIChpeCA8IHJhbmdlcy5sZW5ndGggLSAxKVxuXHRcdFx0XHRyZXR1cm4gcmFuZ2VzW2l4ICsgMV07XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvLyBubyBzZWxlY3RlZCByYW5nZSwgZmluZCBuZWFyZXN0IG9uZVxuXHRcdGlmIChpc0JhY2t3YXJkKVxuXHRcdFx0Ly8gc2VhcmNoIGJhY2t3YXJkXG5cdFx0XHRyZXR1cm4gXy5maW5kKHJhbmdlcywgZnVuY3Rpb24ocikge1xuXHRcdFx0XHRyZXR1cm4gci5zdGFydCA8IHNlbFJhbmdlLnN0YXJ0O1xuXHRcdFx0fSk7XG5cdFx0XG5cdFx0Ly8gc2VhcmNoIGZvcndhcmRcblx0XHQvLyB0byBkZWFsIHdpdGggb3ZlcmxhcHBpbmcgcmFuZ2VzIChsaWtlIGZ1bGwgYXR0cmlidXRlIGRlZmluaXRpb25cblx0XHQvLyBhbmQgYXR0cmlidXRlIHZhbHVlKSBsZXQncyBmaW5kIHJhbmdlIHVuZGVyIGNhcmV0IGZpcnN0XG5cdFx0aWYgKCFjdXJSYW5nZSkge1xuXHRcdFx0dmFyIG1hdGNoZWRSYW5nZXMgPSBfLmZpbHRlcihyYW5nZXMsIGZ1bmN0aW9uKHIpIHtcblx0XHRcdFx0cmV0dXJuIHIuaW5zaWRlKHNlbFJhbmdlLmVuZCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoZWRSYW5nZXMubGVuZ3RoID4gMSlcblx0XHRcdFx0cmV0dXJuIG1hdGNoZWRSYW5nZXNbMV07XG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdHJldHVybiBfLmZpbmQocmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRyZXR1cm4gci5lbmQgPiBzZWxSYW5nZS5lbmQ7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZWFyY2ggZm9yIG9wZW5pbmcgdGFnIGluIGNvbnRlbnQsIHN0YXJ0aW5nIGF0IHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBXaGVyZSB0byBzZWFyY2ggdGFnXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgQ2hhcmFjdGVyIGluZGV4IHdoZXJlIHRvIHN0YXJ0IHNlYXJjaGluZ1xuXHQgKiBAcmV0dXJuIHtSYW5nZX0gUmV0dXJucyByYW5nZSBpZiB2YWxpZCBvcGVuaW5nIHRhZyB3YXMgZm91bmQsXG5cdCAqIDxjb2RlPm51bGw8L2NvZGU+IG90aGVyd2lzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZmluZE9wZW5pbmdUYWdGcm9tUG9zaXRpb24oaHRtbCwgcG9zKSB7XG5cdFx0dmFyIHRhZztcblx0XHR3aGlsZSAocG9zID49IDApIHtcblx0XHRcdGlmICh0YWcgPSBnZXRPcGVuaW5nVGFnRnJvbVBvc2l0aW9uKGh0bWwsIHBvcykpXG5cdFx0XHRcdHJldHVybiB0YWc7XG5cdFx0XHRwb3MtLTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBXaGVyZSB0byBzZWFyY2ggdGFnXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgQ2hhcmFjdGVyIGluZGV4IHdoZXJlIHRvIHN0YXJ0IHNlYXJjaGluZ1xuXHQgKiBAcmV0dXJuIHtSYW5nZX0gUmV0dXJucyByYW5nZSBpZiB2YWxpZCBvcGVuaW5nIHRhZyB3YXMgZm91bmQsXG5cdCAqIDxjb2RlPm51bGw8L2NvZGU+IG90aGVyd2lzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0T3BlbmluZ1RhZ0Zyb21Qb3NpdGlvbihodG1sLCBwb3MpIHtcblx0XHR2YXIgbTtcblx0XHRpZiAoaHRtbC5jaGFyQXQocG9zKSA9PSAnPCcgJiYgKG0gPSBodG1sLnN1YnN0cmluZyhwb3MsIGh0bWwubGVuZ3RoKS5tYXRjaChzdGFydFRhZykpKSB7XG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUocG9zLCBtWzBdKTtcblx0XHR9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzUXVvdGUoY2gpIHtcblx0XHRyZXR1cm4gY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIE1ha2VzIGFsbCBwb3NzaWJsZSBzZWxlY3Rpb24gcmFuZ2VzIGZvciBzcGVjaWZpZWQgQ1NTIHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7Q1NTUHJvcGVydHl9IHByb3BlcnR5XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIG1ha2VQb3NzaWJsZVJhbmdlc0NTUyhwcm9wZXJ0eSkge1xuXHRcdC8vIGZpbmQgYWxsIHBvc3NpYmxlIHJhbmdlcywgc29ydGVkIGJ5IHBvc2l0aW9uIGFuZCBzaXplXG5cdFx0dmFyIHZhbHVlUmFuZ2UgPSBwcm9wZXJ0eS52YWx1ZVJhbmdlKHRydWUpO1xuXHRcdHZhciByZXN1bHQgPSBbcHJvcGVydHkucmFuZ2UodHJ1ZSksIHZhbHVlUmFuZ2VdO1xuXHRcdHZhciBzdHJpbmdTdHJlYW0gPSByZXF1aXJlKCdzdHJpbmdTdHJlYW0nKTtcblx0XHR2YXIgY3NzRWRpdFRyZWUgPSByZXF1aXJlKCdjc3NFZGl0VHJlZScpO1xuXHRcdHZhciByYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJyk7XG5cdFx0XG5cdFx0Ly8gbG9jYXRlIHBhcnRzIG9mIGNvbXBsZXggdmFsdWVzLlxuXHRcdC8vIHNvbWUgZXhhbXBsZXM6XG5cdFx0Ly8g4oCTIDFweCBzb2xpZCByZWQ6IDMgcGFydHNcblx0XHQvLyDigJMgYXJpYWwsIHNhbnMtc2VyaWY6IGVudW1lcmF0aW9uLCAyIHBhcnRzXG5cdFx0Ly8g4oCTIHVybChpbWFnZS5wbmcpOiBmdW5jdGlvbiB2YWx1ZSBwYXJ0XG5cdFx0dmFyIHZhbHVlID0gcHJvcGVydHkudmFsdWUoKTtcblx0XHRfLmVhY2gocHJvcGVydHkudmFsdWVQYXJ0cygpLCBmdW5jdGlvbihyKSB7XG5cdFx0XHQvLyBhZGQgYWJzb2x1dGUgcmFuZ2Vcblx0XHRcdHZhciBjbG9uZSA9IHIuY2xvbmUoKTtcblx0XHRcdHJlc3VsdC5wdXNoKGNsb25lLnNoaWZ0KHZhbHVlUmFuZ2Uuc3RhcnQpKTtcblx0XHRcdFxuXHRcdFx0LyoqIEB0eXBlIFN0cmluZ1N0cmVhbSAqL1xuXHRcdFx0dmFyIHN0cmVhbSA9IHN0cmluZ1N0cmVhbS5jcmVhdGUoci5zdWJzdHJpbmcodmFsdWUpKTtcblx0XHRcdGlmIChzdHJlYW0ubWF0Y2goL15bXFx3XFwtXStcXCgvLCB0cnVlKSkge1xuXHRcdFx0XHQvLyB3ZSBoYXZlIGEgZnVuY3Rpb24sIGZpbmQgdmFsdWVzIGluIGl0LlxuXHRcdFx0XHQvLyBidXQgZmlyc3QgYWRkIGZ1bmN0aW9uIGNvbnRlbnRzXG5cdFx0XHRcdHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG5cdFx0XHRcdHN0cmVhbS5za2lwVG9QYWlyKCcoJywgJyknKTtcblx0XHRcdFx0dmFyIGZuQm9keSA9IHN0cmVhbS5jdXJyZW50KCk7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlLmNyZWF0ZShjbG9uZS5zdGFydCArIHN0cmVhbS5zdGFydCwgZm5Cb2R5KSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBmaW5kIHBhcnRzXG5cdFx0XHRcdF8uZWFjaChjc3NFZGl0VHJlZS5maW5kUGFydHMoZm5Cb2R5KSwgZnVuY3Rpb24ocGFydCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJhbmdlLmNyZWF0ZShjbG9uZS5zdGFydCArIHN0cmVhbS5zdGFydCArIHBhcnQuc3RhcnQsIHBhcnQuc3Vic3RyaW5nKGZuQm9keSkpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gb3B0aW1pemUgcmVzdWx0OiByZW1vdmUgZW1wdHkgcmFuZ2VzIGFuZCBkdXBsaWNhdGVzXG5cdFx0cmV0dXJuIF8uY2hhaW4ocmVzdWx0KVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAhIWl0ZW0ubGVuZ3RoKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnVuaXEoZmFsc2UsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcblx0XHRcdH0pXG5cdFx0XHQudmFsdWUoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRyaWVzIHRvIGZpbmQgbWF0Y2hlZCBDU1MgcHJvcGVydHkgYW5kIG5lYXJlc3QgcmFuZ2UgZm9yIHNlbGVjdGlvblxuXHQgKiBAcGFyYW0ge0NTU1J1bGV9IHJ1bGVcblx0ICogQHBhcmFtIHtSYW5nZX0gc2VsUmFuZ2Vcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JhY2t3YXJkXG5cdCAqIEByZXR1cm5zIHtSYW5nZX1cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoZWRSYW5nZUZvckNTU1Byb3BlcnR5KHJ1bGUsIHNlbFJhbmdlLCBpc0JhY2t3YXJkKSB7XG5cdFx0LyoqIEB0eXBlIENTU1Byb3BlcnR5ICovXG5cdFx0dmFyIHByb3BlcnR5ID0gbnVsbDtcblx0XHR2YXIgcG9zc2libGVSYW5nZXMsIGN1clJhbmdlID0gbnVsbCwgaXg7XG5cdFx0dmFyIGxpc3QgPSBydWxlLmxpc3QoKTtcblx0XHR2YXIgc2VhcmNoRm4sIG5lYXJlc3RJdGVtRm47XG5cdFx0XG5cdFx0aWYgKGlzQmFja3dhcmQpIHtcblx0XHRcdGxpc3QucmV2ZXJzZSgpO1xuXHRcdFx0c2VhcmNoRm4gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBwLnJhbmdlKHRydWUpLnN0YXJ0IDw9IHNlbFJhbmdlLnN0YXJ0O1xuXHRcdFx0fTtcblx0XHRcdG5lYXJlc3RJdGVtRm4gPSBmdW5jdGlvbihyKSB7XG5cdFx0XHRcdHJldHVybiByLnN0YXJ0IDwgc2VsUmFuZ2Uuc3RhcnQ7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWFyY2hGbiA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHAucmFuZ2UodHJ1ZSkuZW5kID49IHNlbFJhbmdlLmVuZDtcblx0XHRcdH07XG5cdFx0XHRuZWFyZXN0SXRlbUZuID0gZnVuY3Rpb24ocikge1xuXHRcdFx0XHRyZXR1cm4gci5lbmQgPiBzZWxSYW5nZS5zdGFydDtcblx0XHRcdH07XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHNlYXJjaCBmb3IgbmVhcmVzdCB0byBzZWxlY3Rpb24gQ1NTIHByb3BlcnR5XG5cdFx0d2hpbGUgKHByb3BlcnR5ID0gXy5maW5kKGxpc3QsIHNlYXJjaEZuKSkge1xuXHRcdFx0cG9zc2libGVSYW5nZXMgPSBtYWtlUG9zc2libGVSYW5nZXNDU1MocHJvcGVydHkpO1xuXHRcdFx0aWYgKGlzQmFja3dhcmQpXG5cdFx0XHRcdHBvc3NpYmxlUmFuZ2VzLnJldmVyc2UoKTtcblx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgaWYgYW55IHBvc3NpYmxlIHJhbmdlIGlzIGFscmVhZHkgc2VsZWN0ZWRcblx0XHRcdGN1clJhbmdlID0gXy5maW5kKHBvc3NpYmxlUmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRcdHJldHVybiByLmVxdWFsKHNlbFJhbmdlKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWN1clJhbmdlKSB7XG5cdFx0XHRcdC8vIG5vIHNlbGVjdGlvbiwgc2VsZWN0IG5lYXJlc3QgaXRlbVxuXHRcdFx0XHR2YXIgbWF0Y2hlZFJhbmdlcyA9IF8uZmlsdGVyKHBvc3NpYmxlUmFuZ2VzLCBmdW5jdGlvbihyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHIuaW5zaWRlKHNlbFJhbmdlLmVuZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG1hdGNoZWRSYW5nZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGN1clJhbmdlID0gbWF0Y2hlZFJhbmdlc1sxXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1clJhbmdlID0gXy5maW5kKHBvc3NpYmxlUmFuZ2VzLCBuZWFyZXN0SXRlbUZuKSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGl4ID0gXy5pbmRleE9mKHBvc3NpYmxlUmFuZ2VzLCBjdXJSYW5nZSk7XG5cdFx0XHRcdGlmIChpeCAhPSBwb3NzaWJsZVJhbmdlcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0Y3VyUmFuZ2UgPSBwb3NzaWJsZVJhbmdlc1tpeCArIDFdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGN1clJhbmdlID0gbnVsbDtcblx0XHRcdHNlbFJhbmdlLnN0YXJ0ID0gc2VsUmFuZ2UuZW5kID0gaXNCYWNrd2FyZCBcblx0XHRcdFx0PyBwcm9wZXJ0eS5yYW5nZSh0cnVlKS5zdGFydCAtIDFcblx0XHRcdFx0OiBwcm9wZXJ0eS5yYW5nZSh0cnVlKS5lbmQgKyAxO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY3VyUmFuZ2U7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGZpbmROZXh0Q1NTSXRlbShlZGl0b3IpIHtcblx0XHRyZXR1cm4gZmluZEl0ZW0oZWRpdG9yLCBmYWxzZSwgcmVxdWlyZSgnY3NzRWRpdFRyZWUnKS5leHRyYWN0UnVsZSwgZ2V0UmFuZ2VGb3JOZXh0SXRlbUluQ1NTKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZmluZFByZXZDU1NJdGVtKGVkaXRvcikge1xuXHRcdHJldHVybiBmaW5kSXRlbShlZGl0b3IsIHRydWUsIHJlcXVpcmUoJ2Nzc0VkaXRUcmVlJykuZXh0cmFjdFJ1bGUsIGdldFJhbmdlRm9yUHJldkl0ZW1JbkNTUyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHJhbmdlIGZvciBpdGVtIHRvIGJlIHNlbGVjdGVkIGluIENTUyBhZnRlciBjdXJyZW50IGNhcmV0IFxuXHQgKiAoc2VsZWN0aW9uKSBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcnVsZSBDU1MgcnVsZSBkZWNsYXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFJ1bGUncyBwb3NpdGlvbiBpbmRleCBpbnNpZGUgY29udGVudFxuXHQgKiBAcGFyYW0ge1JhbmdlfSBzZWxSYW5nZSBTZWxlY3Rpb24gcmFuZ2Vcblx0ICogQHJldHVybiB7UmFuZ2V9IFJldHVybnMgcmFuZ2UgaWYgbmV4dCBpdGVtIHdhcyBmb3VuZCwgPGNvZGU+bnVsbDwvY29kZT4gb3RoZXJ3aXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSYW5nZUZvck5leHRJdGVtSW5DU1MocnVsZSwgb2Zmc2V0LCBzZWxSYW5nZSkge1xuXHRcdHZhciB0cmVlID0gcmVxdWlyZSgnY3NzRWRpdFRyZWUnKS5wYXJzZShydWxlLCB7XG5cdFx0XHRvZmZzZXQ6IG9mZnNldFxuXHRcdH0pO1xuXHRcdFxuXHRcdC8vIGNoZWNrIGlmIHNlbGVjdG9yIGlzIG1hdGNoZWRcblx0XHR2YXIgcmFuZ2UgPSB0cmVlLm5hbWVSYW5nZSh0cnVlKTtcblx0XHRpZiAoc2VsUmFuZ2UuZW5kIDwgcmFuZ2UuZW5kKSB7XG5cdFx0XHRyZXR1cm4gcmFuZ2U7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBtYXRjaGVkUmFuZ2VGb3JDU1NQcm9wZXJ0eSh0cmVlLCBzZWxSYW5nZSwgZmFsc2UpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyByYW5nZSBmb3IgaXRlbSB0byBiZSBzZWxlY3RlZCBpbiBDU1MgYmVmb3JlIGN1cnJlbnQgY2FyZXQgXG5cdCAqIChzZWxlY3Rpb24pIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBydWxlIENTUyBydWxlIGRlY2xhcmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgUnVsZSdzIHBvc2l0aW9uIGluZGV4IGluc2lkZSBjb250ZW50XG5cdCAqIEBwYXJhbSB7UmFuZ2V9IHNlbFJhbmdlIFNlbGVjdGlvbiByYW5nZVxuXHQgKiBAcmV0dXJuIHtSYW5nZX0gUmV0dXJucyByYW5nZSBpZiBwcmV2aW91cyBpdGVtIHdhcyBmb3VuZCwgPGNvZGU+bnVsbDwvY29kZT4gb3RoZXJ3aXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSYW5nZUZvclByZXZJdGVtSW5DU1MocnVsZSwgb2Zmc2V0LCBzZWxSYW5nZSkge1xuXHRcdHZhciB0cmVlID0gcmVxdWlyZSgnY3NzRWRpdFRyZWUnKS5wYXJzZShydWxlLCB7XG5cdFx0XHRvZmZzZXQ6IG9mZnNldFxuXHRcdH0pO1xuXHRcdFxuXHRcdHZhciBjdXJSYW5nZSA9IG1hdGNoZWRSYW5nZUZvckNTU1Byb3BlcnR5KHRyZWUsIHNlbFJhbmdlLCB0cnVlKTtcblx0XHRcblx0XHRpZiAoIWN1clJhbmdlKSB7XG5cdFx0XHQvLyBubyBtYXRjaGVkIHByb3BlcnR5LCB0cnkgdG8gbWF0Y2ggc2VsZWN0b3Jcblx0XHRcdHZhciByYW5nZSA9IHRyZWUubmFtZVJhbmdlKHRydWUpO1xuXHRcdFx0aWYgKHNlbFJhbmdlLnN0YXJ0ID4gcmFuZ2Uuc3RhcnQpIHtcblx0XHRcdFx0cmV0dXJuIHJhbmdlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY3VyUmFuZ2U7XG5cdH1cblx0XG5cdC8vIFhYWCByZWdpc3RlciBhY3Rpb25zXG5cdHZhciBhY3Rpb25zID0gcmVxdWlyZSgnYWN0aW9ucycpO1xuXHRhY3Rpb25zLmFkZCgnc2VsZWN0X25leHRfaXRlbScsIGZ1bmN0aW9uKGVkaXRvcil7XG5cdFx0aWYgKGVkaXRvci5nZXRTeW50YXgoKSA9PSAnY3NzJylcblx0XHRcdHJldHVybiBmaW5kTmV4dENTU0l0ZW0oZWRpdG9yKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gZmluZE5leHRIVE1MSXRlbShlZGl0b3IpO1xuXHR9KTtcblx0XG5cdGFjdGlvbnMuYWRkKCdzZWxlY3RfcHJldmlvdXNfaXRlbScsIGZ1bmN0aW9uKGVkaXRvcil7XG5cdFx0aWYgKGVkaXRvci5nZXRTeW50YXgoKSA9PSAnY3NzJylcblx0XHRcdHJldHVybiBmaW5kUHJldkNTU0l0ZW0oZWRpdG9yKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gZmluZFByZXZIVE1MSXRlbShlZGl0b3IpO1xuXHR9KTtcbn0pOy8qKlxuICogSFRNTCBwYWlyIG1hdGNoaW5nIChiYWxhbmNpbmcpIGFjdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1lbWJlck9mIF9fbWF0Y2hQYWlyQWN0aW9uRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKiBAdHlwZSBlbW1ldC5hY3Rpb25zICovXG5cdHZhciBhY3Rpb25zID0gcmVxdWlyZSgnYWN0aW9ucycpO1xuXHR2YXIgbWF0Y2hlciA9IHJlcXVpcmUoJ2h0bWxNYXRjaGVyJyk7XG5cdHZhciBsYXN0TWF0Y2ggPSBudWxsO1xuXHRcblx0LyoqXG5cdCAqIEZpbmQgYW5kIHNlbGVjdCBIVE1MIHRhZyBwYWlyXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3IgRWRpdG9yIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHBhaXIgbWF0Y2hpbmc6ICdpbicgb3IgJ291dCcuIFxuXHQgKiBEZWZhdWx0IGlzICdvdXQnXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaFBhaXIoZWRpdG9yLCBkaXJlY3Rpb24pIHtcblx0XHRkaXJlY3Rpb24gPSBTdHJpbmcoKGRpcmVjdGlvbiB8fCAnb3V0JykudG9Mb3dlckNhc2UoKSk7XG5cdFx0dmFyIGluZm8gPSByZXF1aXJlKCdlZGl0b3JVdGlscycpLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHRcblx0XHR2YXIgcmFuZ2UgPSByZXF1aXJlKCdyYW5nZScpO1xuXHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdHZhciBzZWwgPSByYW5nZS5jcmVhdGUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdHZhciBjb250ZW50ID0gaW5mby5jb250ZW50O1xuXHRcdFxuXHRcdC8vIHZhbGlkYXRlIHByZXZpb3VzIG1hdGNoXG5cdFx0aWYgKGxhc3RNYXRjaCAmJiAhbGFzdE1hdGNoLnJhbmdlLmVxdWFsKHNlbCkpIHtcblx0XHRcdGxhc3RNYXRjaCA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChsYXN0TWF0Y2ggJiYgc2VsLmxlbmd0aCgpKSB7XG5cdFx0XHRpZiAoZGlyZWN0aW9uID09ICdpbicpIHtcblx0XHRcdFx0Ly8gdXNlciBoYXMgcHJldmlvdXNseSBzZWxlY3RlZCB0YWcgYW5kIHdhbnRzIHRvIG1vdmUgaW53YXJkXG5cdFx0XHRcdGlmIChsYXN0TWF0Y2gudHlwZSA9PSAndGFnJyAmJiAhbGFzdE1hdGNoLmNsb3NlKSB7XG5cdFx0XHRcdFx0Ly8gdW5hcnkgdGFnIHdhcyBzZWxlY3RlZCwgY2FuJ3QgbW92ZSBpbndhcmRcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGxhc3RNYXRjaC5yYW5nZS5lcXVhbChsYXN0TWF0Y2gub3V0ZXJSYW5nZSkpIHtcblx0XHRcdFx0XHRcdGxhc3RNYXRjaC5yYW5nZSA9IGxhc3RNYXRjaC5pbm5lclJhbmdlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgbmFycm93ZWQgPSByZXF1aXJlKCd1dGlscycpLm5hcnJvd1RvTm9uU3BhY2UoY29udGVudCwgbGFzdE1hdGNoLmlubmVyUmFuZ2UpO1xuXHRcdFx0XHRcdFx0bGFzdE1hdGNoID0gbWF0Y2hlci5maW5kKGNvbnRlbnQsIG5hcnJvd2VkLnN0YXJ0ICsgMSk7XG5cdFx0XHRcdFx0XHRpZiAobGFzdE1hdGNoICYmIGxhc3RNYXRjaC5yYW5nZS5lcXVhbChzZWwpICYmIGxhc3RNYXRjaC5vdXRlclJhbmdlLmVxdWFsKHNlbCkpIHtcblx0XHRcdFx0XHRcdFx0bGFzdE1hdGNoLnJhbmdlID0gbGFzdE1hdGNoLmlubmVyUmFuZ2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHQhbGFzdE1hdGNoLmlubmVyUmFuZ2UuZXF1YWwobGFzdE1hdGNoLm91dGVyUmFuZ2UpIFxuXHRcdFx0XHRcdFx0JiYgbGFzdE1hdGNoLnJhbmdlLmVxdWFsKGxhc3RNYXRjaC5pbm5lclJhbmdlKSBcblx0XHRcdFx0XHRcdCYmIHNlbC5lcXVhbChsYXN0TWF0Y2gucmFuZ2UpKSB7XG5cdFx0XHRcdFx0bGFzdE1hdGNoLnJhbmdlID0gbGFzdE1hdGNoLm91dGVyUmFuZ2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGFzdE1hdGNoID0gbWF0Y2hlci5maW5kKGNvbnRlbnQsIHNlbC5zdGFydCk7XG5cdFx0XHRcdFx0aWYgKGxhc3RNYXRjaCAmJiBsYXN0TWF0Y2gucmFuZ2UuZXF1YWwoc2VsKSAmJiBsYXN0TWF0Y2guaW5uZXJSYW5nZS5lcXVhbChzZWwpKSB7XG5cdFx0XHRcdFx0XHRsYXN0TWF0Y2gucmFuZ2UgPSBsYXN0TWF0Y2gub3V0ZXJSYW5nZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGFzdE1hdGNoID0gbWF0Y2hlci5maW5kKGNvbnRlbnQsIHNlbC5zdGFydCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChsYXN0TWF0Y2ggJiYgIWxhc3RNYXRjaC5yYW5nZS5lcXVhbChzZWwpKSB7XG5cdFx0XHRlZGl0b3IuY3JlYXRlU2VsZWN0aW9uKGxhc3RNYXRjaC5yYW5nZS5zdGFydCwgbGFzdE1hdGNoLnJhbmdlLmVuZCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0bGFzdE1hdGNoID0gbnVsbDtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdGFjdGlvbnMuYWRkKCdtYXRjaF9wYWlyJywgbWF0Y2hQYWlyLCB7aGlkZGVuOiB0cnVlfSk7XG5cdGFjdGlvbnMuYWRkKCdtYXRjaF9wYWlyX2lud2FyZCcsIGZ1bmN0aW9uKGVkaXRvcil7XG5cdFx0cmV0dXJuIG1hdGNoUGFpcihlZGl0b3IsICdpbicpO1xuXHR9LCB7bGFiZWw6ICdIVE1ML01hdGNoIFBhaXIgVGFnIChpbndhcmQpJ30pO1xuXG5cdGFjdGlvbnMuYWRkKCdtYXRjaF9wYWlyX291dHdhcmQnLCBmdW5jdGlvbihlZGl0b3Ipe1xuXHRcdHJldHVybiBtYXRjaFBhaXIoZWRpdG9yLCAnb3V0Jyk7XG5cdH0sIHtsYWJlbDogJ0hUTUwvTWF0Y2ggUGFpciBUYWcgKG91dHdhcmQpJ30pO1xuXHRcblx0LyoqXG5cdCAqIE1vdmVzIGNhcmV0IHRvIG1hdGNoaW5nIG9wZW5pbmcgb3IgY2xvc2luZyB0YWdcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHQgKi9cblx0YWN0aW9ucy5hZGQoJ21hdGNoaW5nX3BhaXInLCBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHR2YXIgY29udGVudCA9IFN0cmluZyhlZGl0b3IuZ2V0Q29udGVudCgpKTtcblx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHRcblx0XHRpZiAoY29udGVudC5jaGFyQXQoY2FyZXRQb3MpID09ICc8JykgXG5cdFx0XHQvLyBsb29rcyBsaWtlIGNhcmV0IGlzIG91dHNpZGUgb2YgdGFnIHBhaXIgIFxuXHRcdFx0Y2FyZXRQb3MrKztcblx0XHRcdFxuXHRcdHZhciB0YWcgPSBtYXRjaGVyLnRhZyhjb250ZW50LCBjYXJldFBvcyk7XG5cdFx0aWYgKHRhZyAmJiB0YWcuY2xvc2UpIHsgLy8gZXhjbHVkZSB1bmFyeSB0YWdzXG5cdFx0XHRpZiAodGFnLm9wZW4ucmFuZ2UuaW5zaWRlKGNhcmV0UG9zKSkge1xuXHRcdFx0XHRlZGl0b3Iuc2V0Q2FyZXRQb3ModGFnLmNsb3NlLnJhbmdlLnN0YXJ0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVkaXRvci5zZXRDYXJldFBvcyh0YWcub3Blbi5yYW5nZS5zdGFydCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sIHtsYWJlbDogJ0hUTUwvR28gVG8gTWF0Y2hpbmcgVGFnIFBhaXInfSk7XG59KTsvKipcbiAqIEdyYWNlZnVsbHkgcmVtb3ZlcyB0YWcgdW5kZXIgY3Vyc29yXG4gKiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gXyBcbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHJlcXVpcmUoJ2FjdGlvbnMnKS5hZGQoJ3JlbW92ZV90YWcnLCBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdHZhciBpbmZvID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0XG5cdFx0Ly8gc2VhcmNoIGZvciB0YWdcblx0XHR2YXIgdGFnID0gcmVxdWlyZSgnaHRtbE1hdGNoZXInKS50YWcoaW5mby5jb250ZW50LCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0aWYgKHRhZykge1xuXHRcdFx0aWYgKCF0YWcuY2xvc2UpIHtcblx0XHRcdFx0Ly8gc2ltcGx5IHJlbW92ZSB1bmFyeSB0YWdcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KHV0aWxzLmdldENhcmV0UGxhY2Vob2xkZXIoKSwgdGFnLnJhbmdlLnN0YXJ0LCB0YWcucmFuZ2UuZW5kKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlbW92ZSB0YWcgYW5kIGl0cyBuZXdsaW5lc1xuXHRcdFx0XHQvKiogQHR5cGUgUmFuZ2UgKi9cblx0XHRcdFx0dmFyIHRhZ0NvbnRlbnRSYW5nZSA9IHV0aWxzLm5hcnJvd1RvTm9uU3BhY2UoaW5mby5jb250ZW50LCB0YWcuaW5uZXJSYW5nZSk7XG5cdFx0XHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdFx0XHR2YXIgc3RhcnRMaW5lQm91bmRzID0gdXRpbHMuZmluZE5ld2xpbmVCb3VuZHMoaW5mby5jb250ZW50LCB0YWdDb250ZW50UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0XHR2YXIgc3RhcnRMaW5lUGFkID0gdXRpbHMuZ2V0TGluZVBhZGRpbmcoc3RhcnRMaW5lQm91bmRzLnN1YnN0cmluZyhpbmZvLmNvbnRlbnQpKTtcblx0XHRcdFx0dmFyIHRhZ0NvbnRlbnQgPSB0YWdDb250ZW50UmFuZ2Uuc3Vic3RyaW5nKGluZm8uY29udGVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR0YWdDb250ZW50ID0gdXRpbHMudW5pbmRlbnRTdHJpbmcodGFnQ29udGVudCwgc3RhcnRMaW5lUGFkKTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KHV0aWxzLmdldENhcmV0UGxhY2Vob2xkZXIoKSArIHV0aWxzLmVzY2FwZVRleHQodGFnQ29udGVudCksIHRhZy5vdXRlclJhbmdlLnN0YXJ0LCB0YWcub3V0ZXJSYW5nZS5lbmQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LCB7bGFiZWw6ICdIVE1ML1JlbW92ZSBUYWcnfSk7XG59KTtcbi8qKlxuICogU3BsaXRzIG9yIGpvaW5zIHRhZywgZS5nLiB0cmFuc2Zvcm1zIGl0IGludG8gYSBzaG9ydCBub3RhdGlvbiBhbmQgdmljZSB2ZXJzYTo8YnI+XG4gKiAmbHQ7ZGl2Jmd0OyZsdDsvZGl2Jmd0OyDihpIgJmx0O2RpdiAvJmd0OyA6IGpvaW48YnI+XG4gKiAmbHQ7ZGl2IC8mZ3Q7IOKGkiAmbHQ7ZGl2Jmd0OyZsdDsvZGl2Jmd0OyA6IHNwbGl0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqIEBtZW1iZXJPZiBfX3NwbGl0Sm9pblRhZ0FjdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmVtbWV0LmV4ZWMoZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHQvKipcblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFnXG5cdCAqL1xuXHRmdW5jdGlvbiBqb2luVGFnKGVkaXRvciwgcHJvZmlsZSwgdGFnKSB7XG5cdFx0LyoqIEB0eXBlIGVtbWV0LnV0aWxzICovXG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcblx0XHQvLyBlbXB0eSBjbG9zaW5nIHNsYXNoIGlzIGEgbm9uc2Vuc2UgZm9yIHRoaXMgYWN0aW9uXG5cdFx0dmFyIHNsYXNoID0gcHJvZmlsZS5zZWxmQ2xvc2luZygpIHx8ICcgLyc7XG5cdFx0dmFyIGNvbnRlbnQgPSB0YWcub3Blbi5yYW5nZS5zdWJzdHJpbmcodGFnLnNvdXJjZSkucmVwbGFjZSgvXFxzKj4kLywgc2xhc2ggKyAnPicpO1xuXHRcdFxuXHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFxuXHRcdC8vIHVwZGF0ZSBjYXJldCBwb3NpdGlvblxuXHRcdGlmIChjb250ZW50Lmxlbmd0aCArIHRhZy5vdXRlclJhbmdlLnN0YXJ0IDwgY2FyZXRQb3MpIHtcblx0XHRcdGNhcmV0UG9zID0gY29udGVudC5sZW5ndGggKyB0YWcub3V0ZXJSYW5nZS5zdGFydDtcblx0XHR9XG5cdFx0XG5cdFx0Y29udGVudCA9IHV0aWxzLmVzY2FwZVRleHQoY29udGVudCk7XG5cdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGNvbnRlbnQsIHRhZy5vdXRlclJhbmdlLnN0YXJ0LCB0YWcub3V0ZXJSYW5nZS5lbmQpO1xuXHRcdGVkaXRvci5zZXRDYXJldFBvcyhjYXJldFBvcyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNwbGl0VGFnKGVkaXRvciwgcHJvZmlsZSwgdGFnKSB7XG5cdFx0LyoqIEB0eXBlIGVtbWV0LnV0aWxzICovXG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcblx0XHR2YXIgbmwgPSB1dGlscy5nZXROZXdsaW5lKCk7XG5cdFx0dmFyIHBhZCA9IHJlcXVpcmUoJ3Jlc291cmNlcycpLmdldFZhcmlhYmxlKCdpbmRlbnRhdGlvbicpO1xuXHRcdHZhciBjYXJldFBvcyA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFxuXHRcdC8vIGRlZmluZSB0YWcgY29udGVudCBkZXBlbmRpbmcgb24gcHJvZmlsZVxuXHRcdHZhciB0YWdDb250ZW50ID0gKHByb2ZpbGUudGFnX25sID09PSB0cnVlKSA/IG5sICsgcGFkICsgbmwgOiAnJztcblx0XHR2YXIgY29udGVudCA9IHRhZy5vdXRlckNvbnRlbnQoKS5yZXBsYWNlKC9cXHMqXFwvPiQvLCAnPicpO1xuXHRcdGNhcmV0UG9zID0gdGFnLm91dGVyUmFuZ2Uuc3RhcnQgKyBjb250ZW50Lmxlbmd0aDtcblx0XHRjb250ZW50ICs9IHRhZ0NvbnRlbnQgKyAnPC8nICsgdGFnLm9wZW4ubmFtZSArICc+Jztcblx0XHRcblx0XHRjb250ZW50ID0gdXRpbHMuZXNjYXBlVGV4dChjb250ZW50KTtcblx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQoY29udGVudCwgdGFnLm91dGVyUmFuZ2Uuc3RhcnQsIHRhZy5vdXRlclJhbmdlLmVuZCk7XG5cdFx0ZWRpdG9yLnNldENhcmV0UG9zKGNhcmV0UG9zKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0cmVxdWlyZSgnYWN0aW9ucycpLmFkZCgnc3BsaXRfam9pbl90YWcnLCBmdW5jdGlvbihlZGl0b3IsIHByb2ZpbGVOYW1lKSB7XG5cdFx0dmFyIG1hdGNoZXIgPSByZXF1aXJlKCdodG1sTWF0Y2hlcicpO1xuXHRcdFxuXHRcdHZhciBpbmZvID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5vdXRwdXRJbmZvKGVkaXRvciwgbnVsbCwgcHJvZmlsZU5hbWUpO1xuXHRcdHZhciBwcm9maWxlID0gcmVxdWlyZSgncHJvZmlsZScpLmdldChpbmZvLnByb2ZpbGUpO1xuXHRcdFxuXHRcdC8vIGZpbmQgdGFnIGF0IGN1cnJlbnQgcG9zaXRpb25cblx0XHR2YXIgdGFnID0gbWF0Y2hlci50YWcoaW5mby5jb250ZW50LCBlZGl0b3IuZ2V0Q2FyZXRQb3MoKSk7XG5cdFx0aWYgKHRhZykge1xuXHRcdFx0cmV0dXJuIHRhZy5jbG9zZSBcblx0XHRcdFx0PyBqb2luVGFnKGVkaXRvciwgcHJvZmlsZSwgdGFnKSBcblx0XHRcdFx0OiBzcGxpdFRhZyhlZGl0b3IsIHByb2ZpbGUsIHRhZyk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fSwge2xhYmVsOiAnSFRNTC9TcGxpdFxcXFxKb2luIFRhZyBEZWNsYXJhdGlvbid9KTtcbn0pOy8qKlxuICogUmVmbGVjdCBDU1MgdmFsdWU6IHRha2VzIHJ1bGUncyB2YWx1ZSB1bmRlciBjYXJldCBhbmQgcGFzdGVzIGl0IGZvciB0aGUgc2FtZSBcbiAqIHJ1bGVzIHdpdGggdmVuZG9yIHByZWZpeGVzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX3JlZmxlY3RDU1NBY3Rpb25EZWZpbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5kZWZpbmUoJ3JlZmxlY3RDU1NWYWx1ZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0LyoqXG5cdCAqIEB0eXBlIEhhbmRsZXJMaXN0IExpc3Qgb2YgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuXHQgKi9cblx0dmFyIGhhbmRsZXJzID0gcmVxdWlyZSgnaGFuZGxlckxpc3QnKS5jcmVhdGUoKTtcblx0XG5cdHJlcXVpcmUoJ2FjdGlvbnMnKS5hZGQoJ3JlZmxlY3RfY3NzX3ZhbHVlJywgZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0aWYgKGVkaXRvci5nZXRTeW50YXgoKSAhPSAnY3NzJykgcmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdHJldHVybiByZXF1aXJlKCdhY3Rpb25VdGlscycpLmNvbXBvdW5kVXBkYXRlKGVkaXRvciwgZG9DU1NSZWZsZWN0aW9uKGVkaXRvcikpO1xuXHR9LCB7bGFiZWw6ICdDU1MvUmVmbGVjdCBWYWx1ZSd9KTtcblx0XG5cdGZ1bmN0aW9uIGRvQ1NTUmVmbGVjdGlvbihlZGl0b3IpIHtcblx0XHQvKiogQHR5cGUgZW1tZXQuY3NzRWRpdFRyZWUgKi9cblx0XHR2YXIgY3NzRWRpdFRyZWUgPSByZXF1aXJlKCdjc3NFZGl0VHJlZScpO1xuXHRcdHZhciBvdXRwdXRJbmZvID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0XG5cdFx0dmFyIGNzc1J1bGUgPSBjc3NFZGl0VHJlZS5wYXJzZUZyb21Qb3NpdGlvbihvdXRwdXRJbmZvLmNvbnRlbnQsIGNhcmV0UG9zKTtcblx0XHRpZiAoIWNzc1J1bGUpIHJldHVybjtcblx0XHRcblx0XHR2YXIgcHJvcGVydHkgPSBjc3NSdWxlLml0ZW1Gcm9tUG9zaXRpb24oY2FyZXRQb3MsIHRydWUpO1xuXHRcdC8vIG5vIHByb3BlcnR5IHVuZGVyIGN1cnNvciwgbm90aGluZyB0byByZWZsZWN0XG5cdFx0aWYgKCFwcm9wZXJ0eSkgcmV0dXJuO1xuXHRcdFxuXHRcdHZhciBvbGRSdWxlID0gY3NzUnVsZS5zb3VyY2U7XG5cdFx0dmFyIG9mZnNldCA9IGNzc1J1bGUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0dmFyIGNhcmV0RGVsdGEgPSBjYXJldFBvcyAtIG9mZnNldCAtIHByb3BlcnR5LnJhbmdlKCkuc3RhcnQ7XG5cdFx0XG5cdFx0aGFuZGxlcnMuZXhlYyhmYWxzZSwgW3Byb3BlcnR5XSk7XG5cdFx0XG5cdFx0aWYgKG9sZFJ1bGUgIT09IGNzc1J1bGUuc291cmNlKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiAgY3NzUnVsZS5zb3VyY2UsXG5cdFx0XHRcdHN0YXJ0OiBvZmZzZXQsXG5cdFx0XHRcdGVuZDogICBvZmZzZXQgKyBvbGRSdWxlLmxlbmd0aCxcblx0XHRcdFx0Y2FyZXQ6IG9mZnNldCArIHByb3BlcnR5LnJhbmdlKCkuc3RhcnQgKyBjYXJldERlbHRhXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgcmVnZXhwIHRoYXQgc2hvdWxkIG1hdGNoIHJlZmxlY3RlZCBDU1MgcHJvcGVydHkgbmFtZXNcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQ3VycmVudCBDU1MgcHJvcGVydHkgbmFtZVxuXHQgKiBAcmV0dXJuIHtSZWdFeHB9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSZWZsZWN0ZWRDU1NOYW1lKG5hbWUpIHtcblx0XHRuYW1lID0gcmVxdWlyZSgnY3NzRWRpdFRyZWUnKS5iYXNlTmFtZShuYW1lKTtcblx0XHR2YXIgdmVuZG9yUHJlZml4ID0gJ14oPzpcXFxcLVxcXFx3K1xcXFwtKT8nLCBtO1xuXHRcdFxuXHRcdGlmIChuYW1lID09ICdvcGFjaXR5JyB8fCBuYW1lID09ICdmaWx0ZXInKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cCh2ZW5kb3JQcmVmaXggKyAnKD86b3BhY2l0eXxmaWx0ZXIpJCcpO1xuXHRcdH0gZWxzZSBpZiAobSA9IG5hbWUubWF0Y2goL15ib3JkZXItcmFkaXVzLSh0b3B8Ym90dG9tKShsZWZ0fHJpZ2h0KS8pKSB7XG5cdFx0XHQvLyBNb3ppbGxhLXN0eWxlIGJvcmRlciByYWRpdXNcblx0XHRcdHJldHVybiBuZXcgUmVnRXhwKHZlbmRvclByZWZpeCArICcoPzonICsgbmFtZSArICd8Ym9yZGVyLScgKyBtWzFdICsgJy0nICsgbVsyXSArICctcmFkaXVzKSQnKTtcblx0XHR9IGVsc2UgaWYgKG0gPSBuYW1lLm1hdGNoKC9eYm9yZGVyLSh0b3B8Ym90dG9tKS0obGVmdHxyaWdodCktcmFkaXVzLykpIHsgXG5cdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cCh2ZW5kb3JQcmVmaXggKyAnKD86JyArIG5hbWUgKyAnfGJvcmRlci1yYWRpdXMtJyArIG1bMV0gKyBtWzJdICsgJykkJyk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBuZXcgUmVnRXhwKHZlbmRvclByZWZpeCArIG5hbWUgKyAnJCcpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmVmbGVjdHMgdmFsdWUgZnJvbSA8Y29kZT5kb25vcjwvY29kZT4gaW50byA8Y29kZT5yZWNlaXZlcjwvY29kZT5cblx0ICogQHBhcmFtIHtDU1NQcm9wZXJ0eX0gZG9ub3IgRG9ub3IgQ1NTIHByb3BlcnR5IGZyb20gd2hpY2ggdmFsdWUgc2hvdWxkXG5cdCAqIGJlIHJlZmxlY3RlZFxuXHQgKiBAcGFyYW0ge0NTU1Byb3BlcnR5fSByZWNlaXZlciBQcm9wZXJ0eSB0aGF0IHNob3VsZCByZWNlaXZlIHJlZmxlY3RlZCBcblx0ICogdmFsdWUgZnJvbSBkb25vclxuXHQgKi9cblx0ZnVuY3Rpb24gcmVmbGVjdFZhbHVlKGRvbm9yLCByZWNlaXZlcikge1xuXHRcdHZhciB2YWx1ZSA9IGdldFJlZmxlY3RlZFZhbHVlKGRvbm9yLm5hbWUoKSwgZG9ub3IudmFsdWUoKSwgXG5cdFx0XHRcdHJlY2VpdmVyLm5hbWUoKSwgcmVjZWl2ZXIudmFsdWUoKSk7XG5cdFx0XG5cdFx0cmVjZWl2ZXIudmFsdWUodmFsdWUpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgZm9yIDxjb2RlPnJlZk5hbWU8L2NvZGU+IENTUyBwcm9wZXJ0eVxuXHQgKiBmcm9tIDxjb2RlPmN1ck5hbWU8L2NvZGU+IHByb3BlcnR5LiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHNwZWNpYWwgY2FzZXMsXG5cdCAqIHdoZW4gdGhlIHNhbWUgcmVzdWx0IG11c3QgYmUgYWNoaWV2ZWQgd2l0aCBkaWZmZXJlbnQgcHJvcGVydGllcyBmb3IgZGlmZmVyZW50XG5cdCAqIGJyb3dzZXJzLiBGb3IgZXhhbXBsZTogb3DQsGNpdHk6MC41OyDihpIgZmlsdGVyOmFscGhhKG9wYWNpdHk9NTApOzxicj48YnI+XG5cdCAqIFxuXHQgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgdmFsdWUgY29udmVyc2lvbiBiZXR3ZWVuIGRpZmZlcmVudCBDU1MgcHJvcGVydGllc1xuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGN1ck5hbWUgQ3VycmVudCBDU1MgcHJvcGVydHkgbmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3VyVmFsdWUgQ3VycmVudCBDU1MgcHJvcGVydHkgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlZk5hbWUgUmVjZWl2ZXIgQ1NTIHByb3BlcnR5J3MgbmFtZSBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlZlZhbHVlIFJlY2VpdmVyIENTUyBwcm9wZXJ0eSdzIHZhbHVlXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gTmV3IHZhbHVlIGZvciByZWNlaXZlciBwcm9wZXJ0eVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmVmbGVjdGVkVmFsdWUoY3VyTmFtZSwgY3VyVmFsdWUsIHJlZk5hbWUsIHJlZlZhbHVlKSB7XG5cdFx0dmFyIGNzc0VkaXRUcmVlID0gcmVxdWlyZSgnY3NzRWRpdFRyZWUnKTtcblx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdGN1ck5hbWUgPSBjc3NFZGl0VHJlZS5iYXNlTmFtZShjdXJOYW1lKTtcblx0XHRyZWZOYW1lID0gY3NzRWRpdFRyZWUuYmFzZU5hbWUocmVmTmFtZSk7XG5cdFx0XG5cdFx0aWYgKGN1ck5hbWUgPT0gJ29wYWNpdHknICYmIHJlZk5hbWUgPT0gJ2ZpbHRlcicpIHtcblx0XHRcdHJldHVybiByZWZWYWx1ZS5yZXBsYWNlKC9vcGFjaXR5PVteKV0qL2ksICdvcGFjaXR5PScgKyBNYXRoLmZsb29yKHBhcnNlRmxvYXQoY3VyVmFsdWUpICogMTAwKSk7XG5cdFx0fSBlbHNlIGlmIChjdXJOYW1lID09ICdmaWx0ZXInICYmIHJlZk5hbWUgPT0gJ29wYWNpdHknKSB7XG5cdFx0XHR2YXIgbSA9IGN1clZhbHVlLm1hdGNoKC9vcGFjaXR5PShbXildKikvaSk7XG5cdFx0XHRyZXR1cm4gbSA/IHV0aWxzLnByZXR0aWZ5TnVtYmVyKHBhcnNlSW50KG1bMV0pIC8gMTAwKSA6IHJlZlZhbHVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY3VyVmFsdWU7XG5cdH1cblx0XG5cdC8vIFhYWCBhZGQgZGVmYXVsdCBoYW5kbGVyXG5cdGhhbmRsZXJzLmFkZChmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdHZhciByZU5hbWUgPSBnZXRSZWZsZWN0ZWRDU1NOYW1lKHByb3BlcnR5Lm5hbWUoKSk7XG5cdFx0Xy5lYWNoKHByb3BlcnR5LnBhcmVudC5saXN0KCksIGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmIChyZU5hbWUudGVzdChwLm5hbWUoKSkpIHtcblx0XHRcdFx0cmVmbGVjdFZhbHVlKHByb3BlcnR5LCBwKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSwge29yZGVyOiAtMX0pO1xuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBBZGRzIGN1c3RvbSByZWZsZWN0IGhhbmRsZXIuIFRoZSBwYXNzZWQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG1hdGNoZWRcblx0XHQgKiBDU1MgcHJvcGVydHkgKGFzIDxjb2RlPkNTU0VkaXRFbGVtZW50PC9jb2RlPiBvYmplY3QpIGFuZCBzaG91bGRcblx0XHQgKiByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgaXQgd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHkgKGhhbmRsZWQgXG5cdFx0ICogcmVmbGVjdGlvbiksIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdGFkZEhhbmRsZXI6IGZ1bmN0aW9uKGZuLCBvcHRpb25zKSB7XG5cdFx0XHRoYW5kbGVycy5hZGQoZm4sIG9wdGlvbnMpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyByZWdpc3RlcmVkIGhhbmRsZXJcblx0XHQgKiBAcmV0dXJuc1xuXHRcdCAqL1xuXHRcdHJlbW92ZUhhbmRsZXI6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRoYW5kbGVycy5yZW1vdmUoZm4sIG9wdGlvbnMpO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogRXZhbHVhdGVzIHNpbXBsZSBtYXRoIGV4cHJlc3Npb24gdW5kZXIgY2FyZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gXyBcbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHJlcXVpcmUoJ2FjdGlvbnMnKS5hZGQoJ2V2YWx1YXRlX21hdGhfZXhwcmVzc2lvbicsIGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdHZhciBhY3Rpb25VdGlscyA9IHJlcXVpcmUoJ2FjdGlvblV0aWxzJyk7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcblx0XHR2YXIgY29udGVudCA9IFN0cmluZyhlZGl0b3IuZ2V0Q29udGVudCgpKTtcblx0XHR2YXIgY2hhcnMgPSAnListKi9cXFxcJztcblx0XHRcblx0XHQvKiogQHR5cGUgUmFuZ2UgKi9cblx0XHR2YXIgc2VsID0gcmVxdWlyZSgncmFuZ2UnKS5jcmVhdGUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuXHRcdGlmICghc2VsLmxlbmd0aCgpKSB7XG5cdFx0XHRzZWwgPSBhY3Rpb25VdGlscy5maW5kRXhwcmVzc2lvbkJvdW5kcyhlZGl0b3IsIGZ1bmN0aW9uKGNoKSB7XG5cdFx0XHRcdHJldHVybiB1dGlscy5pc051bWVyaWMoY2gpIHx8IGNoYXJzLmluZGV4T2YoY2gpICE9IC0xO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChzZWwgJiYgc2VsLmxlbmd0aCgpKSB7XG5cdFx0XHR2YXIgZXhwciA9IHNlbC5zdWJzdHJpbmcoY29udGVudCk7XG5cdFx0XHRcblx0XHRcdC8vIHJlcGxhY2UgaW50ZWdyYWwgZGl2aXNpb246IDExXFwyID0+IE1hdGgucm91bmQoMTEvMikgXG5cdFx0XHRleHByID0gZXhwci5yZXBsYWNlKC8oW1xcZFxcLlxcLV0rKVxcXFwoW1xcZFxcLlxcLV0rKS9nLCAnTWF0aC5yb3VuZCgkMS8kMiknKTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHV0aWxzLnByZXR0aWZ5TnVtYmVyKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBleHByKSgpKTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KHJlc3VsdCwgc2VsLnN0YXJ0LCBzZWwuZW5kKTtcblx0XHRcdFx0ZWRpdG9yLnNldENhcmV0UG9zKHNlbC5zdGFydCArIHJlc3VsdC5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fSwge2xhYmVsOiAnTnVtYmVycy9FdmFsdWF0ZSBNYXRoIEV4cHJlc3Npb24nfSk7XG59KTtcbi8qKlxuICogSW5jcmVtZW50L2RlY3JlbWVudCBudW1iZXIgdW5kZXIgY3Vyc29yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBFeHRyYWN0IG51bWJlciBmcm9tIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gb2YgdGhlIDxjb2RlPmVkaXRvcjwvY29kZT4gYW5kXG5cdCAqIGluY3JlbWVudCBpdCBieSA8Y29kZT5zdGVwPC9jb2RlPlxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwIEluY3JlbWVudCBzdGVwIChtYXkgYmUgbmVnYXRpdmUpXG5cdCAqL1xuXHRmdW5jdGlvbiBpbmNyZW1lbnROdW1iZXIoZWRpdG9yLCBzdGVwKSB7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHR2YXIgYWN0aW9uVXRpbHMgPSByZXF1aXJlKCdhY3Rpb25VdGlscycpO1xuXHRcdFxuXHRcdHZhciBoYXNTaWduID0gZmFsc2U7XG5cdFx0dmFyIGhhc0RlY2ltYWwgPSBmYWxzZTtcblx0XHRcdFxuXHRcdHZhciByID0gYWN0aW9uVXRpbHMuZmluZEV4cHJlc3Npb25Cb3VuZHMoZWRpdG9yLCBmdW5jdGlvbihjaCwgcG9zLCBjb250ZW50KSB7XG5cdFx0XHRpZiAodXRpbHMuaXNOdW1lcmljKGNoKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRpZiAoY2ggPT0gJy4nKSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IG5leHQgY2hhcmFjdGVyIGlzIG51bWVyaWMgdG9vXG5cdFx0XHRcdGlmICghdXRpbHMuaXNOdW1lcmljKGNvbnRlbnQuY2hhckF0KHBvcyArIDEpKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gaGFzRGVjaW1hbCA/IGZhbHNlIDogaGFzRGVjaW1hbCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2ggPT0gJy0nKVxuXHRcdFx0XHRyZXR1cm4gaGFzU2lnbiA/IGZhbHNlIDogaGFzU2lnbiA9IHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0pO1xuXHRcdFx0XG5cdFx0aWYgKHIgJiYgci5sZW5ndGgoKSkge1xuXHRcdFx0dmFyIHN0ck51bSA9IHIuc3Vic3RyaW5nKFN0cmluZyhlZGl0b3IuZ2V0Q29udGVudCgpKSk7XG5cdFx0XHR2YXIgbnVtID0gcGFyc2VGbG9hdChzdHJOdW0pO1xuXHRcdFx0aWYgKCFfLmlzTmFOKG51bSkpIHtcblx0XHRcdFx0bnVtID0gdXRpbHMucHJldHRpZnlOdW1iZXIobnVtICsgc3RlcCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkbyB3ZSBoYXZlIHplcm8tcGFkZGVkIG51bWJlcj9cblx0XHRcdFx0aWYgKC9eKFxcLT8pMCtbMS05XS8udGVzdChzdHJOdW0pKSB7XG5cdFx0XHRcdFx0dmFyIG1pbnVzID0gJyc7XG5cdFx0XHRcdFx0aWYgKFJlZ0V4cC4kMSkge1xuXHRcdFx0XHRcdFx0bWludXMgPSAnLSc7XG5cdFx0XHRcdFx0XHRudW0gPSBudW0uc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IG51bS5zcGxpdCgnLicpO1xuXHRcdFx0XHRcdHBhcnRzWzBdID0gdXRpbHMuemVyb1BhZFN0cmluZyhwYXJ0c1swXSwgaW50TGVuZ3RoKHN0ck51bSkpO1xuXHRcdFx0XHRcdG51bSA9IG1pbnVzICsgcGFydHMuam9pbignLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZUNvbnRlbnQobnVtLCByLnN0YXJ0LCByLmVuZCk7XG5cdFx0XHRcdGVkaXRvci5jcmVhdGVTZWxlY3Rpb24oci5zdGFydCwgci5zdGFydCArIG51bS5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBsZW5ndGggb2YgaW50ZWdlciBwYXJ0IG9mIG51bWJlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbnVtXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnRMZW5ndGgobnVtKSB7XG5cdFx0bnVtID0gbnVtLnJlcGxhY2UoL15cXC0vLCAnJyk7XG5cdFx0aWYgKH5udW0uaW5kZXhPZignLicpKSB7XG5cdFx0XHRyZXR1cm4gbnVtLnNwbGl0KCcuJylbMF0ubGVuZ3RoO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVtLmxlbmd0aDtcblx0fVxuXHRcblx0dmFyIGFjdGlvbnMgPSByZXF1aXJlKCdhY3Rpb25zJyk7XG5cdF8uZWFjaChbMSwgLTEsIDEwLCAtMTAsIDAuMSwgLTAuMV0sIGZ1bmN0aW9uKG51bSkge1xuXHRcdHZhciBwcmVmaXggPSBudW0gPiAwID8gJ2luY3JlbWVudCcgOiAnZGVjcmVtZW50Jztcblx0XHRcblx0XHRhY3Rpb25zLmFkZChwcmVmaXggKyAnX251bWJlcl9ieV8nICsgU3RyaW5nKE1hdGguYWJzKG51bSkpLnJlcGxhY2UoJy4nLCAnJykuc3Vic3RyaW5nKDAsIDIpLCBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdHJldHVybiBpbmNyZW1lbnROdW1iZXIoZWRpdG9yLCBudW0pO1xuXHRcdH0sIHtsYWJlbDogJ051bWJlcnMvJyArIHByZWZpeC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByZWZpeC5zdWJzdHJpbmcoMSkgKyAnIG51bWJlciBieSAnICsgTWF0aC5hYnMobnVtKX0pO1xuXHR9KTtcbn0pOy8qKlxuICogQWN0aW9ucyB0byBpbnNlcnQgbGluZSBicmVha3MuIFNvbWUgc2ltcGxlIGVkaXRvcnMgKGxpa2UgYnJvd3NlcidzIFxuICogJmx0O3RleHRhcmVhJmd0OywgZm9yIGV4YW1wbGUpIGRvIG5vdCBwcm92aWRlIHN1Y2ggc2ltcGxlIHRoaW5nc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmV4ZWMoZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHR2YXIgYWN0aW9ucyA9IHJlcXVpcmUoJ2FjdGlvbnMnKTtcblx0LyoqIEB0eXBlIGVtbWV0LnByZWZlcmVuY2VzICovXG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJ3ByZWZlcmVuY2VzJyk7XG5cdFxuXHQvLyBzZXR1cCBkZWZhdWx0IHByZWZlcmVuY2VzXG5cdHByZWZzLmRlZmluZSgnY3NzLmNsb3NlQnJhY2VJbmRlbnRhdGlvbicsICdcXG4nLFxuXHRcdFx0J0luZGVudGF0aW9uIGJlZm9yZSBjbG9zaW5nIGJyYWNlIG9mIENTUyBydWxlLiBTb21lIHVzZXJzIHByZWZlcmUgJyBcblx0XHRcdCsgJ2luZGVudGVkIGNsb3NpbmcgYnJhY2Ugb2YgQ1NTIHJ1bGUgZm9yIGJldHRlciByZWFkYWJpbGl0eS4gJ1xuXHRcdFx0KyAnVGhpcyBwcmVmZXJlbmNl4oCZcyB2YWx1ZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgYmVmb3JlICdcblx0XHRcdCsgJ2Nsb3NpbmcgYnJhY2Ugd2hlbiB1c2VyIGFkZHMgbmV3bGluZSBpbiBuZXdseSBjcmVhdGVkIENTUyBydWxlICdcblx0XHRcdCsgJyhlLmcuIHdoZW4g4oCcSW5zZXJ0IGZvcm1hdHRlZCBsaW5lYnJlYWvigJ0gYWN0aW9uIHdpbGwgYmUgcGVyZm9ybWVkICcgXG5cdFx0XHQrICdpbiBDU1MgZmlsZSkuIElmIHlvdeKAmXJlIHN1Y2ggdXNlciwgeW91IG1heSB3YW50IHRvIHdyaXRlIHB1dCBhIHZhbHVlICcgXG5cdFx0XHQrICdsaWtlIDxjb2RlPlxcXFxuXFxcXHQ8L2NvZGU+IGluIHRoaXMgcHJlZmVyZW5jZS4nKTtcblx0XG5cdC8qKlxuXHQgKiBJbnNlcnRzIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggcHJvcGVyIGluZGVudGF0aW9uIGluIHNwZWNpZmljIHBvc2l0aW9ucyBvbmx5LlxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGluZSBicmVhayB3YXMgaW5zZXJ0ZWQgXG5cdCAqL1xuXHRhY3Rpb25zLmFkZCgnaW5zZXJ0X2Zvcm1hdHRlZF9saW5lX2JyZWFrX29ubHknLCBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdC8qKiBAdHlwZSBlbW1ldC5yZXNvdXJjZXMgKi9cblx0XHR2YXIgcmVzID0gcmVxdWlyZSgncmVzb3VyY2VzJyk7XG5cdFx0XG5cdFx0dmFyIGluZm8gPSByZXF1aXJlKCdlZGl0b3JVdGlscycpLm91dHB1dEluZm8oZWRpdG9yKTtcblx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0Q2FyZXRQb3MoKTtcblx0XHR2YXIgbmwgPSB1dGlscy5nZXROZXdsaW5lKCk7XG5cdFx0XG5cdFx0aWYgKF8uaW5jbHVkZShbJ2h0bWwnLCAneG1sJywgJ3hzbCddLCBpbmZvLnN5bnRheCkpIHtcblx0XHRcdHZhciBwYWQgPSByZXMuZ2V0VmFyaWFibGUoJ2luZGVudGF0aW9uJyk7XG5cdFx0XHQvLyBsZXQncyBzZWUgaWYgd2UncmUgYnJlYWtpbmcgbmV3bHkgY3JlYXRlZCB0YWdcblx0XHRcdHZhciB0YWcgPSByZXF1aXJlKCdodG1sTWF0Y2hlcicpLnRhZyhpbmZvLmNvbnRlbnQsIGNhcmV0UG9zKTtcblx0XHRcdGlmICh0YWcgJiYgIXRhZy5pbm5lclJhbmdlLmxlbmd0aCgpKSB7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChubCArIHBhZCArIHV0aWxzLmdldENhcmV0UGxhY2Vob2xkZXIoKSArIG5sLCBjYXJldFBvcyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaW5mby5zeW50YXggPT0gJ2NzcycpIHtcblx0XHRcdC8qKiBAdHlwZSBTdHJpbmcgKi9cblx0XHRcdHZhciBjb250ZW50ID0gaW5mby5jb250ZW50O1xuXHRcdFx0aWYgKGNhcmV0UG9zICYmIGNvbnRlbnQuY2hhckF0KGNhcmV0UG9zIC0gMSkgPT0gJ3snKSB7XG5cdFx0XHRcdHZhciBhcHBlbmQgPSBwcmVmcy5nZXQoJ2Nzcy5jbG9zZUJyYWNlSW5kZW50YXRpb24nKTtcblx0XHRcdFx0dmFyIHBhZCA9IHJlcy5nZXRWYXJpYWJsZSgnaW5kZW50YXRpb24nKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBoYXNDbG9zZUJyYWNlID0gY29udGVudC5jaGFyQXQoY2FyZXRQb3MpID09ICd9Jztcblx0XHRcdFx0aWYgKCFoYXNDbG9zZUJyYWNlKSB7XG5cdFx0XHRcdFx0Ly8gZG8gd2UgcmVhbGx5IG5lZWQgc3BlY2lhbCBmb3JtYXR0aW5nIGhlcmU/XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhpcyBpcyByZWFsbHkgYSBuZXdseSBjcmVhdGVkIHJ1bGUsXG5cdFx0XHRcdFx0Ly8gbG9vayBhaGVhZCBmb3IgYSBjbG9zaW5nIGJyYWNlXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGNhcmV0UG9zLCBpbCA9IGNvbnRlbnQubGVuZ3RoLCBjaDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNoID0gY29udGVudC5jaGFyQXQoaSk7XG5cdFx0XHRcdFx0XHRpZiAoY2ggPT0gJ3snKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG9rLCB0aGlzIGlzIGEgbmV3IHJ1bGUgd2l0aG91dCBjbG9zaW5nIGJyYWNlXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoY2ggPT0gJ30nKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG5vdCBhIG5ldyBydWxlLCBqdXN0IGFkZCBpbmRlbnRhdGlvblxuXHRcdFx0XHRcdFx0XHRhcHBlbmQgPSAnJztcblx0XHRcdFx0XHRcdFx0aGFzQ2xvc2VCcmFjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFoYXNDbG9zZUJyYWNlKSB7XG5cdFx0XHRcdFx0YXBwZW5kICs9ICd9Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZGVmaW5pbmcgcnVsZSBzZXRcblx0XHRcdFx0dmFyIGluc1ZhbHVlID0gbmwgKyBwYWQgKyB1dGlscy5nZXRDYXJldFBsYWNlaG9sZGVyKCkgKyBhcHBlbmQ7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChpbnNWYWx1ZSwgY2FyZXRQb3MpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sIHtoaWRkZW46IHRydWV9KTtcblx0XG5cdC8qKlxuXHQgKiBJbnNlcnRzIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggcHJvcGVyIGluZGVudGF0aW9uLiBUaGlzIGFjdGlvbiBpcyB1c2VkIGluXG5cdCAqIGVkaXRvcnMgdGhhdCBkb2Vzbid0IGhhdmUgaW5kZW50YXRpb24gY29udHJvbCAobGlrZSB0ZXh0YXJlYSBlbGVtZW50KSB0byBcblx0ICogcHJvdmlkZSBwcm9wZXIgaW5kZW50YXRpb25cblx0ICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvciBFZGl0b3IgaW5zdGFuY2Vcblx0ICovXG5cdGFjdGlvbnMuYWRkKCdpbnNlcnRfZm9ybWF0dGVkX2xpbmVfYnJlYWsnLCBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRpZiAoIWFjdGlvbnMucnVuKCdpbnNlcnRfZm9ybWF0dGVkX2xpbmVfYnJlYWtfb25seScsIGVkaXRvcikpIHtcblx0XHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0XHRcblx0XHRcdHZhciBjdXJQYWRkaW5nID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5nZXRDdXJyZW50TGluZVBhZGRpbmcoZWRpdG9yKTtcblx0XHRcdHZhciBjb250ZW50ID0gU3RyaW5nKGVkaXRvci5nZXRDb250ZW50KCkpO1xuXHRcdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0XHR2YXIgbGVuID0gY29udGVudC5sZW5ndGg7XG5cdFx0XHR2YXIgbmwgPSB1dGlscy5nZXROZXdsaW5lKCk7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgb3V0IG5leHQgbGluZSBwYWRkaW5nXG5cdFx0XHR2YXIgbGluZVJhbmdlID0gZWRpdG9yLmdldEN1cnJlbnRMaW5lUmFuZ2UoKTtcblx0XHRcdHZhciBuZXh0UGFkZGluZyA9ICcnO1xuXHRcdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSBsaW5lUmFuZ2UuZW5kICsgMSwgY2g7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRjaCA9IGNvbnRlbnQuY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAoY2ggPT0gJyAnIHx8IGNoID09ICdcXHQnKVxuXHRcdFx0XHRcdG5leHRQYWRkaW5nICs9IGNoO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChuZXh0UGFkZGluZy5sZW5ndGggPiBjdXJQYWRkaW5nLmxlbmd0aClcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KG5sICsgbmV4dFBhZGRpbmcsIGNhcmV0UG9zLCBjYXJldFBvcywgdHJ1ZSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudChubCwgY2FyZXRQb3MpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSwge2hpZGRlbjogdHJ1ZX0pO1xufSk7LyoqXG4gKiBNZXJnZXMgc2VsZWN0ZWQgbGluZXMgb3IgbGluZXMgYmV0d2VlbiBYSFRNTCB0YWcgcGFpcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0cmVxdWlyZSgnYWN0aW9ucycpLmFkZCgnbWVyZ2VfbGluZXMnLCBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHR2YXIgbWF0Y2hlciA9IHJlcXVpcmUoJ2h0bWxNYXRjaGVyJyk7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHR2YXIgZWRpdG9yVXRpbHMgPSByZXF1aXJlKCdlZGl0b3JVdGlscycpO1xuXHRcdHZhciBpbmZvID0gZWRpdG9yVXRpbHMub3V0cHV0SW5mbyhlZGl0b3IpO1xuXHRcdFxuXHRcdC8qKiBAdHlwZSBSYW5nZSAqL1xuXHRcdHZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZShlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG5cdFx0aWYgKCFzZWxlY3Rpb24ubGVuZ3RoKCkpIHtcblx0XHRcdC8vIGZpbmQgbWF0Y2hpbmcgdGFnXG5cdFx0XHR2YXIgcGFpciA9IG1hdGNoZXIuZmluZChpbmZvLmNvbnRlbnQsIGVkaXRvci5nZXRDYXJldFBvcygpKTtcblx0XHRcdGlmIChwYWlyKSB7XG5cdFx0XHRcdHNlbGVjdGlvbiA9IHBhaXIub3V0ZXJSYW5nZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKHNlbGVjdGlvbi5sZW5ndGgoKSkge1xuXHRcdFx0Ly8gZ290IHJhbmdlLCBtZXJnZSBsaW5lc1xuXHRcdFx0dmFyIHRleHQgPSAgc2VsZWN0aW9uLnN1YnN0cmluZyhpbmZvLmNvbnRlbnQpO1xuXHRcdFx0dmFyIGxpbmVzID0gdXRpbHMuc3BsaXRCeUxpbmVzKHRleHQpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgvXlxccysvLCAnJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRleHQgPSBsaW5lcy5qb2luKCcnKS5yZXBsYWNlKC9cXHN7Mix9LywgJyAnKTtcblx0XHRcdHZhciB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG5cdFx0XHR0ZXh0ID0gdXRpbHMuZXNjYXBlVGV4dCh0ZXh0KTtcblx0XHRcdGVkaXRvci5yZXBsYWNlQ29udGVudCh0ZXh0LCBzZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5lbmQpO1xuXHRcdFx0ZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5zdGFydCArIHRleHRMZW4pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KTtcbn0pOy8qKlxuICogRW5jb2Rlcy9kZWNvZGVzIGltYWdlIHVuZGVyIGN1cnNvciB0by9mcm9tIGJhc2U2NFxuICogQHBhcmFtIHtJRW1tZXRFZGl0b3J9IGVkaXRvclxuICogQHNpbmNlIDAuNjVcbiAqIFxuICogQG1lbWJlck9mIF9fYmFzZTY0QWN0aW9uRGVmaW5lXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0cmVxdWlyZSgnYWN0aW9ucycpLmFkZCgnZW5jb2RlX2RlY29kZV9kYXRhX3VybCcsIGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdHZhciBkYXRhID0gU3RyaW5nKGVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XG5cdFx0dmFyIGNhcmV0UG9zID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0XHRcblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdC8vIG5vIHNlbGVjdGlvbiwgdHJ5IHRvIGZpbmQgaW1hZ2UgYm91bmRzIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdFx0dmFyIHRleHQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSksICBtO1xuXHRcdFx0d2hpbGUgKGNhcmV0UG9zLS0gPj0gMCkge1xuXHRcdFx0XHRpZiAoc3RhcnRzV2l0aCgnc3JjPScsIHRleHQsIGNhcmV0UG9zKSkgeyAvLyBmb3VuZCA8aW1nIHNyYz1cIlwiPlxuXHRcdFx0XHRcdGlmIChtID0gdGV4dC5zdWJzdHIoY2FyZXRQb3MpLm1hdGNoKC9eKHNyYz0oW1wiJ10pPykoW14nXCI8Plxcc10rKVxcMT8vKSkge1xuXHRcdFx0XHRcdFx0ZGF0YSA9IG1bM107XG5cdFx0XHRcdFx0XHRjYXJldFBvcyArPSBtWzFdLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhcnRzV2l0aCgndXJsKCcsIHRleHQsIGNhcmV0UG9zKSkgeyAvLyBmb3VuZCBDU1MgdXJsKCkgcGF0dGVyblxuXHRcdFx0XHRcdGlmIChtID0gdGV4dC5zdWJzdHIoY2FyZXRQb3MpLm1hdGNoKC9eKHVybFxcKChbJ1wiXSk/KShbXidcIlxcKVxcc10rKVxcMT8vKSkge1xuXHRcdFx0XHRcdFx0ZGF0YSA9IG1bM107XG5cdFx0XHRcdFx0XHRjYXJldFBvcyArPSBtWzFdLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGRhdGEpIHtcblx0XHRcdGlmIChzdGFydHNXaXRoKCdkYXRhOicsIGRhdGEpKVxuXHRcdFx0XHRyZXR1cm4gZGVjb2RlRnJvbUJhc2U2NChlZGl0b3IsIGRhdGEsIGNhcmV0UG9zKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuIGVuY29kZVRvQmFzZTY0KGVkaXRvciwgZGF0YSwgY2FyZXRQb3MpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sIHtsYWJlbDogJ0VuY29kZVxcXFxEZWNvZGUgZGF0YTpVUkwgaW1hZ2UnfSk7XG5cdFxuXHQvKipcblx0ICogVGVzdCBpZiA8Y29kZT50ZXh0PC9jb2RlPiBzdGFydHMgd2l0aCA8Y29kZT50b2tlbjwvY29kZT4gYXQgPGNvZGU+cG9zPC9jb2RlPlxuXHQgKiBwb3NpdGlvbi4gSWYgPGNvZGU+cG9zPC9jb2RlPiBpcyBvbWl0dGVkLCBzZWFyY2ggZnJvbSBiZWdpbm5pbmcgb2YgdGV4dCBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRva2VuIHRvIHRlc3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgV2hlcmUgdG8gc2VhcmNoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgUG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgc2VhcmNoXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBzaW5jZSAwLjY1XG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFydHNXaXRoKHRva2VuLCB0ZXh0LCBwb3MpIHtcblx0XHRwb3MgPSBwb3MgfHwgMDtcblx0XHRyZXR1cm4gdGV4dC5jaGFyQXQocG9zKSA9PSB0b2tlbi5jaGFyQXQoMCkgJiYgdGV4dC5zdWJzdHIocG9zLCB0b2tlbi5sZW5ndGgpID09IHRva2VuO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRW5jb2RlcyBpbWFnZSB0byBiYXNlNjRcblx0ICogXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IGltZ1BhdGggUGF0aCB0byBpbWFnZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zIENhcmV0IHBvc2l0aW9uIHdoZXJlIGltYWdlIGlzIGxvY2F0ZWQgaW4gdGhlIGVkaXRvclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlVG9CYXNlNjQoZWRpdG9yLCBpbWdQYXRoLCBwb3MpIHtcblx0XHR2YXIgZmlsZSA9IHJlcXVpcmUoJ2ZpbGUnKTtcblx0XHR2YXIgYWN0aW9uVXRpbHMgPSByZXF1aXJlKCdhY3Rpb25VdGlscycpO1xuXHRcdFxuXHRcdHZhciBlZGl0b3JGaWxlID0gZWRpdG9yLmdldEZpbGVQYXRoKCk7XG5cdFx0dmFyIGRlZmF1bHRNaW1lVHlwZSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuXHRcdFx0XG5cdFx0aWYgKGVkaXRvckZpbGUgPT09IG51bGwpIHtcblx0XHRcdHRocm93IFwiWW91IHNob3VsZCBzYXZlIHlvdXIgZmlsZSBiZWZvcmUgdXNpbmcgdGhpcyBhY3Rpb25cIjtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gbG9jYXRlIHJlYWwgaW1hZ2UgcGF0aFxuXHRcdHZhciByZWFsSW1nUGF0aCA9IGZpbGUubG9jYXRlRmlsZShlZGl0b3JGaWxlLCBpbWdQYXRoKTtcblx0XHRpZiAocmVhbEltZ1BhdGggPT09IG51bGwpIHtcblx0XHRcdHRocm93IFwiQ2FuJ3QgZmluZCBcIiArIGltZ1BhdGggKyAnIGZpbGUnO1xuXHRcdH1cblx0XHRcblx0XHRmaWxlLnJlYWQocmVhbEltZ1BhdGgsIGZ1bmN0aW9uKGVyciwgY29udGVudCkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHR0aHJvdyAnVW5hYmxlIHRvIHJlYWQgJyArIHJlYWxJbWdQYXRoICsgJzogJyArIGVycjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGI2NCA9IHJlcXVpcmUoJ2Jhc2U2NCcpLmVuY29kZShTdHJpbmcoY29udGVudCkpO1xuXHRcdFx0aWYgKCFiNjQpIHtcblx0XHRcdFx0dGhyb3cgXCJDYW4ndCBlbmNvZGUgZmlsZSBjb250ZW50IHRvIGJhc2U2NFwiO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRiNjQgPSAnZGF0YTonICsgKGFjdGlvblV0aWxzLm1pbWVUeXBlc1tTdHJpbmcoZmlsZS5nZXRFeHQocmVhbEltZ1BhdGgpKV0gfHwgZGVmYXVsdE1pbWVUeXBlKSArXG5cdFx0XHRcdCc7YmFzZTY0LCcgKyBiNjQ7XG5cdFx0XHRcdFxuXHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KCckMCcgKyBiNjQsIHBvcywgcG9zICsgaW1nUGF0aC5sZW5ndGgpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYmFzZTY0IHN0cmluZyBiYWNrIHRvIGZpbGUuXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgQmFzZTY0LWVuY29kZWQgZmlsZSBjb250ZW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgQ2FyZXQgcG9zaXRpb24gd2hlcmUgaW1hZ2UgaXMgbG9jYXRlZCBpbiB0aGUgZWRpdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGVGcm9tQmFzZTY0KGVkaXRvciwgZGF0YSwgcG9zKSB7XG5cdFx0Ly8gYXNrIHVzZXIgdG8gZW50ZXIgcGF0aCB0byBmaWxlXG5cdFx0dmFyIGZpbGVQYXRoID0gU3RyaW5nKGVkaXRvci5wcm9tcHQoJ0VudGVyIHBhdGggdG8gZmlsZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpJykpO1xuXHRcdGlmICghZmlsZVBhdGgpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHR2YXIgZmlsZSA9IHJlcXVpcmUoJ2ZpbGUnKTtcblx0XHR2YXIgYWJzUGF0aCA9IGZpbGUuY3JlYXRlUGF0aChlZGl0b3IuZ2V0RmlsZVBhdGgoKSwgZmlsZVBhdGgpO1xuXHRcdGlmICghYWJzUGF0aCkge1xuXHRcdFx0dGhyb3cgXCJDYW4ndCBzYXZlIGZpbGVcIjtcblx0XHR9XG5cdFx0XG5cdFx0ZmlsZS5zYXZlKGFic1BhdGgsIHJlcXVpcmUoJ2Jhc2U2NCcpLmRlY29kZSggZGF0YS5yZXBsYWNlKC9eZGF0YVxcOi4rPzsuKz8sLywgJycpICkpO1xuXHRcdGVkaXRvci5yZXBsYWNlQ29udGVudCgnJDAnICsgZmlsZVBhdGgsIHBvcywgcG9zICsgZGF0YS5sZW5ndGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIGltYWdlIHNpemUgYXR0cmlidXRlcyBpbiBIVE1MJ3MgJmx0O2ltZyZndDsgZWxlbWVudCBvclxuICogQ1NTIHJ1bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX191cGRhdGVJbWFnZVNpemVBY3Rpb25cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKlxuXHQgKiBVcGRhdGVzIGltYWdlIHNpemUgb2YgJmx0O2ltZyBzcmM9XCJcIiZndDsgdGFnXG5cdCAqIEBwYXJhbSB7SUVtbWV0RWRpdG9yfSBlZGl0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZUltYWdlU2l6ZUhUTUwoZWRpdG9yKSB7XG5cdFx0dmFyIG9mZnNldCA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFxuXHRcdC8vIGZpbmQgdGFnIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdHZhciBpbmZvID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0dmFyIHhtbEVsZW0gPSByZXF1aXJlKCd4bWxFZGl0VHJlZScpLnBhcnNlRnJvbVBvc2l0aW9uKGluZm8uY29udGVudCwgb2Zmc2V0LCB0cnVlKTtcblx0XHRpZiAoeG1sRWxlbSAmJiAoeG1sRWxlbS5uYW1lKCkgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT0gJ2ltZycpIHtcblx0XHRcdGdldEltYWdlU2l6ZUZvclNvdXJjZShlZGl0b3IsIHhtbEVsZW0udmFsdWUoJ3NyYycpLCBmdW5jdGlvbihzaXplKSB7XG5cdFx0XHRcdGlmIChzaXplKSB7XG5cdFx0XHRcdFx0dmFyIGNvbXBvdW5kRGF0YSA9IHhtbEVsZW0ucmFuZ2UodHJ1ZSk7XG5cdFx0XHRcdFx0eG1sRWxlbS52YWx1ZSgnd2lkdGgnLCBzaXplLndpZHRoKTtcblx0XHRcdFx0XHR4bWxFbGVtLnZhbHVlKCdoZWlnaHQnLCBzaXplLmhlaWdodCwgeG1sRWxlbS5pbmRleE9mKCd3aWR0aCcpICsgMSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmVxdWlyZSgnYWN0aW9uVXRpbHMnKS5jb21wb3VuZFVwZGF0ZShlZGl0b3IsIF8uZXh0ZW5kKGNvbXBvdW5kRGF0YSwge1xuXHRcdFx0XHRcdFx0ZGF0YTogeG1sRWxlbS50b1N0cmluZygpLFxuXHRcdFx0XHRcdFx0Y2FyZXQ6IG9mZnNldFxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogVXBkYXRlcyBpbWFnZSBzaXplIG9mIENTUyBwcm9wZXJ0eVxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVJbWFnZVNpemVDU1MoZWRpdG9yKSB7XG5cdFx0dmFyIG9mZnNldCA9IGVkaXRvci5nZXRDYXJldFBvcygpO1xuXHRcdFxuXHRcdC8vIGZpbmQgdGFnIGZyb20gY3VycmVudCBjYXJldCBwb3NpdGlvblxuXHRcdHZhciBpbmZvID0gcmVxdWlyZSgnZWRpdG9yVXRpbHMnKS5vdXRwdXRJbmZvKGVkaXRvcik7XG5cdFx0dmFyIGNzc1J1bGUgPSByZXF1aXJlKCdjc3NFZGl0VHJlZScpLnBhcnNlRnJvbVBvc2l0aW9uKGluZm8uY29udGVudCwgb2Zmc2V0LCB0cnVlKTtcblx0XHRpZiAoY3NzUnVsZSkge1xuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlcmUgaXMgcHJvcGVydHkgd2l0aCBpbWFnZSB1bmRlciBjYXJldFxuXHRcdFx0dmFyIHByb3AgPSBjc3NSdWxlLml0ZW1Gcm9tUG9zaXRpb24ob2Zmc2V0LCB0cnVlKSwgbTtcblx0XHRcdGlmIChwcm9wICYmIChtID0gL3VybFxcKChbXCInXT8pKC4rPylcXDFcXCkvaS5leGVjKHByb3AudmFsdWUoKSB8fCAnJykpKSB7XG5cdFx0XHRcdGdldEltYWdlU2l6ZUZvclNvdXJjZShlZGl0b3IsIG1bMl0sIGZ1bmN0aW9uKHNpemUpIHtcblx0XHRcdFx0XHRpZiAoc2l6ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGNvbXBvdW5kRGF0YSA9IGNzc1J1bGUucmFuZ2UodHJ1ZSk7XG5cdFx0XHRcdFx0XHRjc3NSdWxlLnZhbHVlKCd3aWR0aCcsIHNpemUud2lkdGggKyAncHgnKTtcblx0XHRcdFx0XHRcdGNzc1J1bGUudmFsdWUoJ2hlaWdodCcsIHNpemUuaGVpZ2h0ICsgJ3B4JywgY3NzUnVsZS5pbmRleE9mKCd3aWR0aCcpICsgMSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJlcXVpcmUoJ2FjdGlvblV0aWxzJykuY29tcG91bmRVcGRhdGUoZWRpdG9yLCBfLmV4dGVuZChjb21wb3VuZERhdGEsIHtcblx0XHRcdFx0XHRcdFx0ZGF0YTogY3NzUnVsZS50b1N0cmluZygpLFxuXHRcdFx0XHRcdFx0XHRjYXJldDogb2Zmc2V0XG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGltYWdlIGRpbWVuc2lvbnMgZm9yIHNvdXJjZVxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgSW1hZ2Ugc291cmNlIChwYXRoIG9yIGRhdGE6dXJsKVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0SW1hZ2VTaXplRm9yU291cmNlKGVkaXRvciwgc3JjLCBjYWxsYmFjaykge1xuXHRcdHZhciBmaWxlQ29udGVudDtcblx0XHR2YXIgYXUgPSByZXF1aXJlKCdhY3Rpb25VdGlscycpO1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdC8vIGNoZWNrIGlmIGl0IGlzIGRhdGE6dXJsXG5cdFx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKSB7XG5cdFx0XHRcdGZpbGVDb250ZW50ID0gcmVxdWlyZSgnYmFzZTY0JykuZGVjb2RlKCBzcmMucmVwbGFjZSgvXmRhdGFcXDouKz87Lis/LC8sICcnKSApO1xuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soYXUuZ2V0SW1hZ2VTaXplKGZpbGVDb250ZW50KSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBmaWxlID0gcmVxdWlyZSgnZmlsZScpO1xuXHRcdFx0dmFyIGFic1BhdGggPSBmaWxlLmxvY2F0ZUZpbGUoZWRpdG9yLmdldEZpbGVQYXRoKCksIHNyYyk7XG5cdFx0XHRpZiAoYWJzUGF0aCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBcIkNhbid0IGZpbmQgXCIgKyBzcmMgKyAnIGZpbGUnO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmaWxlLnJlYWQoYWJzUGF0aCwgZnVuY3Rpb24oZXJyLCBjb250ZW50KSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHR0aHJvdyAnVW5hYmxlIHRvIHJlYWQgJyArIGFic1BhdGggKyAnOiAnICsgZXJyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb250ZW50ID0gU3RyaW5nKGNvbnRlbnQpO1xuXHRcdFx0XHRjYWxsYmFjayhhdS5nZXRJbWFnZVNpemUoY29udGVudCkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXF1aXJlKCdhY3Rpb25zJykuYWRkKCd1cGRhdGVfaW1hZ2Vfc2l6ZScsIGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdC8vIHRoaXMgYWN0aW9uIHdpbGwgZGVmaW5pdGVseSB3b27igJl0IHdvcmsgaW4gU0FTUyBkaWFsZWN0LFxuXHRcdC8vIGJ1dCBtYXkgd29yayBpbiBTQ1NTIG9yIExFU1Ncblx0XHRpZiAoXy5pbmNsdWRlKFsnY3NzJywgJ2xlc3MnLCAnc2NzcyddLCBTdHJpbmcoZWRpdG9yLmdldFN5bnRheCgpKSkpIHtcblx0XHRcdHVwZGF0ZUltYWdlU2l6ZUNTUyhlZGl0b3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cGRhdGVJbWFnZVNpemVIVE1MKGVkaXRvcik7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9KTtcbn0pOy8qKlxuICogUmVzb2x2ZXIgZm9yIGZhc3QgQ1NTIHR5cGluZy4gSGFuZGxlcyBhYmJyZXZpYXRpb25zIHdpdGggdGhlIGZvbGxvd2luZyBcbiAqIG5vdGF0aW9uOjxicj5cbiAqIFxuICogPGNvZGU+KC12ZW5kb3IgcHJlZml4KT9wcm9wZXJ0eSh2YWx1ZSkqKCEpPzwvY29kZT5cbiAqIFxuICogPGJyPjxicj5cbiAqIDxiPkFiYnJldmlhdGlvbiBoYW5kbGluZzwvYj48YnI+XG4gKiBcbiAqIEJ5IGRlZmF1bHQsIEVtbWV0IHNlYXJjaGVzIGZvciBtYXRjaGluZyBzbmlwcGV0IGRlZmluaXRpb24gZm9yIHByb3ZpZGVkIGFiYnJldmlhdGlvbi5cbiAqIElmIHNuaXBwZXQgd2Fzbid0IGZvdW5kLCBFbW1ldCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBlbGVtZW50IHdpdGggXG4gKiBhYmJyZXZpYXRpb24ncyBuYW1lLiBGb3IgZXhhbXBsZSwgPGNvZGU+Zm9vPC9jb2RlPiBhYmJyZXZpYXRpb24gd2lsbCBnZW5lcmF0ZVxuICogPGNvZGU+Jmx0O2ZvbyZndDsmbHQ7L2ZvbyZndDs8L2NvZGU+IG91dHB1dC5cbiAqIDxicj48YnI+XG4gKiBUaGlzIG1vZHVsZSB3aWxsIGNhcHR1cmUgYWxsIGV4cGFuZGVkIHByb3BlcnRpZXMgYW5kIHVwZ3JhZGUgdGhlbSB3aXRoIHZhbHVlcywgXG4gKiB2ZW5kb3IgcHJlZml4ZXMgYW5kICFpbXBvcnRhbnQgZGVjbGFyYXRpb25zLiBBbGwgdW5tYXRjaGVkIGFiYnJldmlhdGlvbnMgd2lsbCBcbiAqIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgaW50byA8Y29kZT5wcm9wZXJ0eS1uYW1lOiAkezF9PC9jb2RlPiBzbmlwcGV0cy4gXG4gKiBcbiAqIDxiPlZlbmRvciBwcmVmaXhlczxiPjxicj5cbiAqIFxuICogSWYgQ1NTLXByb3BlcnR5IGlzIHByZWNlZGVkIHdpdGggZGFzaCwgcmVzb2x2ZXIgc2hvdWxkIG91dHB1dCBwcm9wZXJ0eSB3aXRoXG4gKiBhbGwgPGk+a25vd248L2k+IHZlbmRvciBwcmVmaXhlcy4gRm9yIGV4YW1wbGUsIGlmIDxjb2RlPmJyYWQ8L2NvZGU+IFxuICogYWJicmV2aWF0aW9uIGdlbmVyYXRlcyA8Y29kZT5ib3JkZXItcmFkaXVzOiAke3ZhbHVlfTs8L2NvZGU+IHNuaXBwZXQsXG4gKiB0aGUgPGNvZGU+LWJyYWQ8L2NvZGU+IGFiYnJldmlhdGlvbiBzaG91bGQgZ2VuZXJhdGU6XG4gKiA8cHJlPjxjb2RlPlxuICogLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAke3ZhbHVlfTtcbiAqIC1tb3otYm9yZGVyLXJhZGl1czogJHt2YWx1ZX07XG4gKiBib3JkZXItcmFkaXVzOiAke3ZhbHVlfTtcbiAqIDwvY29kZT48L3ByZT5cbiAqIE5vdGUgdGhhdCA8aT5vPC9pPiBhbmQgPGk+bXM8L2k+IHByZWZpeGVzIGFyZSBvbWl0dGVkIHNpbmNlIE9wZXJhIGFuZCBJRSBcbiAqIHN1cHBvcnRzIHVucHJlZml4ZWQgcHJvcGVydHkuPGJyPjxicj5cbiAqIFxuICogVXNlcnMgY2FuIGFsc28gcHJvdmlkZSBhbiBleHBsaWNpdCBsaXN0IG9mIG9uZS1jaGFyYWN0ZXIgcHJlZml4ZXMgZm9yIGFueVxuICogQ1NTIHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgPGNvZGU+LXdtLWZsb2F0PC9jb2RlPiB3aWxsIHByb2R1Y2VcbiAqIFxuICogPHByZT48Y29kZT5cbiAqIC13ZWJraXQtZmxvYXQ6ICR7MX07XG4gKiAtbW96LWZsb2F0OiAkezF9O1xuICogZmxvYXQ6ICR7MX07XG4gKiA8L2NvZGU+PC9wcmU+XG4gKiBcbiAqIEFsdGhvdWdoIHRoaXMgZXhhbXBsZSBsb29rcyBwb2ludGxlc3MsIHVzZXJzIGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIHdyaXRlXG4gKiBjdXR0aW5nLWVkZ2UgcHJvcGVydGllcyBpbXBsZW1lbnRlZCBieSBicm93c2VyIHZlbmRvcnMgcmVjZW50bHkuICBcbiAqIFxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX19jc3NSZXNvbHZlckRlZmluZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmRlZmluZSgnY3NzUmVzb2x2ZXInLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdC8qKiBCYWNrLXJlZmVyZW5jZSB0byBtb2R1bGUgKi9cblx0dmFyIG1vZHVsZSA9IG51bGw7XG5cdFxuXHR2YXIgcHJlZml4T2JqID0ge1xuXHRcdC8qKiBSZWFsIHZlbmRvciBwcmVmaXggbmFtZSAqL1xuXHRcdHByZWZpeDogJ2VtbWV0Jyxcblx0XHRcblx0XHQvKiogXG5cdFx0ICogSW5kaWNhdGVzIHRoaXMgcHJlZml4IGlzIG9ic29sZXRlIGFuZCBzaG91bGQndCBiZSB1c2VkIHdoZW4gdXNlciBcblx0XHQgKiB3YW50cyB0byBnZW5lcmF0ZSBhbGwtcHJlZml4ZWQgcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdG9ic29sZXRlOiBmYWxzZSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHByZWZpeGVkIENTUyBwcm9wZXJ0eSBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVW5wcmVmaXhlZCBDU1MgcHJvcGVydHlcblx0XHQgKi9cblx0XHR0cmFuc2Zvcm1OYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gJy0nICsgdGhpcy5wcmVmaXggKyAnLScgKyBuYW1lO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiB1bnByZWZpeGVkIENTUyBwcm9wZXJ0aWVzIHRoYXQgc3VwcG9ydGVkIGJ5IFxuXHRcdCAqIGN1cnJlbnQgcHJlZml4LiBUaGlzIGxpc3QgaXMgdXNlZCB0byBnZW5lcmF0ZSBhbGwtcHJlZml4ZWQgcHJvcGVydHlcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFxuXHRcdCAqL1xuXHRcdHByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGdldFByb3BlcnRpZXMoJ2Nzcy4nICsgdGhpcy5wcmVmaXggKyAnUHJvcGVydGllcycpIHx8IFtdO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgcHJlZml4XG5cdFx0ICogQHBhcmFtIG5hbWVcblx0XHQgKi9cblx0XHRzdXBwb3J0czogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cmV0dXJuIF8uaW5jbHVkZSh0aGlzLnByb3BlcnRpZXMoKSwgbmFtZSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKiBcblx0ICogTGlzdCBvZiByZWdpc3RlcmVkIG9uZS1jaGFyYWN0ZXIgcHJlZml4ZXMuIEtleSBpcyBhIG9uZS1jaGFyYWN0ZXIgcHJlZml4LCBcblx0ICogdmFsdWUgaXMgYW4gPGNvZGU+cHJlZml4T2JqPC9jb2RlPiBvYmplY3Rcblx0ICovXG5cdHZhciB2ZW5kb3JQcmVmaXhlcyA9IHt9O1xuXHRcblx0dmFyIGRlZmF1bHRWYWx1ZSA9ICckezF9Oyc7XG5cdFxuXHQvLyBYWFggbW9kdWxlIHByZWZlcmVuY2VzXG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJ3ByZWZlcmVuY2VzJyk7XG5cdHByZWZzLmRlZmluZSgnY3NzLnZhbHVlU2VwYXJhdG9yJywgJzogJyxcblx0XHRcdCdEZWZpbmVzIGEgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBiZXR3ZWVuIENTUyBwcm9wZXJ0eSBhbmQgJyBcblx0XHRcdCsgJ3ZhbHVlIHdoZW4gZXhwYW5kaW5nIENTUyBhYmJyZXZpYXRpb25zLicpO1xuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5wcm9wZXJ0eUVuZCcsICc7Jyxcblx0XHRcdCdEZWZpbmVzIGEgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIENTUyBwcm9wZXJ0eSAgJyBcblx0XHRcdCsgJ3doZW4gZXhwYW5kaW5nIENTUyBhYmJyZXZpYXRpb25zLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdzdHlsdXMudmFsdWVTZXBhcmF0b3InLCAnICcsXG5cdFx0XHQnRGVmaW5lcyBhIHN5bWJvbCB0aGF0IHNob3VsZCBiZSBwbGFjZWQgYmV0d2VlbiBDU1MgcHJvcGVydHkgYW5kICcgXG5cdFx0XHQrICd2YWx1ZSB3aGVuIGV4cGFuZGluZyBDU1MgYWJicmV2aWF0aW9ucyBpbiBTdHlsdXMgZGlhbGVjdC4nKTtcblx0cHJlZnMuZGVmaW5lKCdzdHlsdXMucHJvcGVydHlFbmQnLCAnJyxcblx0XHRcdCdEZWZpbmVzIGEgc3ltYm9sIHRoYXQgc2hvdWxkIGJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIENTUyBwcm9wZXJ0eSAgJyBcblx0XHRcdCsgJ3doZW4gZXhwYW5kaW5nIENTUyBhYmJyZXZpYXRpb25zIGluIFN0eWx1cyBkaWFsZWN0LicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdzYXNzLnByb3BlcnR5RW5kJywgJycsXG5cdFx0XHQnRGVmaW5lcyBhIHN5bWJvbCB0aGF0IHNob3VsZCBiZSBwbGFjZWQgYXQgdGhlIGVuZCBvZiBDU1MgcHJvcGVydHkgICcgXG5cdFx0XHQrICd3aGVuIGV4cGFuZGluZyBDU1MgYWJicmV2aWF0aW9ucyBpbiBTQVNTIGRpYWxlY3QuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5hdXRvSW5zZXJ0VmVuZG9yUHJlZml4ZXMnLCB0cnVlLFxuXHRcdFx0J0F1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgdmVuZG9yLXByZWZpeGVkIGNvcGllcyBvZiBleHBhbmRlZCBDU1MgJyBcblx0XHRcdCsgJ3Byb3BlcnR5LiBCeSBkZWZhdWx0LCBFbW1ldCB3aWxsIGdlbmVyYXRlIHZlbmRvci1wcmVmaXhlZCAnXG5cdFx0XHQrICdwcm9wZXJ0aWVzIG9ubHkgd2hlbiB5b3UgcHV0IGRhc2ggYmVmb3JlIGFiYnJldmlhdGlvbiAnIFxuXHRcdFx0KyAnKGUuZy4gPGNvZGU+LWJ4c2g8L2NvZGU+KS4gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB5b3UgZG9u4oCZdCAnIFxuXHRcdFx0KyAnbmVlZCBkYXNoZXMgYmVmb3JlIGFiYnJldmlhdGlvbnM6IEVtbWV0IHdpbGwgcHJvZHVjZSAnIFxuXHRcdFx0KyAndmVuZG9yLXByZWZpeGVkIHByb3BlcnRpZXMgZm9yIHlvdS4nKTtcblx0XG5cdHZhciBkZXNjVGVtcGxhdGUgPSBfLnRlbXBsYXRlKCdBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIENTUyBwcm9wZXJ0aWVzIHRoYXQgbWF5IGhhdmUgJyBcblx0XHQrICc8Y29kZT48JT0gdmVuZG9yICU+PC9jb2RlPiB2ZW5kb3IgcHJlZml4LiBUaGlzIGxpc3QgaXMgdXNlZCB0byBnZW5lcmF0ZSAnXG5cdFx0KyAnYSBsaXN0IG9mIHByZWZpeGVkIHByb3BlcnRpZXMgd2hlbiBleHBhbmRpbmcgPGNvZGU+LXByb3BlcnR5PC9jb2RlPiAnXG5cdFx0KyAnYWJicmV2aWF0aW9ucy4gRW1wdHkgbGlzdCBtZWFucyB0aGF0IGFsbCBwb3NzaWJsZSBDU1MgdmFsdWVzIG1heSAnIFxuXHRcdCsgJ2hhdmUgPGNvZGU+PCU9IHZlbmRvciAlPjwvY29kZT4gcHJlZml4LicpO1xuXHRcblx0dmFyIGRlc2NBZGRvblRlbXBsYXRlID0gXy50ZW1wbGF0ZSgnQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiA8ZW0+YWRkaXRpb25hbDwvZW0+IENTUyBwcm9wZXJ0aWVzICcgXG5cdFx0XHQrICdmb3IgPGNvZGU+Y3NzLjwlPSB2ZW5kb3IgJT5QcmVwZXJ0aWVzPC9jb2RlPiBwcmVmZXJlbmNlLiAnIFxuXHRcdFx0KyAnWW91IHNob3VsZCB1c2UgdGhpcyBsaXN0IGlmIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgYSBmZXcgQ1NTICcgXG5cdFx0XHQrICdwcm9wZXJ0aWVzIHRvIG9yaWdpbmFsIHNldC4gVG8gYWRkIGEgbmV3IHByb3BlcnR5LCBzaW1wbHkgd3JpdGUgaXRzIG5hbWUsICdcblx0XHRcdCsgJ3RvIHJlbW92ZSBpdCwgcHJlY2VkZSBwcm9wZXJ0eSB3aXRoIGh5cGhlbi48YnI+J1xuXHRcdFx0KyAnRm9yIGV4YW1wbGUsIHRvIGFkZCA8ZW0+Zm9vPC9lbT4gcHJvcGVydHkgYW5kIHJlbW92ZSA8ZW0+Ym9yZGVyLXJhZGl1czwvZW0+IG9uZSwgJ1xuXHRcdFx0KyAndGhlIHByZWZlcmVuY2UgdmFsdWUgd2lsbCBsb29rIGxpa2UgdGhpczogPGNvZGU+Zm9vLCAtYm9yZGVyLXJhZGl1czwvY29kZT4uJyk7XG5cdFxuXHQvLyBwcm9wZXJ0aWVzIGxpc3QgaXMgY3JlYXRlZCBmcm9tIGNzc0ZlYXR1cmVzLmh0bWwgZmlsZVxuXHR2YXIgcHJvcHMgPSB7XG5cdFx0J3dlYmtpdCc6ICdhbmltYXRpb24sIGFuaW1hdGlvbi1kZWxheSwgYW5pbWF0aW9uLWRpcmVjdGlvbiwgYW5pbWF0aW9uLWR1cmF0aW9uLCBhbmltYXRpb24tZmlsbC1tb2RlLCBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBhbmltYXRpb24tbmFtZSwgYW5pbWF0aW9uLXBsYXktc3RhdGUsIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24sIGFwcGVhcmFuY2UsIGJhY2tmYWNlLXZpc2liaWxpdHksIGJhY2tncm91bmQtY2xpcCwgYmFja2dyb3VuZC1jb21wb3NpdGUsIGJhY2tncm91bmQtb3JpZ2luLCBiYWNrZ3JvdW5kLXNpemUsIGJvcmRlci1maXQsIGJvcmRlci1ob3Jpem9udGFsLXNwYWNpbmcsIGJvcmRlci1pbWFnZSwgYm9yZGVyLXZlcnRpY2FsLXNwYWNpbmcsIGJveC1hbGlnbiwgYm94LWRpcmVjdGlvbiwgYm94LWZsZXgsIGJveC1mbGV4LWdyb3VwLCBib3gtbGluZXMsIGJveC1vcmRpbmFsLWdyb3VwLCBib3gtb3JpZW50LCBib3gtcGFjaywgYm94LXJlZmxlY3QsIGJveC1zaGFkb3csIGNvbG9yLWNvcnJlY3Rpb24sIGNvbHVtbi1icmVhay1hZnRlciwgY29sdW1uLWJyZWFrLWJlZm9yZSwgY29sdW1uLWJyZWFrLWluc2lkZSwgY29sdW1uLWNvdW50LCBjb2x1bW4tZ2FwLCBjb2x1bW4tcnVsZS1jb2xvciwgY29sdW1uLXJ1bGUtc3R5bGUsIGNvbHVtbi1ydWxlLXdpZHRoLCBjb2x1bW4tc3BhbiwgY29sdW1uLXdpZHRoLCBkYXNoYm9hcmQtcmVnaW9uLCBmb250LXNtb290aGluZywgaGlnaGxpZ2h0LCBoeXBoZW5hdGUtY2hhcmFjdGVyLCBoeXBoZW5hdGUtbGltaXQtYWZ0ZXIsIGh5cGhlbmF0ZS1saW1pdC1iZWZvcmUsIGh5cGhlbnMsIGxpbmUtYm94LWNvbnRhaW4sIGxpbmUtYnJlYWssIGxpbmUtY2xhbXAsIGxvY2FsZSwgbWFyZ2luLWJlZm9yZS1jb2xsYXBzZSwgbWFyZ2luLWFmdGVyLWNvbGxhcHNlLCBtYXJxdWVlLWRpcmVjdGlvbiwgbWFycXVlZS1pbmNyZW1lbnQsIG1hcnF1ZWUtcmVwZXRpdGlvbiwgbWFycXVlZS1zdHlsZSwgbWFzay1hdHRhY2htZW50LCBtYXNrLWJveC1pbWFnZSwgbWFzay1ib3gtaW1hZ2Utb3V0c2V0LCBtYXNrLWJveC1pbWFnZS1yZXBlYXQsIG1hc2stYm94LWltYWdlLXNsaWNlLCBtYXNrLWJveC1pbWFnZS1zb3VyY2UsIG1hc2stYm94LWltYWdlLXdpZHRoLCBtYXNrLWNsaXAsIG1hc2stY29tcG9zaXRlLCBtYXNrLWltYWdlLCBtYXNrLW9yaWdpbiwgbWFzay1wb3NpdGlvbiwgbWFzay1yZXBlYXQsIG1hc2stc2l6ZSwgbmJzcC1tb2RlLCBwZXJzcGVjdGl2ZSwgcGVyc3BlY3RpdmUtb3JpZ2luLCBydGwtb3JkZXJpbmcsIHRleHQtY29tYmluZSwgdGV4dC1kZWNvcmF0aW9ucy1pbi1lZmZlY3QsIHRleHQtZW1waGFzaXMtY29sb3IsIHRleHQtZW1waGFzaXMtcG9zaXRpb24sIHRleHQtZW1waGFzaXMtc3R5bGUsIHRleHQtZmlsbC1jb2xvciwgdGV4dC1vcmllbnRhdGlvbiwgdGV4dC1zZWN1cml0eSwgdGV4dC1zdHJva2UtY29sb3IsIHRleHQtc3Ryb2tlLXdpZHRoLCB0cmFuc2Zvcm0sIHRyYW5zaXRpb24sIHRyYW5zZm9ybS1vcmlnaW4sIHRyYW5zZm9ybS1zdHlsZSwgdHJhbnNpdGlvbi1kZWxheSwgdHJhbnNpdGlvbi1kdXJhdGlvbiwgdHJhbnNpdGlvbi1wcm9wZXJ0eSwgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24sIHVzZXItZHJhZywgdXNlci1tb2RpZnksIHVzZXItc2VsZWN0LCB3cml0aW5nLW1vZGUsIHN2Zy1zaGFkb3csIGJveC1zaXppbmcsIGJvcmRlci1yYWRpdXMnLFxuXHRcdCdtb3onOiAnYW5pbWF0aW9uLWRlbGF5LCBhbmltYXRpb24tZGlyZWN0aW9uLCBhbmltYXRpb24tZHVyYXRpb24sIGFuaW1hdGlvbi1maWxsLW1vZGUsIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGFuaW1hdGlvbi1uYW1lLCBhbmltYXRpb24tcGxheS1zdGF0ZSwgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbiwgYXBwZWFyYW5jZSwgYmFja2ZhY2UtdmlzaWJpbGl0eSwgYmFja2dyb3VuZC1pbmxpbmUtcG9saWN5LCBiaW5kaW5nLCBib3JkZXItYm90dG9tLWNvbG9ycywgYm9yZGVyLWltYWdlLCBib3JkZXItbGVmdC1jb2xvcnMsIGJvcmRlci1yaWdodC1jb2xvcnMsIGJvcmRlci10b3AtY29sb3JzLCBib3gtYWxpZ24sIGJveC1kaXJlY3Rpb24sIGJveC1mbGV4LCBib3gtb3JkaW5hbC1ncm91cCwgYm94LW9yaWVudCwgYm94LXBhY2ssIGJveC1zaGFkb3csIGJveC1zaXppbmcsIGNvbHVtbi1jb3VudCwgY29sdW1uLWdhcCwgY29sdW1uLXJ1bGUtY29sb3IsIGNvbHVtbi1ydWxlLXN0eWxlLCBjb2x1bW4tcnVsZS13aWR0aCwgY29sdW1uLXdpZHRoLCBmbG9hdC1lZGdlLCBmb250LWZlYXR1cmUtc2V0dGluZ3MsIGZvbnQtbGFuZ3VhZ2Utb3ZlcnJpZGUsIGZvcmNlLWJyb2tlbi1pbWFnZS1pY29uLCBoeXBoZW5zLCBpbWFnZS1yZWdpb24sIG9yaWVudCwgb3V0bGluZS1yYWRpdXMtYm90dG9tbGVmdCwgb3V0bGluZS1yYWRpdXMtYm90dG9tcmlnaHQsIG91dGxpbmUtcmFkaXVzLXRvcGxlZnQsIG91dGxpbmUtcmFkaXVzLXRvcHJpZ2h0LCBwZXJzcGVjdGl2ZSwgcGVyc3BlY3RpdmUtb3JpZ2luLCBzdGFjay1zaXppbmcsIHRhYi1zaXplLCB0ZXh0LWJsaW5rLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIHRleHQtZGVjb3JhdGlvbi1saW5lLCB0ZXh0LWRlY29yYXRpb24tc3R5bGUsIHRleHQtc2l6ZS1hZGp1c3QsIHRyYW5zZm9ybSwgdHJhbnNmb3JtLW9yaWdpbiwgdHJhbnNmb3JtLXN0eWxlLCB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLWRlbGF5LCB0cmFuc2l0aW9uLWR1cmF0aW9uLCB0cmFuc2l0aW9uLXByb3BlcnR5LCB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiwgdXNlci1mb2N1cywgdXNlci1pbnB1dCwgdXNlci1tb2RpZnksIHVzZXItc2VsZWN0LCB3aW5kb3ctc2hhZG93LCBiYWNrZ3JvdW5kLWNsaXAsIGJvcmRlci1yYWRpdXMnLFxuXHRcdCdtcyc6ICdhY2NlbGVyYXRvciwgYmFja2ZhY2UtdmlzaWJpbGl0eSwgYmFja2dyb3VuZC1wb3NpdGlvbi14LCBiYWNrZ3JvdW5kLXBvc2l0aW9uLXksIGJlaGF2aW9yLCBibG9jay1wcm9ncmVzc2lvbiwgYm94LWFsaWduLCBib3gtZGlyZWN0aW9uLCBib3gtZmxleCwgYm94LWxpbmUtcHJvZ3Jlc3Npb24sIGJveC1saW5lcywgYm94LW9yZGluYWwtZ3JvdXAsIGJveC1vcmllbnQsIGJveC1wYWNrLCBjb250ZW50LXpvb20tYm91bmRhcnksIGNvbnRlbnQtem9vbS1ib3VuZGFyeS1tYXgsIGNvbnRlbnQtem9vbS1ib3VuZGFyeS1taW4sIGNvbnRlbnQtem9vbS1jaGFpbmluZywgY29udGVudC16b29tLXNuYXAsIGNvbnRlbnQtem9vbS1zbmFwLXBvaW50cywgY29udGVudC16b29tLXNuYXAtdHlwZSwgY29udGVudC16b29taW5nLCBmaWx0ZXIsIGZsb3ctZnJvbSwgZmxvdy1pbnRvLCBmb250LWZlYXR1cmUtc2V0dGluZ3MsIGdyaWQtY29sdW1uLCBncmlkLWNvbHVtbi1hbGlnbiwgZ3JpZC1jb2x1bW4tc3BhbiwgZ3JpZC1jb2x1bW5zLCBncmlkLWxheWVyLCBncmlkLXJvdywgZ3JpZC1yb3ctYWxpZ24sIGdyaWQtcm93LXNwYW4sIGdyaWQtcm93cywgaGlnaC1jb250cmFzdC1hZGp1c3QsIGh5cGhlbmF0ZS1saW1pdC1jaGFycywgaHlwaGVuYXRlLWxpbWl0LWxpbmVzLCBoeXBoZW5hdGUtbGltaXQtem9uZSwgaHlwaGVucywgaW1lLW1vZGUsIGludGVycG9sYXRpb24tbW9kZSwgbGF5b3V0LWZsb3csIGxheW91dC1ncmlkLCBsYXlvdXQtZ3JpZC1jaGFyLCBsYXlvdXQtZ3JpZC1saW5lLCBsYXlvdXQtZ3JpZC1tb2RlLCBsYXlvdXQtZ3JpZC10eXBlLCBsaW5lLWJyZWFrLCBvdmVyZmxvdy1zdHlsZSwgcGVyc3BlY3RpdmUsIHBlcnNwZWN0aXZlLW9yaWdpbiwgcGVyc3BlY3RpdmUtb3JpZ2luLXgsIHBlcnNwZWN0aXZlLW9yaWdpbi15LCBzY3JvbGwtYm91bmRhcnksIHNjcm9sbC1ib3VuZGFyeS1ib3R0b20sIHNjcm9sbC1ib3VuZGFyeS1sZWZ0LCBzY3JvbGwtYm91bmRhcnktcmlnaHQsIHNjcm9sbC1ib3VuZGFyeS10b3AsIHNjcm9sbC1jaGFpbmluZywgc2Nyb2xsLXJhaWxzLCBzY3JvbGwtc25hcC1wb2ludHMteCwgc2Nyb2xsLXNuYXAtcG9pbnRzLXksIHNjcm9sbC1zbmFwLXR5cGUsIHNjcm9sbC1zbmFwLXgsIHNjcm9sbC1zbmFwLXksIHNjcm9sbGJhci1hcnJvdy1jb2xvciwgc2Nyb2xsYmFyLWJhc2UtY29sb3IsIHNjcm9sbGJhci1kYXJrc2hhZG93LWNvbG9yLCBzY3JvbGxiYXItZmFjZS1jb2xvciwgc2Nyb2xsYmFyLWhpZ2hsaWdodC1jb2xvciwgc2Nyb2xsYmFyLXNoYWRvdy1jb2xvciwgc2Nyb2xsYmFyLXRyYWNrLWNvbG9yLCB0ZXh0LWFsaWduLWxhc3QsIHRleHQtYXV0b3NwYWNlLCB0ZXh0LWp1c3RpZnksIHRleHQta2FzaGlkYS1zcGFjZSwgdGV4dC1vdmVyZmxvdywgdGV4dC1zaXplLWFkanVzdCwgdGV4dC11bmRlcmxpbmUtcG9zaXRpb24sIHRvdWNoLWFjdGlvbiwgdHJhbnNmb3JtLCB0cmFuc2Zvcm0tb3JpZ2luLCB0cmFuc2Zvcm0tb3JpZ2luLXgsIHRyYW5zZm9ybS1vcmlnaW4teSwgdHJhbnNmb3JtLW9yaWdpbi16LCB0cmFuc2Zvcm0tc3R5bGUsIHRyYW5zaXRpb24sIHRyYW5zaXRpb24tZGVsYXksIHRyYW5zaXRpb24tZHVyYXRpb24sIHRyYW5zaXRpb24tcHJvcGVydHksIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uLCB1c2VyLXNlbGVjdCwgd29yZC1icmVhaywgd29yZC13cmFwLCB3cmFwLWZsb3csIHdyYXAtbWFyZ2luLCB3cmFwLXRocm91Z2gsIHdyaXRpbmctbW9kZScsXG5cdFx0J28nOiAnZGFzaGJvYXJkLXJlZ2lvbiwgYW5pbWF0aW9uLCBhbmltYXRpb24tZGVsYXksIGFuaW1hdGlvbi1kaXJlY3Rpb24sIGFuaW1hdGlvbi1kdXJhdGlvbiwgYW5pbWF0aW9uLWZpbGwtbW9kZSwgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgYW5pbWF0aW9uLW5hbWUsIGFuaW1hdGlvbi1wbGF5LXN0YXRlLCBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uLCBib3JkZXItaW1hZ2UsIGxpbmssIGxpbmstc291cmNlLCBvYmplY3QtZml0LCBvYmplY3QtcG9zaXRpb24sIHRhYi1zaXplLCB0YWJsZS1iYXNlbGluZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm0tb3JpZ2luLCB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLWRlbGF5LCB0cmFuc2l0aW9uLWR1cmF0aW9uLCB0cmFuc2l0aW9uLXByb3BlcnR5LCB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiwgYWNjZXNza2V5LCBpbnB1dC1mb3JtYXQsIGlucHV0LXJlcXVpcmVkLCBtYXJxdWVlLWRpciwgbWFycXVlZS1sb29wLCBtYXJxdWVlLXNwZWVkLCBtYXJxdWVlLXN0eWxlJ1xuXHR9O1xuXHRcblx0Xy5lYWNoKHByb3BzLCBmdW5jdGlvbih2LCBrKSB7XG5cdFx0cHJlZnMuZGVmaW5lKCdjc3MuJyArIGsgKyAnUHJvcGVydGllcycsIHYsIGRlc2NUZW1wbGF0ZSh7dmVuZG9yOiBrfSkpO1xuXHRcdHByZWZzLmRlZmluZSgnY3NzLicgKyBrICsgJ1Byb3BlcnRpZXNBZGRvbicsICcnLCBkZXNjQWRkb25UZW1wbGF0ZSh7dmVuZG9yOiBrfSkpO1xuXHR9KTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLnVuaXRsZXNzUHJvcGVydGllcycsICd6LWluZGV4LCBsaW5lLWhlaWdodCwgb3BhY2l0eSwgZm9udC13ZWlnaHQsIHpvb20nLCBcblx0XHRcdCdUaGUgbGlzdCBvZiBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyDigIvigIttdXN0IG5vdCBjb250YWluIHVuaXRzLicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MuaW50VW5pdCcsICdweCcsICdEZWZhdWx0IHVuaXQgZm9yIGludGVnZXIgdmFsdWVzJyk7XG5cdHByZWZzLmRlZmluZSgnY3NzLmZsb2F0VW5pdCcsICdlbScsICdEZWZhdWx0IHVuaXQgZm9yIGZsb2F0IHZhbHVlcycpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3Mua2V5d29yZHMnLCAnYXV0bywgaW5oZXJpdCcsIFxuXHRcdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsaWQga2V5d29yZHMgdGhhdCBjYW4gYmUgdXNlZCBpbiBDU1MgYWJicmV2aWF0aW9ucy4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmtleXdvcmRBbGlhc2VzJywgJ2E6YXV0bywgaTppbmhlcml0LCBzOnNvbGlkLCBkYTpkYXNoZWQsIGRvOmRvdHRlZCwgdDp0cmFuc3BhcmVudCcsIFxuXHRcdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Yga2V5d29yZCBhbGlhc2VzLCB1c2VkIGluIENTUyBhYmJyZXZpYXRpb24uICdcblx0XHRcdCsgJ0VhY2ggYWxpYXMgc2hvdWxkIGJlIGRlZmluZWQgYXMgPGNvZGU+YWxpYXM6a2V5d29yZF9uYW1lPC9jb2RlPi4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLnVuaXRBbGlhc2VzJywgJ2U6ZW0sIHA6JSwgeDpleCwgcjpyZW0nLCBcblx0XHRcdCdBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHVuaXQgYWxpYXNlcywgdXNlZCBpbiBDU1MgYWJicmV2aWF0aW9uLiAnXG5cdFx0XHQrICdFYWNoIGFsaWFzIHNob3VsZCBiZSBkZWZpbmVkIGFzIDxjb2RlPmFsaWFzOnVuaXRfdmFsdWU8L2NvZGU+LicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdjc3MuY29sb3Iuc2hvcnQnLCB0cnVlLCBcblx0XHRcdCdTaG91bGQgY29sb3IgdmFsdWVzIGxpa2UgPGNvZGU+I2ZmZmZmZjwvY29kZT4gYmUgc2hvcnRlbmVkIHRvICdcblx0XHRcdCsgJzxjb2RlPiNmZmY8L2NvZGU+IGFmdGVyIGFiYnJldmlhdGlvbiB3aXRoIGNvbG9yIHdhcyBleHBhbmRlZC4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmNvbG9yLmNhc2UnLCAna2VlcCcsIFxuXHRcdFx0J0xldHRlciBjYXNlIG9mIGNvbG9yIHZhbHVlcyBnZW5lcmF0ZWQgYnkgYWJicmV2aWF0aW9ucyB3aXRoIGNvbG9yICdcblx0XHRcdCsgJyhsaWtlIDxjb2RlPmMjMDwvY29kZT4pLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIDxjb2RlPnVwcGVyPC9jb2RlPiwgJ1xuXHRcdFx0KyAnPGNvZGU+bG93ZXI8L2NvZGU+IGFuZCA8Y29kZT5rZWVwPC9jb2RlPi4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmZ1enp5U2VhcmNoJywgdHJ1ZSwgXG5cdFx0XHQnRW5hYmxlIGZ1enp5IHNlYXJjaCBhbW9uZyBDU1Mgc25pcHBldCBuYW1lcy4gV2hlbiBlbmFibGVkLCBldmVyeSAnIFxuXHRcdFx0KyAnPGVtPnVua25vd248L2VtPiBzbmlwcGV0IHdpbGwgYmUgc2NvcmVkIGFnYWluc3QgYXZhaWxhYmxlIHNuaXBwZXQgJ1xuXHRcdFx0KyAnbmFtZXMgKG5vdCB2YWx1ZXMgb3IgQ1NTIHByb3BlcnRpZXMhKS4gVGhlIG1hdGNoIHdpdGggYmVzdCBzY29yZSAnXG5cdFx0XHQrICd3aWxsIGJlIHVzZWQgdG8gcmVzb2x2ZSBzbmlwcGV0IHZhbHVlLiBGb3IgZXhhbXBsZSwgd2l0aCB0aGlzICcgXG5cdFx0XHQrICdwcmVmZXJlbmNlIGVuYWJsZWQsIHRoZSBmb2xsb3dpbmcgYWJicmV2aWF0aW9ucyBhcmUgZXF1YWw6ICdcblx0XHRcdCsgJzxjb2RlPm92Omg8L2NvZGU+ID09IDxjb2RlPm92LWg8L2NvZGU+ID09IDxjb2RlPm8taDwvY29kZT4gPT0gJ1xuXHRcdFx0KyAnPGNvZGU+b2g8L2NvZGU+Jyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5mdXp6eVNlYXJjaE1pblNjb3JlJywgMC4zLCBcblx0XHRcdCdUaGUgbWluaXVtIHNjb3JlIChmcm9tIDAgdG8gMSkgdGhhdCBmdXp6eS1tYXRjaGVkIGFiYnJldmlhdGlvbiBzaG91bGQgJyBcblx0XHRcdCsgJ2FjaGl2ZS4gTG93ZXIgdmFsdWVzIG1heSBwcm9kdWNlIG1hbnkgZmFsc2UtcG9zaXRpdmUgbWF0Y2hlcywgJ1xuXHRcdFx0KyAnaGlnaGVyIHZhbHVlcyBtYXkgcmVkdWNlIHBvc3NpYmxlIG1hdGNoZXMuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5hbGlnblZlbmRvcicsIGZhbHNlLCBcblx0XHRcdCdJZiBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4sIGFsbCBnZW5lcmF0ZWQgdmVuZG9yLXByZWZpeGVkIHByb3BlcnRpZXMgJyBcblx0XHRcdCsgJ3dpbGwgYmUgYWxpZ25lZCBieSByZWFsIHByb3BlcnR5IG5hbWUuJyk7XG5cdFxuXHRcblx0ZnVuY3Rpb24gaXNOdW1lcmljKGNoKSB7XG5cdFx0dmFyIGNvZGUgPSBjaCAmJiBjaC5jaGFyQ29kZUF0KDApO1xuXHRcdHJldHVybiAoY2ggJiYgY2ggPT0gJy4nIHx8IChjb2RlID4gNDcgJiYgY29kZSA8IDU4KSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBwcm92aWRlZCBzbmlwcGV0IGNvbnRhaW5zIG9ubHkgb25lIENTUyBwcm9wZXJ0eSBhbmQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzbmlwcGV0XG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTaW5nbGVQcm9wZXJ0eShzbmlwcGV0KSB7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRzbmlwcGV0ID0gdXRpbHMudHJpbShzbmlwcGV0KTtcblx0XHRcblx0XHQvLyBjaGVjayBpZiBpdCBkb2Vzbid0IGNvbnRhaW4gYSBjb21tZW50IGFuZCBhIG5ld2xpbmVcblx0XHRpZiAofnNuaXBwZXQuaW5kZXhPZignLyonKSB8fCAvW1xcblxccl0vLnRlc3Qoc25pcHBldCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gY2hlY2sgaWYgaXQncyBhIHZhbGlkIHNuaXBwZXQgZGVmaW5pdGlvblxuXHRcdGlmICghL15bYS16MC05XFwtXStcXHMqXFw6L2kudGVzdChzbmlwcGV0KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHRzbmlwcGV0ID0gcmVxdWlyZSgndGFiU3RvcHMnKS5wcm9jZXNzVGV4dChzbmlwcGV0LCB7XG5cdFx0XHRyZXBsYWNlQ2FyZXRzOiB0cnVlLFxuXHRcdFx0dGFic3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAndmFsdWUnO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiBzbmlwcGV0LnNwbGl0KCc6JykubGVuZ3RoID09IDI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIGFiYnJldmlhdGVkIHZhbHVlIHRvIGZpbmFsIENTUyBvbmVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZS5jaGFyQXQoMCkgPT0gJy0nICYmICEvXlxcLVtcXC5cXGRdLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eXFwtKy8sICcnKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHZhbHVlLmNoYXJBdCgwKSA9PSAnIycpIHtcblx0XHRcdHJldHVybiBub3JtYWxpemVIZXhDb2xvcih2YWx1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBnZXRLZXl3b3JkKHZhbHVlKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbm9ybWFsaXplSGV4Q29sb3IodmFsdWUpIHtcblx0XHR2YXIgaGV4ID0gdmFsdWUucmVwbGFjZSgvXiMrLywgJycpIHx8ICcwJztcblx0XHRpZiAoaGV4LnRvTG93ZXJDYXNlKCkgPT0gJ3QnKSB7XG5cdFx0XHRyZXR1cm4gJ3RyYW5zcGFyZW50Jztcblx0XHR9XG5cdFx0XG5cdFx0dmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3V0aWxzJykucmVwZWF0U3RyaW5nO1xuXHRcdHZhciBjb2xvciA9IG51bGw7XG5cdFx0c3dpdGNoIChoZXgubGVuZ3RoKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdGNvbG9yID0gcmVwZWF0KGhleCwgNik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjb2xvciA9IHJlcGVhdChoZXgsIDMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMzpcblx0XHRcdFx0Y29sb3IgPSBoZXguY2hhckF0KDApICsgaGV4LmNoYXJBdCgwKSArIGhleC5jaGFyQXQoMSkgKyBoZXguY2hhckF0KDEpICsgaGV4LmNoYXJBdCgyKSArIGhleC5jaGFyQXQoMik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRjb2xvciA9IGhleCArIGhleC5zdWJzdHIoMCwgMik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA1OlxuXHRcdFx0XHRjb2xvciA9IGhleCArIGhleC5jaGFyQXQoMCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29sb3IgPSBoZXguc3Vic3RyKDAsIDYpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBjb2xvciBtdXN0IGJlIHNob3J0ZW5lZD9cblx0XHRpZiAocHJlZnMuZ2V0KCdjc3MuY29sb3Iuc2hvcnQnKSkge1xuXHRcdFx0dmFyIHAgPSBjb2xvci5zcGxpdCgnJyk7XG5cdFx0XHRpZiAocFswXSA9PSBwWzFdICYmIHBbMl0gPT0gcFszXSAmJiBwWzRdID09IHBbNV0pIHtcblx0XHRcdFx0Y29sb3IgPSBwWzBdICsgcFsyXSArIHBbNF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHNob3VsZCB0cmFuc2Zvcm0gY2FzZT9cblx0XHRzd2l0Y2ggKHByZWZzLmdldCgnY3NzLmNvbG9yLmNhc2UnKSkge1xuXHRcdFx0Y2FzZSAndXBwZXInOlxuXHRcdFx0XHRjb2xvciA9IGNvbG9yLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbG93ZXInOlxuXHRcdFx0XHRjb2xvciA9IGNvbG9yLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gJyMnICsgY29sb3I7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdldEtleXdvcmQobmFtZSkge1xuXHRcdHZhciBhbGlhc2VzID0gcHJlZnMuZ2V0RGljdCgnY3NzLmtleXdvcmRBbGlhc2VzJyk7XG5cdFx0cmV0dXJuIG5hbWUgaW4gYWxpYXNlcyA/IGFsaWFzZXNbbmFtZV0gOiBuYW1lO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRVbml0KG5hbWUpIHtcblx0XHR2YXIgYWxpYXNlcyA9IHByZWZzLmdldERpY3QoJ2Nzcy51bml0QWxpYXNlcycpO1xuXHRcdHJldHVybiBuYW1lIGluIGFsaWFzZXMgPyBhbGlhc2VzW25hbWVdIDogbmFtZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNWYWxpZEtleXdvcmQoa2V5d29yZCkge1xuXHRcdHJldHVybiBfLmluY2x1ZGUocHJlZnMuZ2V0QXJyYXkoJ2Nzcy5rZXl3b3JkcycpLCBnZXRLZXl3b3JkKGtleXdvcmQpKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHBhc3NlZCBDU1MgcHJvcGVydHkgc3VwcG9ydCBzcGVjaWZpZWQgdmVuZG9yIHByZWZpeCBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcblx0ICovXG5cdGZ1bmN0aW9uIGhhc1ByZWZpeChwcm9wZXJ0eSwgcHJlZml4KSB7XG5cdFx0dmFyIGluZm8gPSB2ZW5kb3JQcmVmaXhlc1twcmVmaXhdO1xuXHRcdFxuXHRcdGlmICghaW5mbylcblx0XHRcdGluZm8gPSBfLmZpbmQodmVuZG9yUHJlZml4ZXMsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEucHJlZml4ID09IHByZWZpeDtcblx0XHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiBpbmZvICYmIGluZm8uc3VwcG9ydHMocHJvcGVydHkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU2VhcmNoIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHByZWZpeGVzIGZvciBDU1MgcHJvcGVydHkuIFRoaXMgbGlzdFxuXHQgKiBpcyB1c2VkIHRvIGdlbmVyYXRlIGFsbC1wcmVmaXhlZCBzbmlwcGV0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBDU1MgcHJvcGVydHkgbmFtZVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kUHJlZml4ZXMocHJvcGVydHksIG5vQXV0b2ZpbGwpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Xy5lYWNoKHZlbmRvclByZWZpeGVzLCBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuXHRcdFx0aWYgKGhhc1ByZWZpeChwcm9wZXJ0eSwgcHJlZml4KSkge1xuXHRcdFx0XHRyZXN1bHQucHVzaChwcmVmaXgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdGlmICghcmVzdWx0Lmxlbmd0aCAmJiAhbm9BdXRvZmlsbCkge1xuXHRcdFx0Ly8gYWRkIGFsbCBub24tb2Jzb2xldGUgcHJlZml4ZXNcblx0XHRcdF8uZWFjaCh2ZW5kb3JQcmVmaXhlcywgZnVuY3Rpb24ob2JqLCBwcmVmaXgpIHtcblx0XHRcdFx0aWYgKCFvYmoub2Jzb2xldGUpXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2gocHJlZml4KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhZGRQcmVmaXgobmFtZSwgb2JqKSB7XG5cdFx0aWYgKF8uaXNTdHJpbmcob2JqKSlcblx0XHRcdG9iaiA9IHtwcmVmaXg6IG9ian07XG5cdFx0XG5cdFx0dmVuZG9yUHJlZml4ZXNbbmFtZV0gPSBfLmV4dGVuZCh7fSwgcHJlZml4T2JqLCBvYmopO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRTeW50YXhQcmVmZXJlbmNlKG5hbWUsIHN5bnRheCkge1xuXHRcdGlmIChzeW50YXgpIHtcblx0XHRcdHZhciB2YWwgPSBwcmVmcy5nZXQoc3ludGF4ICsgJy4nICsgbmFtZSk7XG5cdFx0XHRpZiAoIV8uaXNVbmRlZmluZWQodmFsKSlcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHByZWZzLmdldCgnY3NzLicgKyBuYW1lKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEZvcm1hdCBDU1MgcHJvcGVydHkgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc3ludGF4IGRpYWxlY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KHByb3BlcnR5LCBzeW50YXgpIHtcblx0XHR2YXIgaXggPSBwcm9wZXJ0eS5pbmRleE9mKCc6Jyk7XG5cdFx0cHJvcGVydHkgPSBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgaXgpLnJlcGxhY2UoL1xccyskLywgJycpIFxuXHRcdFx0KyBnZXRTeW50YXhQcmVmZXJlbmNlKCd2YWx1ZVNlcGFyYXRvcicsIHN5bnRheClcblx0XHRcdCsgcmVxdWlyZSgndXRpbHMnKS50cmltKHByb3BlcnR5LnN1YnN0cmluZyhpeCArIDEpKTtcblx0XHRcblx0XHRyZXR1cm4gcHJvcGVydHkucmVwbGFjZSgvXFxzKjtcXHMqJC8sIGdldFN5bnRheFByZWZlcmVuY2UoJ3Byb3BlcnR5RW5kJywgc3ludGF4KSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHNuaXBwZXQgdmFsdWUgaWYgcmVxdWlyZWQuIEZvciBleGFtcGxlLCB0aGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIG1heSBhZGQgPGk+IWltcG9ydGFudDwvaT4gZGVjbGFyYXRpb24gdG8gQ1NTIHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzbmlwcGV0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbXBvcnRhbnRcblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVNuaXBwZXQoc25pcHBldCwgaXNJbXBvcnRhbnQsIHN5bnRheCkge1xuXHRcdGlmICghXy5pc1N0cmluZyhzbmlwcGV0KSlcblx0XHRcdHNuaXBwZXQgPSBzbmlwcGV0LmRhdGE7XG5cdFx0XG5cdFx0aWYgKCFpc1NpbmdsZVByb3BlcnR5KHNuaXBwZXQpKVxuXHRcdFx0cmV0dXJuIHNuaXBwZXQ7XG5cdFx0XG5cdFx0aWYgKGlzSW1wb3J0YW50KSB7XG5cdFx0XHRpZiAofnNuaXBwZXQuaW5kZXhPZignOycpKSB7XG5cdFx0XHRcdHNuaXBwZXQgPSBzbmlwcGV0LnNwbGl0KCc7Jykuam9pbignICFpbXBvcnRhbnQ7Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzbmlwcGV0ICs9ICcgIWltcG9ydGFudCc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmb3JtYXRQcm9wZXJ0eShzbmlwcGV0LCBzeW50YXgpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGVsZW1lbnRzIGludG8gYXJyYXlcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxpc3Rcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VMaXN0KGxpc3QpIHtcblx0XHR2YXIgcmVzdWx0ID0gXy5tYXAoKGxpc3QgfHwgJycpLnNwbGl0KCcsJyksIHJlcXVpcmUoJ3V0aWxzJykudHJpbSk7XG5cdFx0cmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKGtleSkge1xuXHRcdHZhciBsaXN0ID0gcHJlZnMuZ2V0QXJyYXkoa2V5KTtcblx0XHRfLmVhY2gocHJlZnMuZ2V0QXJyYXkoa2V5ICsgJ0FkZG9uJyksIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdGlmIChwcm9wLmNoYXJBdCgwKSA9PSAnLScpIHtcblx0XHRcdFx0bGlzdCA9IF8ud2l0aG91dChsaXN0LCBwcm9wLnN1YnN0cigxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocHJvcC5jaGFyQXQoMCkgPT0gJysnKVxuXHRcdFx0XHRcdHByb3AgPSBwcm9wLnN1YnN0cigxKTtcblx0XHRcdFx0XG5cdFx0XHRcdGxpc3QucHVzaChwcm9wKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gbGlzdDtcblx0fVxuXHRcblx0XG5cdC8vIFRPRE8gcmVmYWN0b3IsIHRoaXMgbG9va3MgYXdrd2FyZCBub3dcblx0YWRkUHJlZml4KCd3Jywge1xuXHRcdHByZWZpeDogJ3dlYmtpdCdcblx0fSk7XG5cdGFkZFByZWZpeCgnbScsIHtcblx0XHRwcmVmaXg6ICdtb3onXG5cdH0pO1xuXHRhZGRQcmVmaXgoJ3MnLCB7XG5cdFx0cHJlZml4OiAnbXMnXG5cdH0pO1xuXHRhZGRQcmVmaXgoJ28nLCB7XG5cdFx0cHJlZml4OiAnbydcblx0fSk7XG5cdFxuXHQvLyBJIHRoaW5rIG5vYm9keSB1c2VzIGl0XG4vL1x0YWRkUHJlZml4KCdrJywge1xuLy9cdFx0cHJlZml4OiAna2h0bWwnLFxuLy9cdFx0b2Jzb2xldGU6IHRydWVcbi8vXHR9KTtcblx0XG5cdHZhciBjc3NTeW50YXhlcyA9IFsnY3NzJywgJ2xlc3MnLCAnc2FzcycsICdzY3NzJywgJ3N0eWx1cyddO1xuXHRcblx0LyoqXG5cdCAqIFhYWCByZWdpc3RlciByZXNvbHZlclxuXHQgKiBAcGFyYW0ge1RyZWVOb2RlfSBub2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICovXG5cdHJlcXVpcmUoJ3Jlc291cmNlcycpLmFkZFJlc29sdmVyKGZ1bmN0aW9uKG5vZGUsIHN5bnRheCkge1xuXHRcdGlmIChfLmluY2x1ZGUoY3NzU3ludGF4ZXMsIHN5bnRheCkgJiYgbm9kZS5pc0VsZW1lbnQoKSkge1xuXHRcdFx0cmV0dXJuIG1vZHVsZS5leHBhbmRUb1NuaXBwZXQobm9kZS5hYmJyZXZpYXRpb24sIHN5bnRheCk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9KTtcblx0XG5cdHZhciBlYSA9IHJlcXVpcmUoJ2V4cGFuZEFiYnJldmlhdGlvbicpO1xuXHQvKipcblx0ICogRm9yIENTUy1saWtlIHN5bnRheGVzLCB3ZSBuZWVkIHRvIGhhbmRsZSBhIHNwZWNpYWwgdXNlIGNhc2UuIFNvbWUgZWRpdG9yc1xuXHQgKiAobGlrZSBTdWJsaW1lIFRleHQgMikgbWF5IGluc2VydCBzZW1pY29sb25zIGF1dG9tYXRpY2FsbHkgd2hlbiB1c2VyIHR5cGVzXG5cdCAqIGFiYnJldmlhdGlvbi4gQWZ0ZXIgZXhwYW5zaW9uLCB1c2VyIHJlY2VpdmVzIGEgZG91YmxlIHNlbWljb2xvbi4gVGhpc1xuXHQgKiBoYW5kbGVyIGF1dG9tYXRpY2FsbHkgcmVtb3ZlcyBzZW1pY29sb24gZnJvbSBnZW5lcmF0ZWQgY29udGVudCBpbiBzdWNoIGNhc2VzLlxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGVcblx0ICovXG5cdGVhLmFkZEhhbmRsZXIoZnVuY3Rpb24oZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHRpZiAoIV8uaW5jbHVkZShjc3NTeW50YXhlcywgc3ludGF4KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgY2FyZXRQb3MgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKS5lbmQ7XG5cdFx0dmFyIGFiYnIgPSBlYS5maW5kQWJicmV2aWF0aW9uKGVkaXRvcik7XG5cdFx0XHRcblx0XHRpZiAoYWJicikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBlbW1ldC5leHBhbmRBYmJyZXZpYXRpb24oYWJiciwgc3ludGF4LCBwcm9maWxlKTtcblx0XHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRcdHZhciByZXBsYWNlRnJvbSA9IGNhcmV0UG9zIC0gYWJici5sZW5ndGg7XG5cdFx0XHRcdHZhciByZXBsYWNlVG8gPSBjYXJldFBvcztcblx0XHRcdFx0aWYgKGVkaXRvci5nZXRDb250ZW50KCkuY2hhckF0KGNhcmV0UG9zKSA9PSAnOycgJiYgY29udGVudC5jaGFyQXQoY29udGVudC5sZW5ndGggLSAxKSA9PSAnOycpIHtcblx0XHRcdFx0XHRyZXBsYWNlVG8rKztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGNvbnRlbnQsIHJlcGxhY2VGcm9tLCByZXBsYWNlVG8pO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KTtcblx0XG5cdHJldHVybiBtb2R1bGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQWRkcyB2ZW5kb3IgcHJlZml4XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgT25lLWNoYXJhY3RlciBwcmVmaXggbmFtZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IGRlc2NyaWJpbmcgdmVuZG9yIHByZWZpeFxuXHRcdCAqIEBtZW1iZXJPZiBjc3NSZXNvbHZlclxuXHRcdCAqL1xuXHRcdGFkZFByZWZpeDogYWRkUHJlZml4LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIHBhc3NlZCBDU1MgcHJvcGVydHkgc3VwcG9ydHMgc3BlY2lmaWVkIHZlbmRvciBwcmVmaXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG5cdFx0ICovXG5cdFx0c3VwcG9ydHNQcmVmaXg6IGhhc1ByZWZpeCxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHByZWZpeGVkIHZlcnNpb24gb2YgcGFzc2VkIENTUyBwcm9wZXJ0eSwgb25seSBpZiB0aGlzXG5cdFx0ICogcHJvcGVydHkgc3VwcG9ydHMgc3VjaCBwcmVmaXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG5cdFx0ICogQHJldHVybnNcblx0XHQgKi9cblx0XHRwcmVmaXhlZDogZnVuY3Rpb24ocHJvcGVydHksIHByZWZpeCkge1xuXHRcdFx0cmV0dXJuIGhhc1ByZWZpeChwcm9wZXJ0eSwgcHJlZml4KSBcblx0XHRcdFx0PyAnLScgKyBwcmVmaXggKyAnLScgKyBwcm9wZXJ0eSBcblx0XHRcdFx0OiBwcm9wZXJ0eTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgbGlzdCBvZiBhbGwgcmVnaXN0ZXJlZCB2ZW5kb3IgcHJlZml4ZXNcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0bGlzdFByZWZpeGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfLm1hcCh2ZW5kb3JQcmVmaXhlcywgZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBvYmoucHJlZml4O1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG9iamVjdCBkZXNjcmliaW5nIHZlbmRvciBwcmVmaXhcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0UHJlZml4OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdmVuZG9yUHJlZml4ZXNbbmFtZV07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHByZWZpeCBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHRcdCAqL1xuXHRcdHJlbW92ZVByZWZpeDogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0aWYgKG5hbWUgaW4gdmVuZG9yUHJlZml4ZXMpXG5cdFx0XHRcdGRlbGV0ZSB2ZW5kb3JQcmVmaXhlc1tuYW1lXTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dHJhY3QgdmVuZG9yIHByZWZpeGVzIGZyb20gYWJicmV2aWF0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBhcnJheSBvZiBwcmVmaXhlcyBhbmQgY2xlYW4gXG5cdFx0ICogYWJicmV2aWF0aW9uIG5hbWVcblx0XHQgKi9cblx0XHRleHRyYWN0UHJlZml4ZXM6IGZ1bmN0aW9uKGFiYnIpIHtcblx0XHRcdGlmIChhYmJyLmNoYXJBdCgwKSAhPSAnLScpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRwcm9wZXJ0eTogYWJicixcblx0XHRcdFx0XHRwcmVmaXhlczogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBhYmJyZXZpYXRpb24gbWF5IGVpdGhlciBjb250YWluIHNlcXVlbmNlIG9mIG9uZS1jaGFyYWN0ZXIgcHJlZml4ZXNcblx0XHRcdC8vIG9yIGp1c3QgZGFzaCwgbWVhbmluZyB0aGF0IHVzZXIgd2FudHMgdG8gcHJvZHVjZSBhbGwgcG9zc2libGVcblx0XHRcdC8vIHByZWZpeGVkIHByb3BlcnRpZXNcblx0XHRcdHZhciBpID0gMSwgaWwgPSBhYmJyLmxlbmd0aCwgY2g7XG5cdFx0XHR2YXIgcHJlZml4ZXMgPSBbXTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdFx0XHRjaCA9IGFiYnIuY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAoY2ggPT0gJy0nKSB7XG5cdFx0XHRcdFx0Ly8gZW5kLXNlcXVlbmNlIGNoYXJhY3RlciBmb3VuZCwgc3RvcCBzZWFyY2hpbmdcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaCBpbiB2ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHByZWZpeGVzLnB1c2goY2gpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG5vIHByZWZpeCBmb3VuZCwgbWVhbmluZyB1c2VyIHdhbnQgdG8gcHJvZHVjZSBhbGxcblx0XHRcdFx0XHQvLyB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydGllc1xuXHRcdFx0XHRcdHByZWZpeGVzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0aSA9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gcmVhY2hlZCBlbmQgb2YgYWJicmV2aWF0aW9uIGFuZCBubyBwcm9wZXJ0eSBuYW1lIGxlZnRcblx0XHRcdGlmIChpID09IGlsIC0xKSB7XG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0XHRwcmVmaXhlcy5sZW5ndGggPSAxO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwcm9wZXJ0eTogYWJici5zdWJzdHJpbmcoaSksXG5cdFx0XHRcdHByZWZpeGVzOiBwcmVmaXhlcy5sZW5ndGggPyBwcmVmaXhlcyA6ICdhbGwnXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VhcmNoIGZvciB2YWx1ZSBzdWJzdHJpbmcgaW4gYWJicmV2aWF0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfSBWYWx1ZSBzdWJzdHJpbmdcblx0XHQgKi9cblx0XHRmaW5kVmFsdWVzSW5BYmJyZXZpYXRpb246IGZ1bmN0aW9uKGFiYnIsIHN5bnRheCkge1xuXHRcdFx0c3ludGF4ID0gc3ludGF4IHx8ICdjc3MnO1xuXHRcdFx0XG5cdFx0XHR2YXIgaSA9IDAsIGlsID0gYWJici5sZW5ndGgsIHZhbHVlID0gJycsIGNoO1xuXHRcdFx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdFx0XHRjaCA9IGFiYnIuY2hhckF0KGkpO1xuXHRcdFx0XHRpZiAoaXNOdW1lcmljKGNoKSB8fCBjaCA9PSAnIycgfHwgKGNoID09ICctJyAmJiBpc051bWVyaWMoYWJici5jaGFyQXQoaSArIDEpKSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGFiYnIuc3Vic3RyaW5nKGkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpKys7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIHRyeSB0byBmaW5kIGtleXdvcmRzIGluIGFiYnJldmlhdGlvblxuXHRcdFx0dmFyIHByb3BlcnR5ID0gYWJici5zdWJzdHJpbmcoMCwgYWJici5sZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuXHRcdFx0dmFyIHJlcyA9IHJlcXVpcmUoJ3Jlc291cmNlcycpO1xuXHRcdFx0dmFyIGtleXdvcmRzID0gW107XG5cdFx0XHQvLyB0cnkgdG8gZXh0cmFjdCBzb21lIGNvbW1vbmx5LXVzZWQgcHJvcGVydGllc1xuXHRcdFx0d2hpbGUgKH5wcm9wZXJ0eS5pbmRleE9mKCctJykgJiYgIXJlcy5maW5kU25pcHBldChzeW50YXgsIHByb3BlcnR5KSkge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLScpO1xuXHRcdFx0XHR2YXIgbGFzdFBhcnQgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCFpc1ZhbGlkS2V5d29yZChsYXN0UGFydCkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0a2V5d29yZHMudW5zaGlmdChsYXN0UGFydCk7XG5cdFx0XHRcdHByb3BlcnR5ID0gcGFydHMuam9pbignLScpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4ga2V5d29yZHMuam9pbignLScpICsgdmFsdWU7XG5cdFx0fSxcblx0XHRcblx0XHRwYXJzZVZhbHVlczogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHQvKiogQHR5cGUgU3RyaW5nU3RyZWFtICovXG5cdFx0XHR2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyaW5nU3RyZWFtJykuY3JlYXRlKHN0cik7XG5cdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHR2YXIgY2ggPSBudWxsO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG5cdFx0XHRcdGlmIChjaCA9PSAnIycpIHtcblx0XHRcdFx0XHRzdHJlYW0ubWF0Y2goL150fFswLTlhLWZdKy9pLCB0cnVlKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChzdHJlYW0uY3VycmVudCgpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PSAnLScpIHtcblx0XHRcdFx0XHRpZiAoaXNWYWxpZEtleXdvcmQoXy5sYXN0KHZhbHVlcykpIHx8IFxuXHRcdFx0XHRcdFx0XHQoIHN0cmVhbS5zdGFydCAmJiBpc051bWVyaWMoc3RyLmNoYXJBdChzdHJlYW0uc3RhcnQgLSAxKSkgKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzdHJlYW0ubWF0Y2goL15cXC0/WzAtOV0qKFxcLlswLTldKyk/W2EteiVcXC5dKi8sIHRydWUpO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHN0cmVhbS5jdXJyZW50KCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmVhbS5tYXRjaCgvXlswLTldKihcXC5bMC05XSopP1thLXolXSovLCB0cnVlKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChzdHJlYW0uY3VycmVudCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIF8ubWFwKF8uY29tcGFjdCh2YWx1ZXMpLCBub3JtYWxpemVWYWx1ZSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyB2YWx1ZXMgZnJvbSBhYmJyZXZpYXRpb25cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiclxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIGFycmF5IG9mIHZhbHVlcyBhbmQgY2xlYW4gXG5cdFx0ICogYWJicmV2aWF0aW9uIG5hbWVcblx0XHQgKi9cblx0XHRleHRyYWN0VmFsdWVzOiBmdW5jdGlvbihhYmJyKSB7XG5cdFx0XHQvLyBzZWFyY2ggZm9yIHZhbHVlIHN0YXJ0XG5cdFx0XHR2YXIgYWJiclZhbHVlcyA9IHRoaXMuZmluZFZhbHVlc0luQWJicmV2aWF0aW9uKGFiYnIpO1xuXHRcdFx0aWYgKCFhYmJyVmFsdWVzKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cHJvcGVydHk6IGFiYnIsXG5cdFx0XHRcdFx0dmFsdWVzOiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHByb3BlcnR5OiBhYmJyLnN1YnN0cmluZygwLCBhYmJyLmxlbmd0aCAtIGFiYnJWYWx1ZXMubGVuZ3RoKS5yZXBsYWNlKC8tJC8sICcnKSxcblx0XHRcdFx0dmFsdWVzOiB0aGlzLnBhcnNlVmFsdWVzKGFiYnJWYWx1ZXMpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTm9ybWFsaXplcyB2YWx1ZSwgZGVmaW5lZCBpbiBhYmJyZXZpYXRpb24uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRub3JtYWxpemVWYWx1ZTogZnVuY3Rpb24odmFsdWUsIHByb3BlcnR5KSB7XG5cdFx0XHRwcm9wZXJ0eSA9IChwcm9wZXJ0eSB8fCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB1bml0bGVzc1Byb3BzID0gcHJlZnMuZ2V0QXJyYXkoJ2Nzcy51bml0bGVzc1Byb3BlcnRpZXMnKTtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eKFxcLT9bMC05XFwuXSspKFthLXpdKikkLywgZnVuY3Rpb24oc3RyLCB2YWwsIHVuaXQpIHtcblx0XHRcdFx0aWYgKCF1bml0ICYmICh2YWwgPT0gJzAnIHx8IF8uaW5jbHVkZSh1bml0bGVzc1Byb3BzLCBwcm9wZXJ0eSkpKVxuXHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXVuaXQpXG5cdFx0XHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKC9cXC4kLywgJycpICsgcHJlZnMuZ2V0KH52YWwuaW5kZXhPZignLicpID8gJ2Nzcy5mbG9hdFVuaXQnIDogJ2Nzcy5pbnRVbml0Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdmFsICsgZ2V0VW5pdCh1bml0KTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXhwYW5kcyBhYmJyZXZpYXRpb24gaW50byBhIHNuaXBwZXRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gYWJiciBBYmJyZXZpYXRpb24gbmFtZSB0byBleHBhbmRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQWJicmV2aWF0aW9uIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN5bnRheCBDdXJyZWN0IHN5bnRheCBvciBkaWFsZWN0LiBEZWZhdWx0IGlzICdjc3MnXG5cdFx0ICogQHJldHVybnMge09iamVjdH0gQXJyYXkgb2YgQ1NTIHByb3BlcnRpZXMgYW5kIHZhbHVlcyBvciBwcmVkZWZpbmVkXG5cdFx0ICogc25pcHBldCAoc3RyaW5nIG9yIGVsZW1lbnQpXG5cdFx0ICovXG5cdFx0ZXhwYW5kOiBmdW5jdGlvbihhYmJyLCB2YWx1ZSwgc3ludGF4KSB7XG5cdFx0XHRzeW50YXggPSBzeW50YXggfHwgJ2Nzcyc7XG5cdFx0XHR2YXIgcmVzb3VyY2VzID0gcmVxdWlyZSgncmVzb3VyY2VzJyk7XG5cdFx0XHR2YXIgYXV0b0luc2VydFByZWZpeGVzID0gcHJlZnMuZ2V0KCdjc3MuYXV0b0luc2VydFZlbmRvclByZWZpeGVzJyk7XG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGlmIHNuaXBwZXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIHRvICFpbXBvcnRhbnRcblx0XHRcdHZhciBpc0ltcG9ydGFudDtcblx0XHRcdGlmIChpc0ltcG9ydGFudCA9IC9eKC4rKVxcISQvLnRlc3QoYWJicikpIHtcblx0XHRcdFx0YWJiciA9IFJlZ0V4cC4kMTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSBhYmJyZXZpYXRlZCByZXNvdXJjZVxuXHRcdFx0dmFyIHNuaXBwZXQgPSByZXNvdXJjZXMuZmluZFNuaXBwZXQoc3ludGF4LCBhYmJyKTtcblx0XHRcdGlmIChzbmlwcGV0ICYmICFhdXRvSW5zZXJ0UHJlZml4ZXMpIHtcblx0XHRcdFx0cmV0dXJuIHRyYW5zZm9ybVNuaXBwZXQoc25pcHBldCwgaXNJbXBvcnRhbnQsIHN5bnRheCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIG5vIGFiYnJldmlhdGVkIHJlc291cmNlLCBwYXJzZSBhYmJyZXZpYXRpb25cblx0XHRcdHZhciBwcmVmaXhEYXRhID0gdGhpcy5leHRyYWN0UHJlZml4ZXMoYWJicik7XG5cdFx0XHR2YXIgdmFsdWVzRGF0YSA9IHRoaXMuZXh0cmFjdFZhbHVlcyhwcmVmaXhEYXRhLnByb3BlcnR5KTtcblx0XHRcdHZhciBhYmJyRGF0YSA9IF8uZXh0ZW5kKHByZWZpeERhdGEsIHZhbHVlc0RhdGEpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXNuaXBwZXQpIHtcblx0XHRcdFx0c25pcHBldCA9IHJlc291cmNlcy5maW5kU25pcHBldChzeW50YXgsIGFiYnJEYXRhLnByb3BlcnR5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFiYnJEYXRhLnZhbHVlcyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghc25pcHBldCAmJiBwcmVmcy5nZXQoJ2Nzcy5mdXp6eVNlYXJjaCcpKSB7XG5cdFx0XHRcdC8vIGxldOKAmXMgdHJ5IGZ1enp5IHNlYXJjaFxuXHRcdFx0XHRzbmlwcGV0ID0gcmVzb3VyY2VzLmZ1enp5RmluZFNuaXBwZXQoc3ludGF4LCBhYmJyRGF0YS5wcm9wZXJ0eSwgcGFyc2VGbG9hdChwcmVmcy5nZXQoJ2Nzcy5mdXp6eVNlYXJjaE1pblNjb3JlJykpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFzbmlwcGV0KSB7XG5cdFx0XHRcdHNuaXBwZXQgPSBhYmJyRGF0YS5wcm9wZXJ0eSArICc6JyArIGRlZmF1bHRWYWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAoIV8uaXNTdHJpbmcoc25pcHBldCkpIHtcblx0XHRcdFx0c25pcHBldCA9IHNuaXBwZXQuZGF0YTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFpc1NpbmdsZVByb3BlcnR5KHNuaXBwZXQpKSB7XG5cdFx0XHRcdHJldHVybiBzbmlwcGV0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgc25pcHBldE9iaiA9IHRoaXMuc3BsaXRTbmlwcGV0KHNuaXBwZXQpO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0aWYgKCF2YWx1ZSAmJiBhYmJyRGF0YS52YWx1ZXMpIHtcblx0XHRcdFx0dmFsdWUgPSBfLm1hcChhYmJyRGF0YS52YWx1ZXMsIGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbCwgc25pcHBldE9iai5uYW1lKTtcblx0XHRcdFx0fSwgdGhpcykuam9pbignICcpICsgJzsnO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRzbmlwcGV0T2JqLnZhbHVlID0gdmFsdWUgfHwgc25pcHBldE9iai52YWx1ZTtcblx0XHRcdFxuXHRcdFx0dmFyIHByZWZpeGVzID0gYWJickRhdGEucHJlZml4ZXMgPT0gJ2FsbCcgfHwgKCFhYmJyRGF0YS5wcmVmaXhlcyAmJiBhdXRvSW5zZXJ0UHJlZml4ZXMpIFxuXHRcdFx0XHQ/IGZpbmRQcmVmaXhlcyhzbmlwcGV0T2JqLm5hbWUsIGF1dG9JbnNlcnRQcmVmaXhlcyAmJiBhYmJyRGF0YS5wcmVmaXhlcyAhPSAnYWxsJylcblx0XHRcdFx0OiBhYmJyRGF0YS5wcmVmaXhlcztcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0dmFyIG5hbWVzID0gW10sIHByb3BOYW1lO1xuXHRcdFx0Xy5lYWNoKHByZWZpeGVzLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwIGluIHZlbmRvclByZWZpeGVzKSB7XG5cdFx0XHRcdFx0cHJvcE5hbWUgPSB2ZW5kb3JQcmVmaXhlc1twXS50cmFuc2Zvcm1OYW1lKHNuaXBwZXRPYmoubmFtZSk7XG5cdFx0XHRcdFx0bmFtZXMucHVzaChwcm9wTmFtZSk7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2godHJhbnNmb3JtU25pcHBldChwcm9wTmFtZSArICc6JyArIHNuaXBwZXRPYmoudmFsdWUsXG5cdFx0XHRcdFx0XHRcdGlzSW1wb3J0YW50LCBzeW50YXgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIHB1dCB0aGUgb3JpZ2luYWwgcHJvcGVydHlcblx0XHRcdHJlc3VsdC5wdXNoKHRyYW5zZm9ybVNuaXBwZXQoc25pcHBldE9iai5uYW1lICsgJzonICsgc25pcHBldE9iai52YWx1ZSwgaXNJbXBvcnRhbnQsIHN5bnRheCkpO1xuXHRcdFx0bmFtZXMucHVzaChzbmlwcGV0T2JqLm5hbWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAocHJlZnMuZ2V0KCdjc3MuYWxpZ25WZW5kb3InKSkge1xuXHRcdFx0XHR2YXIgcGFkcyA9IHJlcXVpcmUoJ3V0aWxzJykuZ2V0U3RyaW5nc1BhZHMobmFtZXMpO1xuXHRcdFx0XHRyZXN1bHQgPSBfLm1hcChyZXN1bHQsIGZ1bmN0aW9uKHByb3AsIGkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFkc1tpXSArIHByb3A7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2FtZSBhcyA8Y29kZT5leHBhbmQ8L2NvZGU+IG1ldGhvZCBidXQgdHJhbnNmb3JtcyBvdXRwdXQgaW50byBcblx0XHQgKiBFbW1ldCBzbmlwcGV0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGFiYnJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3ludGF4XG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRleHBhbmRUb1NuaXBwZXQ6IGZ1bmN0aW9uKGFiYnIsIHN5bnRheCkge1xuXHRcdFx0dmFyIHNuaXBwZXQgPSB0aGlzLmV4cGFuZChhYmJyLCBudWxsLCBzeW50YXgpO1xuXHRcdFx0aWYgKF8uaXNBcnJheShzbmlwcGV0KSkge1xuXHRcdFx0XHRyZXR1cm4gc25pcHBldC5qb2luKCdcXG4nKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFfLmlzU3RyaW5nKHNuaXBwZXQpKVxuXHRcdFx0XHRyZXR1cm4gc25pcHBldC5kYXRhO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHNuaXBwZXQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3BsaXQgc25pcHBldCBpbnRvIGEgQ1NTIHByb3BlcnR5LXZhbHVlIHBhaXJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc25pcHBldFxuXHRcdCAqL1xuXHRcdHNwbGl0U25pcHBldDogZnVuY3Rpb24oc25pcHBldCkge1xuXHRcdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcdHNuaXBwZXQgPSB1dGlscy50cmltKHNuaXBwZXQpO1xuXHRcdFx0aWYgKHNuaXBwZXQuaW5kZXhPZignOicpID09IC0xKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bmFtZTogc25pcHBldCxcblx0XHRcdFx0XHR2YWx1ZTogZGVmYXVsdFZhbHVlXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBwYWlyID0gc25pcHBldC5zcGxpdCgnOicpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRuYW1lOiB1dGlscy50cmltKHBhaXIuc2hpZnQoKSksXG5cdFx0XHRcdC8vIHJlcGxhY2UgJHswfSB0YWJzdG9wIHRvIHByb2R1Y2UgdmFsaWQgdmVuZG9yLXByZWZpeGVkIHZhbHVlc1xuXHRcdFx0XHQvLyB3aGVyZSBwb3NzaWJsZVxuXHRcdFx0XHR2YWx1ZTogdXRpbHMudHJpbShwYWlyLmpvaW4oJzonKSkucmVwbGFjZSgvXihcXCRcXHswXFx9fFxcJDApKFxccyo7PykkLywgJyR7MX0kMicpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0XG5cdFx0Z2V0U3ludGF4UHJlZmVyZW5jZTogZ2V0U3ludGF4UHJlZmVyZW5jZSxcblx0XHR0cmFuc2Zvcm1TbmlwcGV0OiB0cmFuc2Zvcm1TbmlwcGV0XG5cdH07XG59KTtcbi8qKlxuICogJ0V4cGFuZCBBYmJyZXZpYXRpb24nIGhhbmRsZXIgdGhhdCBwYXJzZXMgZ3JhZGllbnQgZGVmaW5pdGlvbiBmcm9tIHVuZGVyIFxuICogY3Vyc29yIGFuZCB1cGRhdGVzIENTUyBydWxlIHdpdGggdmVuZG9yLXByZWZpeGVkIHZhbHVlcy5cbiAqIFxuICogQG1lbWJlck9mIF9fY3NzR3JhZGllbnRIYW5kbGVyRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZGVmaW5lKCdjc3NHcmFkaWVudCcsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIGRlZmF1bHRMaW5lYXJEaXJlY3Rpb25zID0gWyd0b3AnLCAndG8gYm90dG9tJywgJzBkZWcnXTtcblx0LyoqIEJhY2stcmVmZXJlbmNlIHRvIGN1cnJlbnQgbW9kdWxlICovXG5cdHZhciBtb2R1bGUgPSBudWxsO1xuXHRcblx0dmFyIGNzc1N5bnRheGVzID0gWydjc3MnLCAnbGVzcycsICdzYXNzJywgJ3Njc3MnLCAnc3R5bHVzJywgJ3N0eWwnXTtcblx0XG5cdHZhciByZURlZyA9IC9cXGQrZGVnL2k7XG5cdHZhciByZUtleXdvcmQgPSAvdG9wfGJvdHRvbXxsZWZ0fHJpZ2h0L2k7XG5cdFxuXHQvLyBYWFggZGVmaW5lIHByZWZlcmVuY2VzXG5cdC8qKiBAdHlwZSBwcmVmZXJlbmNlcyAqL1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCdwcmVmZXJlbmNlcycpO1xuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5ncmFkaWVudC5wcmVmaXhlcycsICd3ZWJraXQsIG1veiwgbycsXG5cdFx0XHQnQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZW5kb3ItcHJlZml4ZXMgZm9yIHdoaWNoIHZhbHVlcyBzaG91bGQgJyBcblx0XHRcdCsgJ2JlIGdlbmVyYXRlZC4nKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmdyYWRpZW50Lm9sZFdlYmtpdCcsIHRydWUsXG5cdFx0XHQnR2VuZXJhdGUgZ3JhZGllbnQgZGVmaW5pdGlvbiBmb3Igb2xkIFdlYmtpdCBpbXBsZW1lbnRhdGlvbnMnKTtcblx0XG5cdHByZWZzLmRlZmluZSgnY3NzLmdyYWRpZW50Lm9taXREZWZhdWx0RGlyZWN0aW9uJywgdHJ1ZSxcblx0XHQnRG8gbm90IG91dHB1dCBkZWZhdWx0IGRpcmVjdGlvbiBkZWZpbml0aW9uIGluIGdlbmVyYXRlZCBncmFkaWVudHMuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5ncmFkaWVudC5kZWZhdWx0UHJvcGVydHknLCAnYmFja2dyb3VuZC1pbWFnZScsXG5cdFx0J1doZW4gZ3JhZGllbnQgZXhwYW5kZWQgb3V0c2lkZSBDU1MgdmFsdWUgY29udGV4dCwgaXQgd2lsbCBwcm9kdWNlICdcblx0XHRcdCsgJ3Byb3BlcnRpZXMgd2l0aCB0aGlzIG5hbWUuJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Nzcy5ncmFkaWVudC5mYWxsYmFjaycsIGZhbHNlLFxuXHRcdFx0J1dpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgQ1NTIGdyYWRpZW50IGdlbmVyYXRvciB3aWxsIHByb2R1Y2UgJ1xuXHRcdFx0KyAnPGNvZGU+YmFja2dyb3VuZC1jb2xvcjwvY29kZT4gcHJvcGVydHkgd2l0aCBncmFkaWVudCBmaXJzdCBjb2xvciAnXG5cdFx0XHQrICdhcyBmYWxsYmFjayBmb3Igb2xkIGJyb3dzZXJzLicpO1xuXHRcblx0ZnVuY3Rpb24gbm9ybWFsaXplU3BhY2Uoc3RyKSB7XG5cdFx0cmV0dXJuIHJlcXVpcmUoJ3V0aWxzJykudHJpbShzdHIpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyBsaW5lYXIgZ3JhZGllbnQgZGVmaW5pdGlvblxuXHQgKiBAcGFyYW0ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlTGluZWFyR3JhZGllbnQoZ3JhZGllbnQpIHtcblx0XHR2YXIgZGlyZWN0aW9uID0gZGVmYXVsdExpbmVhckRpcmVjdGlvbnNbMF07XG5cdFx0XG5cdFx0Ly8gZXh0cmFjdCB0b2tlbnNcblx0XHQvKiogQHR5cGUgU3RyaW5nU3RyZWFtICovXG5cdFx0dmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmluZ1N0cmVhbScpLmNyZWF0ZShyZXF1aXJlKCd1dGlscycpLnRyaW0oZ3JhZGllbnQpKTtcblx0XHR2YXIgY29sb3JTdG9wcyA9IFtdLCBjaDtcblx0XHR3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG5cdFx0XHRpZiAoc3RyZWFtLnBlZWsoKSA9PSAnLCcpIHtcblx0XHRcdFx0Y29sb3JTdG9wcy5wdXNoKHN0cmVhbS5jdXJyZW50KCkpO1xuXHRcdFx0XHRzdHJlYW0ubmV4dCgpO1xuXHRcdFx0XHRzdHJlYW0uZWF0U3BhY2UoKTtcblx0XHRcdFx0c3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcblx0XHRcdH0gZWxzZSBpZiAoY2ggPT0gJygnKSB7IC8vIGNvbG9yIGRlZmluaXRpb24sIGxpa2UgJ3JnYigwLDAsMCknXG5cdFx0XHRcdHN0cmVhbS5za2lwVG8oJyknKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gYWRkIGxhc3QgdG9rZW5cblx0XHRjb2xvclN0b3BzLnB1c2goc3RyZWFtLmN1cnJlbnQoKSk7XG5cdFx0Y29sb3JTdG9wcyA9IF8uY29tcGFjdChfLm1hcChjb2xvclN0b3BzLCBub3JtYWxpemVTcGFjZSkpO1xuXHRcdFxuXHRcdGlmICghY29sb3JTdG9wcy5sZW5ndGgpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcblx0XHQvLyBsZXQncyBzZWUgaWYgdGhlIGZpcnN0IGNvbG9yIHN0b3AgaXMgYWN0dWFsbHkgYSBkaXJlY3Rpb25cblx0XHRpZiAocmVEZWcudGVzdChjb2xvclN0b3BzWzBdKSB8fCByZUtleXdvcmQudGVzdChjb2xvclN0b3BzWzBdKSkge1xuXHRcdFx0ZGlyZWN0aW9uID0gY29sb3JTdG9wcy5zaGlmdCgpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRkaXJlY3Rpb246IGRpcmVjdGlvbixcblx0XHRcdGNvbG9yU3RvcHM6IF8ubWFwKGNvbG9yU3RvcHMsIHBhcnNlQ29sb3JTdG9wKVxuXHRcdH07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQYXJzZXMgY29sb3Igc3RvcCBkZWZpbml0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclN0b3Bcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlQ29sb3JTdG9wKGNvbG9yU3RvcCkge1xuXHRcdGNvbG9yU3RvcCA9IG5vcm1hbGl6ZVNwYWNlKGNvbG9yU3RvcCk7XG5cdFx0XG5cdFx0Ly8gZmluZCBjb2xvciBkZWNsYXJhdGlvblxuXHRcdC8vIGZpcnN0LCB0cnkgY29tcGxleCBjb2xvciBkZWNsYXJhdGlvbiwgbGlrZSByZ2IoMCwwLDApXG5cdFx0dmFyIGNvbG9yID0gbnVsbDtcblx0XHRjb2xvclN0b3AgPSBjb2xvclN0b3AucmVwbGFjZSgvXihcXHcrXFwoLis/XFwpKVxccyovLCBmdW5jdGlvbihzdHIsIGMpIHtcblx0XHRcdGNvbG9yID0gYztcblx0XHRcdHJldHVybiAnJztcblx0XHR9KTtcblx0XHRcblx0XHRpZiAoIWNvbG9yKSB7XG5cdFx0XHQvLyB0cnkgc2ltcGxlIGRlY2xhcmF0aW9uLCBsaWtlIHllbGxvdywgI2ZjbywgI2ZmZmZmZiwgZXRjLlxuXHRcdFx0dmFyIHBhcnRzID0gY29sb3JTdG9wLnNwbGl0KCcgJyk7XG5cdFx0XHRjb2xvciA9IHBhcnRzWzBdO1xuXHRcdFx0Y29sb3JTdG9wID0gcGFydHNbMV0gfHwgJyc7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRjb2xvcjogY29sb3Jcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChjb2xvclN0b3ApIHtcblx0XHRcdC8vIHRoZXJlJ3MgcG9zaXRpb24gaW4gY29sb3Igc3RvcCBkZWZpbml0aW9uXG5cdFx0XHRjb2xvclN0b3AucmVwbGFjZSgvXihcXC0/W1xcZFxcLl0rKShbYS16JV0rKT8kLywgZnVuY3Rpb24oc3RyLCBwb3MsIHVuaXQpIHtcblx0XHRcdFx0cmVzdWx0LnBvc2l0aW9uID0gcG9zO1xuXHRcdFx0XHRpZiAofnBvcy5pbmRleE9mKCcuJykpIHtcblx0XHRcdFx0XHR1bml0ID0gJyc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXVuaXQpIHtcblx0XHRcdFx0XHR1bml0ID0gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodW5pdClcblx0XHRcdFx0XHRyZXN1bHQudW5pdCA9IHVuaXQ7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlc29sdmVzIHByb3BlcnR5IG5hbWUgKGFiYnJldmlhdGlvbik6IHNlYXJjaGVzIGZvciBzbmlwcGV0IGRlZmluaXRpb24gaW4gXG5cdCAqICdyZXNvdXJjZXMnIGFuZCByZXR1cm5zIG5ldyBuYW1lIG9mIG1hdGNoZWQgcHJvcGVydHlcblx0ICovXG5cdGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0eU5hbWUobmFtZSwgc3ludGF4KSB7XG5cdFx0dmFyIHJlcyA9IHJlcXVpcmUoJ3Jlc291cmNlcycpO1xuXHRcdHZhciBwcmVmcyA9IHJlcXVpcmUoJ3ByZWZlcmVuY2VzJyk7XG5cdFx0dmFyIHNuaXBwZXQgPSByZXMuZmluZFNuaXBwZXQoc3ludGF4LCBuYW1lKTtcblx0XHRcblx0XHRpZiAoIXNuaXBwZXQgJiYgcHJlZnMuZ2V0KCdjc3MuZnV6enlTZWFyY2gnKSkge1xuXHRcdFx0c25pcHBldCA9IHJlcy5mdXp6eUZpbmRTbmlwcGV0KHN5bnRheCwgbmFtZSwgXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChwcmVmcy5nZXQoJ2Nzcy5mdXp6eVNlYXJjaE1pblNjb3JlJykpKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHNuaXBwZXQpIHtcblx0XHRcdGlmICghXy5pc1N0cmluZyhzbmlwcGV0KSkge1xuXHRcdFx0XHRzbmlwcGV0ID0gc25pcHBldC5kYXRhO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgnY3NzUmVzb2x2ZXInKS5zcGxpdFNuaXBwZXQoc25pcHBldCkubmFtZTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBGaWxscy1vdXQgaW1wbGllZCBwb3NpdGlvbnMgaW4gY29sb3Itc3RvcHMuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvclxuXHQgKiBvbGQgV2Via2l0IGdyYWRpZW50IGRlZmluaXRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBmaWxsSW1wbGllZFBvc2l0aW9ucyhjb2xvclN0b3BzKSB7XG5cdFx0dmFyIGZyb20gPSAwO1xuXHRcdFxuXHRcdF8uZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbihjcywgaSkge1xuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgZmlyc3QgYW5kIGxhc3QgcG9zaXRpb25zIGFyZSBkZWZpbmVkXG5cdFx0XHRpZiAoIWkpXG5cdFx0XHRcdHJldHVybiBjcy5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uIHx8IDA7XG5cdFx0XHRcblx0XHRcdGlmIChpID09IGNvbG9yU3RvcHMubGVuZ3RoIC0gMSAmJiAhKCdwb3NpdGlvbicgaW4gY3MpKVxuXHRcdFx0XHRjcy5wb3NpdGlvbiA9IDE7XG5cdFx0XHRcblx0XHRcdGlmICgncG9zaXRpb24nIGluIGNzKSB7XG5cdFx0XHRcdHZhciBzdGFydCA9IGNvbG9yU3RvcHNbZnJvbV0ucG9zaXRpb24gfHwgMDtcblx0XHRcdFx0dmFyIHN0ZXAgPSAoY3MucG9zaXRpb24gLSBzdGFydCkgLyAoaSAtIGZyb20pO1xuXHRcdFx0XHRfLmVhY2goY29sb3JTdG9wcy5zbGljZShmcm9tLCBpKSwgZnVuY3Rpb24oY3MyLCBqKSB7XG5cdFx0XHRcdFx0Y3MyLnBvc2l0aW9uID0gc3RhcnQgKyBzdGVwICogajtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmcm9tID0gaTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGV4dHVhbCB2ZXJzaW9uIG9mIGRpcmVjdGlvbiBleHByZXNzZWQgaW4gZGVncmVlc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiB0ZXh0dWFsRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuXHRcdHZhciBhbmdsZSA9IHBhcnNlRmxvYXQoZGlyZWN0aW9uKTtcblx0XHRcblx0XHRpZighXy5pc05hTihhbmdsZSkpIHtcblx0XHRcdHN3aXRjaChhbmdsZSAlIDM2MCkge1xuXHRcdFx0XHRjYXNlIDA6ICAgcmV0dXJuICdsZWZ0Jztcblx0XHRcdFx0Y2FzZSA5MDogIHJldHVybiAnYm90dG9tJztcblx0XHRcdFx0Y2FzZSAxODA6IHJldHVybiAncmlnaHQnO1xuXHRcdFx0XHRjYXNlIDI0MDogcmV0dXJuICd0b3AnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZGlyZWN0aW9uO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBkaXJlY3Rpb24gZGVmaW5pdGlvbiBmb3Igb2xkIFdlYmtpdCBncmFkaWVudHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvblxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gb2xkV2Via2l0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuXHRcdGRpcmVjdGlvbiA9IHRleHR1YWxEaXJlY3Rpb24oZGlyZWN0aW9uKTtcblx0XHRcblx0XHRpZihyZURlZy50ZXN0KGRpcmVjdGlvbikpXG5cdFx0XHR0aHJvdyBcIlRoZSBkaXJlY3Rpb24gaXMgYW4gYW5nbGUgdGhhdCBjYW7igJl0IGJlIGNvbnZlcnRlZC5cIjtcblx0XHRcblx0XHR2YXIgdiA9IGZ1bmN0aW9uKHBvcykge1xuXHRcdFx0cmV0dXJuIH5kaXJlY3Rpb24uaW5kZXhPZihwb3MpID8gJzEwMCUnIDogJzAnO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHYoJ3JpZ2h0JykgKyAnICcgKyB2KCdib3R0b20nKSArICcsICcgKyB2KCdsZWZ0JykgKyAnICcgKyB2KCd0b3AnKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0UHJlZml4ZWROYW1lcyhuYW1lKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gcHJlZnMuZ2V0QXJyYXkoJ2Nzcy5ncmFkaWVudC5wcmVmaXhlcycpO1xuXHRcdHZhciBuYW1lcyA9IHByZWZpeGVzIFxuXHRcdFx0PyBfLm1hcChwcmVmaXhlcywgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gJy0nICsgcCArICctJyArIG5hbWU7XG5cdFx0XHR9KSBcblx0XHRcdDogW107XG5cdFx0XG5cdFx0bmFtZXMucHVzaChuYW1lKTtcblx0XHRcblx0XHRyZXR1cm4gbmFtZXM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGxpc3Qgb2YgQ1NTIHByb3BlcnRpZXMgd2l0aCBncmFkaWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZ3JhZGllbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSBPcmlnaW5hbCBDU1MgcHJvcGVydHkgbmFtZVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRm9yR3JhZGllbnQoZ3JhZGllbnQsIHByb3BlcnR5TmFtZSkge1xuXHRcdHZhciBwcm9wcyA9IFtdO1xuXHRcdHZhciBjc3MgPSByZXF1aXJlKCdjc3NSZXNvbHZlcicpO1xuXHRcdFxuXHRcdGlmIChwcmVmcy5nZXQoJ2Nzcy5ncmFkaWVudC5mYWxsYmFjaycpICYmIH5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdiYWNrZ3JvdW5kJykpIHtcblx0XHRcdHByb3BzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsXG5cdFx0XHRcdHZhbHVlOiAnJHsxOicgKyBncmFkaWVudC5jb2xvclN0b3BzWzBdLmNvbG9yICsgJ30nXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0Xy5lYWNoKHByZWZzLmdldEFycmF5KCdjc3MuZ3JhZGllbnQucHJlZml4ZXMnKSwgZnVuY3Rpb24ocHJlZml4KSB7XG5cdFx0XHR2YXIgbmFtZSA9IGNzcy5wcmVmaXhlZChwcm9wZXJ0eU5hbWUsIHByZWZpeCk7XG5cdFx0XHRpZiAocHJlZml4ID09ICd3ZWJraXQnICYmIHByZWZzLmdldCgnY3NzLmdyYWRpZW50Lm9sZFdlYmtpdCcpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdFx0dmFsdWU6IG1vZHVsZS5vbGRXZWJraXRMaW5lYXJHcmFkaWVudChncmFkaWVudClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwcm9wcy5wdXNoKHtcblx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0dmFsdWU6IG1vZHVsZS50b1N0cmluZyhncmFkaWVudCwgcHJlZml4KVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHByb3BzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGIubmFtZS5sZW5ndGggLSBhLm5hbWUubGVuZ3RoO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUGFzdGVzIGdyYWRpZW50IGRlZmluaXRpb24gaW50byBDU1MgcnVsZSB3aXRoIGNvcnJlY3QgdmVuZG9yLXByZWZpeGVzXG5cdCAqIEBwYXJhbSB7RWRpdEVsZW1lbnR9IHByb3BlcnR5IE1hdGNoZWQgQ1NTIHByb3BlcnR5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBncmFkaWVudCBQYXJzZWQgZ3JhZGllbnRcblx0ICogQHBhcmFtIHtSYW5nZX0gdmFsdWVSYW5nZSBJZiBwYXNzZWQsIG9ubHkgdGhpcyByYW5nZSB3aXRoaW4gcHJvcGVydHkgXG5cdCAqIHZhbHVlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBncmFkaWVudC4gT3RoZXJ3aXNlLCBmdWxsIHZhbHVlIHdpbGwgYmUgXG5cdCAqIHJlcGxhY2VkXG5cdCAqL1xuXHRmdW5jdGlvbiBwYXN0ZUdyYWRpZW50KHByb3BlcnR5LCBncmFkaWVudCwgdmFsdWVSYW5nZSkge1xuXHRcdHZhciBydWxlID0gcHJvcGVydHkucGFyZW50O1xuXHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0dmFyIGFsaWduVmVuZG9yID0gcmVxdWlyZSgncHJlZmVyZW5jZXMnKS5nZXQoJ2Nzcy5hbGlnblZlbmRvcicpO1xuXHRcdFxuXHRcdC8vIHdlIG1heSBoYXZlIGFsaWduZWQgZ3JhZGllbnQgZGVmaW5pdGlvbnM6IGZpbmQgdGhlIHNtYWxsZXN0IHZhbHVlXG5cdFx0Ly8gc2VwYXJhdG9yXG5cdFx0dmFyIHNlcCA9IHByb3BlcnR5LnN0eWxlU2VwYXJhdG9yO1xuXHRcdHZhciBiZWZvcmUgPSBwcm9wZXJ0eS5zdHlsZUJlZm9yZTtcblx0XHRcblx0XHQvLyBmaXJzdCwgcmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHdpdGhpbiBDU1MgcnVsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYW5kXG5cdFx0Ly8gZ3JhZGllbnQgZGVmaW5pdGlvblxuXHRcdF8uZWFjaChydWxlLmdldEFsbChnZXRQcmVmaXhlZE5hbWVzKHByb3BlcnR5Lm5hbWUoKSkpLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbSAhPSBwcm9wZXJ0eSAmJiAvZ3JhZGllbnQvaS50ZXN0KGl0ZW0udmFsdWUoKSkpIHtcblx0XHRcdFx0aWYgKGl0ZW0uc3R5bGVTZXBhcmF0b3IubGVuZ3RoIDwgc2VwLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlcCA9IGl0ZW0uc3R5bGVTZXBhcmF0b3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGl0ZW0uc3R5bGVCZWZvcmUubGVuZ3RoIDwgYmVmb3JlLmxlbmd0aCkge1xuXHRcdFx0XHRcdGJlZm9yZSA9IGl0ZW0uc3R5bGVCZWZvcmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVsZS5yZW1vdmUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKGFsaWduVmVuZG9yKSB7XG5cdFx0XHQvLyB1cGRhdGUgcHJlZml4XG5cdFx0XHRpZiAoYmVmb3JlICE9IHByb3BlcnR5LnN0eWxlQmVmb3JlKSB7XG5cdFx0XHRcdHZhciBmdWxsUmFuZ2UgPSBwcm9wZXJ0eS5mdWxsUmFuZ2UoKTtcblx0XHRcdFx0cnVsZS5fdXBkYXRlU291cmNlKGJlZm9yZSwgZnVsbFJhbmdlLnN0YXJ0LCBmdWxsUmFuZ2Uuc3RhcnQgKyBwcm9wZXJ0eS5zdHlsZUJlZm9yZS5sZW5ndGgpO1xuXHRcdFx0XHRwcm9wZXJ0eS5zdHlsZUJlZm9yZSA9IGJlZm9yZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gdXBkYXRlIHNlcGFyYXRvciB2YWx1ZVxuXHRcdFx0aWYgKHNlcCAhPSBwcm9wZXJ0eS5zdHlsZVNlcGFyYXRvcikge1xuXHRcdFx0XHRydWxlLl91cGRhdGVTb3VyY2Uoc2VwLCBwcm9wZXJ0eS5uYW1lUmFuZ2UoKS5lbmQsIHByb3BlcnR5LnZhbHVlUmFuZ2UoKS5zdGFydCk7XG5cdFx0XHRcdHByb3BlcnR5LnN0eWxlU2VwYXJhdG9yID0gc2VwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR2YXIgdmFsdWUgPSBwcm9wZXJ0eS52YWx1ZSgpO1xuXHRcdGlmICghdmFsdWVSYW5nZSlcblx0XHRcdHZhbHVlUmFuZ2UgPSByZXF1aXJlKCdyYW5nZScpLmNyZWF0ZSgwLCBwcm9wZXJ0eS52YWx1ZSgpKTtcblx0XHRcblx0XHR2YXIgdmFsID0gZnVuY3Rpb24odikge1xuXHRcdFx0cmV0dXJuIHV0aWxzLnJlcGxhY2VTdWJzdHJpbmcodmFsdWUsIHYsIHZhbHVlUmFuZ2UpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcHV0IHZhbmlsbGEtY2xlYW4gZ3JhZGllbnQgZGVmaW5pdGlvbiBpbnRvIGN1cnJlbnQgcnVsZVxuXHRcdHByb3BlcnR5LnZhbHVlKHZhbChtb2R1bGUudG9TdHJpbmcoZ3JhZGllbnQpKSArICckezJ9Jyk7XG5cdFx0XG5cdFx0Ly8gY3JlYXRlIGxpc3Qgb2YgcHJvcGVydGllcyB0byBpbnNlcnRcblx0XHR2YXIgcHJvcHNUb0luc2VydCA9IGdldFByb3BlcnRpZXNGb3JHcmFkaWVudChncmFkaWVudCwgcHJvcGVydHkubmFtZSgpKTtcblx0XHRcblx0XHQvLyBhbGlnbiBwcmVmaXhlZCB2YWx1ZXNcblx0XHRpZiAoYWxpZ25WZW5kb3IpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSBfLnBsdWNrKHByb3BzVG9JbnNlcnQsICd2YWx1ZScpO1xuXHRcdFx0dmFyIG5hbWVzID0gXy5wbHVjayhwcm9wc1RvSW5zZXJ0LCAnbmFtZScpO1xuXHRcdFx0dmFsdWVzLnB1c2gocHJvcGVydHkudmFsdWUoKSk7XG5cdFx0XHRuYW1lcy5wdXNoKHByb3BlcnR5Lm5hbWUoKSk7XG5cdFx0XHRcblx0XHRcdHZhciB2YWx1ZVBhZHMgPSB1dGlscy5nZXRTdHJpbmdzUGFkcyhfLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuIHYuc3Vic3RyaW5nKDAsIHYuaW5kZXhPZignKCcpKTtcblx0XHRcdH0pKTtcblx0XHRcdFxuXHRcdFx0dmFyIG5hbWVQYWRzID0gdXRpbHMuZ2V0U3RyaW5nc1BhZHMobmFtZXMpO1xuXHRcdFx0cHJvcGVydHkubmFtZShfLmxhc3QobmFtZVBhZHMpICsgcHJvcGVydHkubmFtZSgpKTtcblx0XHRcdFxuXHRcdFx0Xy5lYWNoKHByb3BzVG9JbnNlcnQsIGZ1bmN0aW9uKHByb3AsIGkpIHtcblx0XHRcdFx0cHJvcC5uYW1lID0gbmFtZVBhZHNbaV0gKyBwcm9wLm5hbWU7XG5cdFx0XHRcdHByb3AudmFsdWUgPSB2YWx1ZVBhZHNbaV0gKyBwcm9wLnZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb3BlcnR5LnZhbHVlKF8ubGFzdCh2YWx1ZVBhZHMpICsgcHJvcGVydHkudmFsdWUoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHB1dCB2ZW5kb3ItcHJlZml4ZWQgZGVmaW5pdGlvbnMgYmVmb3JlIGN1cnJlbnQgcnVsZVxuXHRcdF8uZWFjaChwcm9wc1RvSW5zZXJ0LCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRydWxlLmFkZChwcm9wLm5hbWUsIHByb3AudmFsdWUsIHJ1bGUuaW5kZXhPZihwcm9wZXJ0eSkpO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU2VhcmNoIGZvciBncmFkaWVudCBkZWZpbml0aW9uIGluc2lkZSBDU1MgcHJvcGVydHkgdmFsdWVcblx0ICovXG5cdGZ1bmN0aW9uIGZpbmRHcmFkaWVudChjc3NQcm9wKSB7XG5cdFx0dmFyIHZhbHVlID0gY3NzUHJvcC52YWx1ZSgpO1xuXHRcdHZhciBncmFkaWVudCA9IG51bGw7XG5cdFx0dmFyIG1hdGNoZWRQYXJ0ID0gXy5maW5kKGNzc1Byb3AudmFsdWVQYXJ0cygpLCBmdW5jdGlvbihwYXJ0KSB7XG5cdFx0XHRyZXR1cm4gZ3JhZGllbnQgPSBtb2R1bGUucGFyc2UocGFydC5zdWJzdHJpbmcodmFsdWUpKTtcblx0XHR9KTtcblx0XHRcblx0XHRpZiAobWF0Y2hlZFBhcnQgJiYgZ3JhZGllbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGdyYWRpZW50OiBncmFkaWVudCxcblx0XHRcdFx0dmFsdWVSYW5nZTogbWF0Y2hlZFBhcnRcblx0XHRcdH07XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVHJpZXMgdG8gZXhwYW5kIGdyYWRpZW50IG91dHNpZGUgQ1NTIHZhbHVlIFxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICovXG5cdGZ1bmN0aW9uIGV4cGFuZEdyYWRpZW50T3V0c2lkZVZhbHVlKGVkaXRvciwgc3ludGF4KSB7XG5cdFx0dmFyIHByb3BlcnR5TmFtZSA9IHByZWZzLmdldCgnY3NzLmdyYWRpZW50LmRlZmF1bHRQcm9wZXJ0eScpO1xuXHRcdFxuXHRcdGlmICghcHJvcGVydHlOYW1lKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdC8vIGFzc3VtaW5nIHRoYXQgZ3JhZGllbnQgZGVmaW5pdGlvbiBpcyB3cml0dGVuIG9uIG5ldyBsaW5lLFxuXHRcdC8vIGRvIGEgc2ltcGxpZmllZCBwYXJzaW5nXG5cdFx0dmFyIGNvbnRlbnQgPSBTdHJpbmcoZWRpdG9yLmdldENvbnRlbnQoKSk7XG5cdFx0LyoqIEB0eXBlIFJhbmdlICovXG5cdFx0dmFyIGxpbmVSYW5nZSA9IHJlcXVpcmUoJ3JhbmdlJykuY3JlYXRlKGVkaXRvci5nZXRDdXJyZW50TGluZVJhbmdlKCkpO1xuXHRcdFxuXHRcdC8vIGdldCBsaW5lIGNvbnRlbnQgYW5kIGFkanVzdCByYW5nZSB3aXRoIHBhZGRpbmdcblx0XHR2YXIgbGluZSA9IGxpbmVSYW5nZS5zdWJzdHJpbmcoY29udGVudClcblx0XHRcdC5yZXBsYWNlKC9eXFxzKy8sIGZ1bmN0aW9uKHBhZCkge1xuXHRcdFx0XHRsaW5lUmFuZ2Uuc3RhcnQgKz0gcGFkLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSlcblx0XHRcdC5yZXBsYWNlKC9cXHMrJC8sIGZ1bmN0aW9uKHBhZCkge1xuXHRcdFx0XHRsaW5lUmFuZ2UuZW5kIC09IHBhZC5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0pO1xuXHRcdFxuXHRcdHZhciBjc3MgPSByZXF1aXJlKCdjc3NSZXNvbHZlcicpO1xuXHRcdHZhciBncmFkaWVudCA9IG1vZHVsZS5wYXJzZShsaW5lKTtcblx0XHRpZiAoZ3JhZGllbnQpIHtcblx0XHRcdHZhciBwcm9wcyA9IGdldFByb3BlcnRpZXNGb3JHcmFkaWVudChncmFkaWVudCwgcHJvcGVydHlOYW1lKTtcblx0XHRcdHByb3BzLnB1c2goe1xuXHRcdFx0XHRuYW1lOiBwcm9wZXJ0eU5hbWUsXG5cdFx0XHRcdHZhbHVlOiBtb2R1bGUudG9TdHJpbmcoZ3JhZGllbnQpICsgJyR7Mn0nXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dmFyIHNlcCA9IGNzcy5nZXRTeW50YXhQcmVmZXJlbmNlKCd2YWx1ZVNlcGFyYXRvcicsIHN5bnRheCk7XG5cdFx0XHR2YXIgZW5kID0gY3NzLmdldFN5bnRheFByZWZlcmVuY2UoJ3Byb3BlcnR5RW5kJywgc3ludGF4KTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlcXVpcmUoJ3ByZWZlcmVuY2VzJykuZ2V0KCdjc3MuYWxpZ25WZW5kb3InKSkge1xuXHRcdFx0XHR2YXIgcGFkcyA9IHJlcXVpcmUoJ3V0aWxzJykuZ2V0U3RyaW5nc1BhZHMoXy5tYXAocHJvcHMsIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvcC52YWx1ZS5zdWJzdHJpbmcoMCwgcHJvcC52YWx1ZS5pbmRleE9mKCcoJykpO1xuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdF8uZWFjaChwcm9wcywgZnVuY3Rpb24ocHJvcCwgaSkge1xuXHRcdFx0XHRcdHByb3AudmFsdWUgPSBwYWRzW2ldICsgcHJvcC52YWx1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHByb3BzID0gXy5tYXAocHJvcHMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW0ubmFtZSArIHNlcCArIGl0ZW0udmFsdWUgKyBlbmQ7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KHByb3BzLmpvaW4oJ1xcbicpLCBsaW5lUmFuZ2Uuc3RhcnQsIGxpbmVSYW5nZS5lbmQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNlYXJjaCBmb3IgZ3JhZGllbnQgZGVmaW5pdGlvbiBpbnNpZGUgQ1NTIHZhbHVlIHVuZGVyIGN1cnNvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kR3JhZGllbnRGcm9tUG9zaXRpb24oY29udGVudCwgcG9zKSB7XG5cdFx0dmFyIGNzc1Byb3AgPSBudWxsO1xuXHRcdC8qKiBAdHlwZSBFZGl0Q29udGFpbmVyICovXG5cdFx0dmFyIGNzc1J1bGUgPSByZXF1aXJlKCdjc3NFZGl0VHJlZScpLnBhcnNlRnJvbVBvc2l0aW9uKGNvbnRlbnQsIHBvcywgdHJ1ZSk7XG5cdFx0XG5cdFx0aWYgKGNzc1J1bGUpIHtcblx0XHRcdGNzc1Byb3AgPSBjc3NSdWxlLml0ZW1Gcm9tUG9zaXRpb24ocG9zLCB0cnVlKTtcblx0XHRcdGlmICghY3NzUHJvcCkge1xuXHRcdFx0XHQvLyBpbiBjYXNlIHVzZXIganVzdCBzdGFydGVkIHdyaXRpbmcgQ1NTIHByb3BlcnR5XG5cdFx0XHRcdC8vIGFuZCBkaWRuJ3QgaW5jbHVkZSBzZW1pY29sb27igJN0cnkgYW5vdGhlciBhcHByb2FjaFxuXHRcdFx0XHRjc3NQcm9wID0gXy5maW5kKGNzc1J1bGUubGlzdCgpLCBmdW5jdGlvbihlbGVtKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ucmFuZ2UodHJ1ZSkuZW5kID09IHBvcztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB7XG5cdFx0XHRydWxlOiBjc3NSdWxlLFxuXHRcdFx0cHJvcGVydHk6IGNzc1Byb3Bcblx0XHR9O1xuXHR9XG5cdFxuXHQvLyBYWFggcmVnaXN0ZXIgZXhwYW5kIGFiYnJldmlhdGlvbiBoYW5kbGVyXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lFbW1ldEVkaXRvcn0gZWRpdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzeW50YXhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb2ZpbGVcblx0ICovXG5cdHJlcXVpcmUoJ2V4cGFuZEFiYnJldmlhdGlvbicpLmFkZEhhbmRsZXIoZnVuY3Rpb24oZWRpdG9yLCBzeW50YXgsIHByb2ZpbGUpIHtcblx0XHR2YXIgaW5mbyA9IHJlcXVpcmUoJ2VkaXRvclV0aWxzJykub3V0cHV0SW5mbyhlZGl0b3IsIHN5bnRheCwgcHJvZmlsZSk7XG5cdFx0aWYgKCFfLmluY2x1ZGUoY3NzU3ludGF4ZXMsIGluZm8uc3ludGF4KSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHQvLyBsZXQncyBzZWUgaWYgd2UgYXJlIGV4cGFuZGluZyBncmFkaWVudCBkZWZpbml0aW9uXG5cdFx0dmFyIGNhcmV0ID0gZWRpdG9yLmdldENhcmV0UG9zKCk7XG5cdFx0dmFyIGNvbnRlbnQgPSBpbmZvLmNvbnRlbnQ7XG5cdFx0dmFyIGNzcyA9IGZpbmRHcmFkaWVudEZyb21Qb3NpdGlvbihjb250ZW50LCBjYXJldCk7XG5cdFx0XG5cdFx0aWYgKGNzcy5wcm9wZXJ0eSkge1xuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgY2FyZXQgaXMgaW5zaWRlIHByb3BlcnR5IHZhbHVlIHdpdGggZ3JhZGllbnQgXG5cdFx0XHQvLyBkZWZpbml0aW9uXG5cdFx0XHR2YXIgZyA9IGZpbmRHcmFkaWVudChjc3MucHJvcGVydHkpO1xuXHRcdFx0aWYgKGcpIHtcblx0XHRcdFx0dmFyIHJ1bGVTdGFydCA9IGNzcy5ydWxlLm9wdGlvbnMub2Zmc2V0IHx8IDA7XG5cdFx0XHRcdHZhciBydWxlRW5kID0gcnVsZVN0YXJ0ICsgY3NzLnJ1bGUudG9TdHJpbmcoKS5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBIYW5kbGUgc3BlY2lhbCBjYXNlOlxuXHRcdFx0XHQvLyB1c2VyIHdyb3RlIGdyYWRpZW50IGRlZmluaXRpb24gYmV0d2VlbiBleGlzdGluZyBDU1MgXG5cdFx0XHRcdC8vIHByb3BlcnRpZXMgYW5kIGRpZCBub3QgZmluaXNoZWQgaXQgd2l0aCBzZW1pY29sb24uXG5cdFx0XHRcdC8vIEluIHRoaXMgY2FzZSwgd2UgaGF2ZSBzZW1pY29sb24gcmlnaHQgYWZ0ZXIgZ3JhZGllbnQgXG5cdFx0XHRcdC8vIGRlZmluaXRpb24gYW5kIHJlLXBhcnNlIHJ1bGUgYWdhaW5cblx0XHRcdFx0aWYgKC9bXFxuXFxyXS8udGVzdChjc3MucHJvcGVydHkudmFsdWUoKSkpIHtcblx0XHRcdFx0XHQvLyBpbnNlcnQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgZ3JhZGllbnQgZGVmaW5pdGlvblxuXHRcdFx0XHRcdHZhciBpbnNlcnRQb3MgPSBjc3MucHJvcGVydHkudmFsdWVSYW5nZSh0cnVlKS5zdGFydCArIGcudmFsdWVSYW5nZS5lbmQ7XG5cdFx0XHRcdFx0Y29udGVudCA9IHJlcXVpcmUoJ3V0aWxzJykucmVwbGFjZVN1YnN0cmluZyhjb250ZW50LCAnOycsIGluc2VydFBvcyk7XG5cdFx0XHRcdFx0dmFyIG5ld0NzcyA9IGZpbmRHcmFkaWVudEZyb21Qb3NpdGlvbihjb250ZW50LCBjYXJldCk7XG5cdFx0XHRcdFx0aWYgKG5ld0Nzcy5wcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0ZyA9IGZpbmRHcmFkaWVudChuZXdDc3MucHJvcGVydHkpO1xuXHRcdFx0XHRcdFx0Y3NzID0gbmV3Q3NzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIGN1cnJlbnQgcHJvcGVydHkgaGFzIHRlcm1pbmF0aW5nIHNlbWljb2xvblxuXHRcdFx0XHRjc3MucHJvcGVydHkuZW5kKCc7Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyByZXNvbHZlIENTUyBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdHZhciByZXNvbHZlZE5hbWUgPSByZXNvbHZlUHJvcGVydHlOYW1lKGNzcy5wcm9wZXJ0eS5uYW1lKCksIHN5bnRheCk7XG5cdFx0XHRcdGlmIChyZXNvbHZlZE5hbWUpIHtcblx0XHRcdFx0XHRjc3MucHJvcGVydHkubmFtZShyZXNvbHZlZE5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRwYXN0ZUdyYWRpZW50KGNzcy5wcm9wZXJ0eSwgZy5ncmFkaWVudCwgZy52YWx1ZVJhbmdlKTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VDb250ZW50KGNzcy5ydWxlLnRvU3RyaW5nKCksIHJ1bGVTdGFydCwgcnVsZUVuZCwgdHJ1ZSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZXhwYW5kR3JhZGllbnRPdXRzaWRlVmFsdWUoZWRpdG9yLCBzeW50YXgpO1xuXHR9KTtcblx0XG5cdC8vIFhYWCByZWdpc3RlciBcIlJlZmxlY3QgQ1NTIFZhbHVlXCIgYWN0aW9uIGRlbGVnYXRlXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VkaXRFbGVtZW50fSBwcm9wZXJ0eVxuXHQgKi9cblx0cmVxdWlyZSgncmVmbGVjdENTU1ZhbHVlJykuYWRkSGFuZGxlcihmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0XG5cdFx0dmFyIGcgPSBmaW5kR3JhZGllbnQocHJvcGVydHkpO1xuXHRcdGlmICghZylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHR2YXIgdmFsdWUgPSBwcm9wZXJ0eS52YWx1ZSgpO1xuXHRcdHZhciB2YWwgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRyZXR1cm4gdXRpbHMucmVwbGFjZVN1YnN0cmluZyh2YWx1ZSwgdiwgZy52YWx1ZVJhbmdlKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHJlZmxlY3QgdmFsdWUgZm9yIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lXG5cdFx0Xy5lYWNoKHByb3BlcnR5LnBhcmVudC5nZXRBbGwoZ2V0UHJlZml4ZWROYW1lcyhwcm9wZXJ0eS5uYW1lKCkpKSwgZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0aWYgKHByb3AgPT09IHByb3BlcnR5KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdC8vIGNoZWNrIGlmIHByb3BlcnR5IHZhbHVlIHN0YXJ0cyB3aXRoIGdyYWRpZW50IGRlZmluaXRpb25cblx0XHRcdHZhciBtID0gcHJvcC52YWx1ZSgpLm1hdGNoKC9eXFxzKihcXC0oW2Etel0rKVxcLSk/bGluZWFyXFwtZ3JhZGllbnQvKTtcblx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdHByb3AudmFsdWUodmFsKG1vZHVsZS50b1N0cmluZyhnLmdyYWRpZW50LCBtWzJdIHx8ICcnKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChtID0gcHJvcC52YWx1ZSgpLm1hdGNoKC9cXHMqXFwtd2Via2l0XFwtZ3JhZGllbnQvKSkge1xuXHRcdFx0XHQvLyBvbGQgd2Via2l0IGdyYWRpZW50IGRlZmluaXRpb25cblx0XHRcdFx0cHJvcC52YWx1ZSh2YWwobW9kdWxlLm9sZFdlYmtpdExpbmVhckdyYWRpZW50KGcuZ3JhZGllbnQpKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xuXHRcblx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHQvKipcblx0XHQgKiBQYXJzZXMgZ3JhZGllbnQgZGVmaW5pdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBncmFkaWVudFxuXHRcdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0cGFyc2U6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblx0XHRcdHJlcXVpcmUoJ3V0aWxzJykudHJpbShncmFkaWVudCkucmVwbGFjZSgvXihbXFx3XFwtXSspXFwoKC4rPylcXCkkLywgZnVuY3Rpb24oc3RyLCB0eXBlLCBkZWZpbml0aW9uKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSB2ZW5kb3IgcHJlZml4XG5cdFx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXlxcLVthLXpdK1xcLS8sICcnKTtcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgdHlwZSA9PSAnbGcnKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gcGFyc2VMaW5lYXJHcmFkaWVudChkZWZpbml0aW9uKTtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb2R1Y2VzIGxpbmVhciBncmFkaWVudCBkZWZpbml0aW9uIHVzZWQgaW4gZWFybHkgV2Via2l0IFxuXHRcdCAqIGltcGxlbWVudGF0aW9uc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBncmFkaWVudCBQYXJzZWQgZ3JhZGllbnRcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdG9sZFdlYmtpdExpbmVhckdyYWRpZW50OiBmdW5jdGlvbihncmFkaWVudCkge1xuXHRcdFx0aWYgKF8uaXNTdHJpbmcoZ3JhZGllbnQpKVxuXHRcdFx0XHRncmFkaWVudCA9IHRoaXMucGFyc2UoZ3JhZGllbnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWdyYWRpZW50KVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0dmFyIGNvbG9yU3RvcHMgPSBfLm1hcChncmFkaWVudC5jb2xvclN0b3BzLCBfLmNsb25lKTtcblx0XHRcdFxuXHRcdFx0Ly8gbm9ybWFsaXplIGNvbG9yLXN0b3BzIHBvc2l0aW9uXG5cdFx0XHRfLmVhY2goY29sb3JTdG9wcywgZnVuY3Rpb24oY3MpIHtcblx0XHRcdFx0aWYgKCEoJ3Bvc2l0aW9uJyBpbiBjcykpIC8vIGltcGxpZWQgcG9zaXRpb25cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAofmNzLnBvc2l0aW9uLmluZGV4T2YoJy4nKSB8fCBjcy51bml0ID09ICclJykge1xuXHRcdFx0XHRcdGNzLnBvc2l0aW9uID0gcGFyc2VGbG9hdChjcy5wb3NpdGlvbikgLyAoY3MudW5pdCA9PSAnJScgPyAxMDAgOiAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbid0IGNvbnZlcnQgY29sb3Igc3RvcCAnXCIgKyAoY3MucG9zaXRpb24gKyAoY3MudW5pdCB8fCAnJykpICsgXCInXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRmaWxsSW1wbGllZFBvc2l0aW9ucyhjb2xvclN0b3BzKTtcblx0XHRcdFxuXHRcdFx0Ly8gdHJhbnNmb3JtIGNvbG9yLXN0b3BzIGludG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRjb2xvclN0b3BzID0gXy5tYXAoY29sb3JTdG9wcywgZnVuY3Rpb24oY3MsIGkpIHtcblx0XHRcdFx0aWYgKCFjcy5wb3NpdGlvbiAmJiAhaSlcblx0XHRcdFx0XHRyZXR1cm4gJ2Zyb20oJyArIGNzLmNvbG9yICsgJyknO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNzLnBvc2l0aW9uID09IDEgJiYgaSA9PSBjb2xvclN0b3BzLmxlbmd0aCAtIDEpXG5cdFx0XHRcdFx0cmV0dXJuICd0bygnICsgY3MuY29sb3IgKyAnKSc7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gJ2NvbG9yLXN0b3AoJyArIChjcy5wb3NpdGlvbi50b0ZpeGVkKDIpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykpICsgJywgJyArIGNzLmNvbG9yICsgJyknO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiAnLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsICcgXG5cdFx0XHRcdCsgb2xkV2Via2l0RGlyZWN0aW9uKGdyYWRpZW50LmRpcmVjdGlvbilcblx0XHRcdFx0KyAnLCAnXG5cdFx0XHRcdCsgY29sb3JTdG9wcy5qb2luKCcsICcpXG5cdFx0XHRcdCsgJyknO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgcGFyc2VkIGdyYWRpZW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGdyYWRpZW50IFBhcnNlZCBncmFkaWVudFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggVmVuZG9yIHByZWZpeFxuXHRcdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKGdyYWRpZW50LCBwcmVmaXgpIHtcblx0XHRcdGlmIChncmFkaWVudC50eXBlID09ICdsaW5lYXInKSB7XG5cdFx0XHRcdHZhciBmbiA9IChwcmVmaXggPyAnLScgKyBwcmVmaXggKyAnLScgOiAnJykgKyAnbGluZWFyLWdyYWRpZW50Jztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHRyYW5zZm9ybSBjb2xvci1zdG9wc1xuXHRcdFx0XHR2YXIgY29sb3JTdG9wcyA9IF8ubWFwKGdyYWRpZW50LmNvbG9yU3RvcHMsIGZ1bmN0aW9uKGNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNzLmNvbG9yICsgKCdwb3NpdGlvbicgaW4gY3MgXG5cdFx0XHRcdFx0XHRcdD8gJyAnICsgY3MucG9zaXRpb24gKyAoY3MudW5pdCB8fCAnJylcblx0XHRcdFx0XHRcdFx0OiAnJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGdyYWRpZW50LmRpcmVjdGlvbiBcblx0XHRcdFx0XHRcdCYmICghcHJlZnMuZ2V0KCdjc3MuZ3JhZGllbnQub21pdERlZmF1bHREaXJlY3Rpb24nKSBcblx0XHRcdFx0XHRcdHx8ICFfLmluY2x1ZGUoZGVmYXVsdExpbmVhckRpcmVjdGlvbnMsIGdyYWRpZW50LmRpcmVjdGlvbikpKSB7XG5cdFx0XHRcdFx0Y29sb3JTdG9wcy51bnNoaWZ0KGdyYWRpZW50LmRpcmVjdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmbiArICcoJyArIGNvbG9yU3RvcHMuam9pbignLCAnKSArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTsvKipcbiAqIE1vZHVsZSBhZGRzIHN1cHBvcnQgZm9yIGdlbmVyYXRvcnM6IGEgcmVnZXhwLWJhc2VkIGFiYnJldmlhdGlvbiByZXNvbHZlciBcbiAqIHRoYXQgY2FuIHByb2R1Y2UgY3VzdG9tIG91dHB1dC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0LyoqIEB0eXBlIEhhbmRsZXJMaXN0ICovXG5cdHZhciBnZW5lcmF0b3JzID0gcmVxdWlyZSgnaGFuZGxlckxpc3QnKS5jcmVhdGUoKTtcblx0dmFyIHJlc291cmNlcyA9IHJlcXVpcmUoJ3Jlc291cmNlcycpO1xuXHRcblx0Xy5leHRlbmQocmVzb3VyY2VzLCB7XG5cdFx0LyoqXG5cdFx0ICogQWRkIGdlbmVyYXRvci4gQSBnZW5lcmF0b3IgZnVuY3Rpb24gPGNvZGU+Zm48L2NvZGU+IHdpbGwgYmUgY2FsbGVkIFxuXHRcdCAqIG9ubHkgaWYgY3VycmVudCBhYmJyZXZpYXRpb24gbWF0Y2hlcyA8Y29kZT5yZWdleHA8L2NvZGU+IHJlZ3VsYXIgXG5cdFx0ICogZXhwcmVzc2lvbiBhbmQgdGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIDxjb2RlPm51bGw8L2NvZGU+IGlmXG5cdFx0ICogYWJicmV2aWF0aW9uIGNhbm5vdCBiZSByZXNvbHZlZFxuXHRcdCAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgUmVndWxhciBleHByZXNzaW9uIGZvciBhYmJyZXZpYXRpb24gZWxlbWVudCBuYW1lXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUmVzb2x2ZXIgZnVuY3Rpb25cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGxpc3QgYXMgZGVzY3JpYmVkIGluIFxuXHRcdCAqIHtAbGluayBIYW5kbGVyTGlzdCNhZGQoKX0gbWV0aG9kXG5cdFx0ICovXG5cdFx0YWRkR2VuZXJhdG9yOiBmdW5jdGlvbihyZWdleHAsIGZuLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAoXy5pc1N0cmluZyhyZWdleHApKVxuXHRcdFx0XHRyZWdleHAgPSBuZXcgUmVnRXhwKHJlZ2V4cCk7XG5cdFx0XHRcblx0XHRcdGdlbmVyYXRvcnMuYWRkKGZ1bmN0aW9uKG5vZGUsIHN5bnRheCkge1xuXHRcdFx0XHR2YXIgbTtcblx0XHRcdFx0aWYgKChtID0gcmVnZXhwLmV4ZWMobm9kZS5uYW1lKCkpKSkge1xuXHRcdFx0XHRcdHJldHVybiBmbihtLCBub2RlLCBzeW50YXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHRyZXNvdXJjZXMuYWRkUmVzb2x2ZXIoZnVuY3Rpb24obm9kZSwgc3ludGF4KSB7XG5cdFx0cmV0dXJuIGdlbmVyYXRvcnMuZXhlYyhudWxsLCBfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG5cdH0pO1xufSk7LyoqXG4gKiBNb2R1bGUgZm9yIHJlc29sdmluZyB0YWcgbmFtZXM6IHJldHVybnMgYmVzdCBtYXRjaGVkIHRhZyBuYW1lIGZvciBjaGlsZFxuICogZWxlbWVudCBiYXNlZCBvbiBwYXNzZWQgcGFyZW50J3MgdGFnIG5hbWUuIEFsc28gcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvblxuICogZm9yIGVsZW1lbnQgdHlwZSBkZXRlY3Rpb24gKGlubGluZSwgYmxvY2stbGV2ZWwsIGVtcHR5KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmRlZmluZSgndGFnTmFtZScsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0dmFyIGVsZW1lbnRUeXBlcyA9IHtcbi8vXHRcdGVtcHR5OiAnYXJlYSxiYXNlLGJhc2Vmb250LGJyLGNvbCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxsaW5rLG1ldGEscGFyYW0sZW1iZWQsa2V5Z2VuLGNvbW1hbmQnLnNwbGl0KCcsJyksXG5cdFx0ZW1wdHk6IFtdLFxuXHRcdGJsb2NrTGV2ZWw6ICdhZGRyZXNzLGFwcGxldCxibG9ja3F1b3RlLGJ1dHRvbixjZW50ZXIsZGQsZGVsLGRpcixkaXYsZGwsZHQsZmllbGRzZXQsZm9ybSxmcmFtZXNldCxocixpZnJhbWUsaW5zLGlzaW5kZXgsbGksbGluayxtYXAsbWVudSxub2ZyYW1lcyxub3NjcmlwdCxvYmplY3Qsb2wscCxwcmUsc2NyaXB0LHRhYmxlLHRib2R5LHRkLHRmb290LHRoLHRoZWFkLHRyLHVsLGgxLGgyLGgzLGg0LGg1LGg2Jy5zcGxpdCgnLCcpLFxuXHRcdGlubGluZUxldmVsOiAnYSxhYmJyLGFjcm9ueW0sYXBwbGV0LGIsYmFzZWZvbnQsYmRvLGJpZyxicixidXR0b24sY2l0ZSxjb2RlLGRlbCxkZm4sZW0sZm9udCxpLGlmcmFtZSxpbWcsaW5wdXQsaW5zLGtiZCxsYWJlbCxtYXAsb2JqZWN0LHEscyxzYW1wLHNlbGVjdCxzbWFsbCxzcGFuLHN0cmlrZSxzdHJvbmcsc3ViLHN1cCx0ZXh0YXJlYSx0dCx1LHZhcicuc3BsaXQoJywnKVxuXHR9O1xuXHRcblx0dmFyIGVsZW1lbnRNYXAgPSB7XG5cdFx0J3AnOiAnc3BhbicsXG5cdFx0J3VsJzogJ2xpJyxcblx0XHQnb2wnOiAnbGknLFxuXHRcdCd0YWJsZSc6ICd0cicsXG5cdFx0J3RyJzogJ3RkJyxcblx0XHQndGJvZHknOiAndHInLFxuXHRcdCd0aGVhZCc6ICd0cicsXG5cdFx0J3Rmb290JzogJ3RyJyxcblx0XHQnY29sZ3JvdXAnOiAnY29sJyxcblx0XHQnc2VsZWN0JzogJ29wdGlvbicsXG5cdFx0J29wdGdyb3VwJzogJ29wdGlvbicsXG5cdFx0J2F1ZGlvJzogJ3NvdXJjZScsXG5cdFx0J3ZpZGVvJzogJ3NvdXJjZScsXG5cdFx0J29iamVjdCc6ICdwYXJhbScsXG5cdFx0J21hcCc6ICdhcmVhJ1xuXHR9O1xuXHRcblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGJlc3QgbWF0Y2hlZCBjaGlsZCBlbGVtZW50IG5hbWUgZm9yIHBhc3NlZCBwYXJlbnQnc1xuXHRcdCAqIHRhZyBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqIEBtZW1iZXJPZiB0YWdOYW1lXG5cdFx0ICovXG5cdFx0cmVzb2x2ZTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0bmFtZSA9IChuYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAobmFtZSBpbiBlbGVtZW50TWFwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRNYXBwaW5nKG5hbWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc0lubGluZUxldmVsKG5hbWUpKVxuXHRcdFx0XHRyZXR1cm4gJ3NwYW4nO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gJ2Rpdic7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIG1hcHBlZCBjaGlsZCBlbGVtZW50IG5hbWUgZm9yIHBhc3NlZCBwYXJlbnQncyBuYW1lIFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRNYXBwaW5nOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudE1hcFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgcGFzc2VkIGVsZW1lbnQgbmFtZSBiZWxvbmdzIHRvIGlubGluZS1sZXZlbCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0lubGluZUxldmVsOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihuYW1lLCAnaW5saW5lTGV2ZWwnKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIHBhc3NlZCBlbGVtZW50IGJlbG9uZ3MgdG8gYmxvY2stbGV2ZWwgZWxlbWVudC5cblx0XHQgKiBGb3IgYmV0dGVyIG1hdGNoaW5nIG9mIHVua25vd24gZWxlbWVudHMgKGZvciBYTUwsIGZvciBleGFtcGxlKSwgXG5cdFx0ICogeW91IHNob3VsZCB1c2UgPGNvZGU+IXRoaXMuaXNJbmxpbmVMZXZlbChuYW1lKTwvY29kZT5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0Jsb2NrTGV2ZWw6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKG5hbWUsICdibG9ja0xldmVsJyk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBpcyB2b2lkIChpLmUuIHNob3VsZCBub3QgaGF2ZSBjbG9zaW5nIHRhZykuXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNFbXB0eUVsZW1lbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKG5hbWUsICdlbXB0eScpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgdGVzdGluZyBpZiBlbGVtZW50IG5hbWUgYmVsb25ncyB0byBzcGVjaWZpZWRcblx0XHQgKiBlbGVtZW50cyBjb2xsZWN0aW9uXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgRWxlbWVudCBuYW1lXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29sbGVjdGlvbiBuYW1lXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNUeXBlT2Y6IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcblx0XHRcdHJldHVybiBfLmluY2x1ZGUoZWxlbWVudFR5cGVzW3R5cGVdLCBuYW1lKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgbmV3IHBhcmVudOKAk2NoaWxkIG1hcHBpbmdcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkXG5cdFx0ICovXG5cdFx0YWRkTWFwcGluZzogZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuXHRcdFx0ZWxlbWVudE1hcFtwYXJlbnRdID0gY2hpbGQ7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHBhcmVudC1jaGlsZCBtYXBwaW5nXG5cdFx0ICovXG5cdFx0cmVtb3ZlTWFwcGluZzogZnVuY3Rpb24ocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50IGluIGVsZW1lbnRNYXApXG5cdFx0XHRcdGRlbGV0ZSBlbGVtZW50TWFwW3BhcmVudF07XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIG5ldyBlbGVtZW50IGludG8gY29sbGVjdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEVsZW1lbnQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gbmFtZVxuXHRcdCAqL1xuXHRcdGFkZEVsZW1lbnRUb0NvbGxlY3Rpb246IGZ1bmN0aW9uKG5hbWUsIGNvbGxlY3Rpb24pIHtcblx0XHRcdGlmICghZWxlbWVudFR5cGVzW2NvbGxlY3Rpb25dKVxuXHRcdFx0XHRlbGVtZW50VHlwZXNbY29sbGVjdGlvbl0gPSBbXTtcblx0XHRcdFxuXHRcdFx0dmFyIGNvbCA9IHRoaXMuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uKTtcblx0XHRcdGlmICghXy5pbmNsdWRlKGNvbCwgbmFtZSkpXG5cdFx0XHRcdGNvbC5wdXNoKG5hbWUpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBlbGVtZW50IG5hbWUgZnJvbSBzcGVjaWZpZWQgY29sbGVjdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEVsZW1lbnQgbmFtZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gbmFtZVxuXHRcdCAqIEByZXR1cm5zXG5cdFx0ICovXG5cdFx0cmVtb3ZlRWxlbWVudEZyb21Db2xsZWN0aW9uOiBmdW5jdGlvbihuYW1lLCBjb2xsZWN0aW9uKSB7XG5cdFx0XHRpZiAoY29sbGVjdGlvbiBpbiBlbGVtZW50VHlwZXMpIHtcblx0XHRcdFx0ZWxlbWVudFR5cGVzW2NvbGxlY3Rpb25dID0gXy53aXRob3V0KHRoaXMuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uKSwgbmFtZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGVsZW1lbnRzIG5hbWUgY29sbGVjdGlvblxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIENvbGxlY3Rpb24gbmFtZVxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKi9cblx0XHRnZXRDb2xsZWN0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudFR5cGVzW25hbWVdO1xuXHRcdH1cblx0fTtcbn0pOy8qKlxuICogRmlsdGVyIGZvciBhaWRpbmcgb2Ygd3JpdGluZyBlbGVtZW50cyB3aXRoIGNvbXBsZXggY2xhc3MgbmFtZXMgYXMgZGVzY3JpYmVkXG4gKiBpbiBZYW5kZXgncyBCRU0gKEJsb2NrLCBFbGVtZW50LCBNb2RpZmllcikgbWV0aG9kb2xvZ3kuIFRoaXMgZmlsdGVyIHdpbGxcbiAqIGF1dG9tYXRpY2FsbHkgaW5oZXJpdCBibG9jayBhbmQgZWxlbWVudCBuYW1lcyBmcm9tIHBhcmVudCBlbGVtZW50cyBhbmQgaW5zZXJ0XG4gKiB0aGVtIGludG8gY2hpbGQgZWxlbWVudCBjbGFzc2VzXG4gKiBAbWVtYmVyT2YgX19iZW1GaWx0ZXJEZWZpbmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmV4ZWMoZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCdwcmVmZXJlbmNlcycpO1xuXHRwcmVmcy5kZWZpbmUoJ2JlbS5lbGVtZW50U2VwYXJhdG9yJywgJ19fJywgJ0NsYXNzIG5hbWXigJlzIGVsZW1lbnQgc2VwYXJhdG9yLicpO1xuXHRwcmVmcy5kZWZpbmUoJ2JlbS5tb2RpZmllclNlcGFyYXRvcicsICdfJywgJ0NsYXNzIG5hbWXigJlzIG1vZGlmaWVyIHNlcGFyYXRvci4nKTtcblx0cHJlZnMuZGVmaW5lKCdiZW0uc2hvcnRFbGVtZW50UHJlZml4JywgJy0nLCBcblx0XHRcdCdTeW1ib2wgZm9yIGRlc2NyaWJpbmcgc2hvcnQg4oCcYmxvY2stZWxlbWVudOKAnSBub3RhdGlvbi4gQ2xhc3MgbmFtZXMgJ1xuXHRcdFx0KyAncHJlZml4ZWQgd2l0aCB0aGlzIHN5bWJvbCB3aWxsIGJlIHRyZWF0ZWQgYXMgZWxlbWVudCBuYW1lIGZvciBwYXJlbnTigJhzICdcblx0XHRcdCsgJ2Jsb2NrIG5hbWUuIEVhY2ggc3ltYm9sIGluc3RhbmNlIHRyYXZlcnNlcyBvbmUgbGV2ZWwgdXAgaW4gcGFyc2VkICcgXG5cdFx0XHQrICd0cmVlIGZvciBibG9jayBuYW1lIGxvb2t1cC4gRW1wdHkgdmFsdWUgd2lsbCBkaXNhYmxlIHNob3J0IG5vdGF0aW9uLicpO1xuXHRcblx0dmFyIHNob3VsZFJ1bkh0bWxGaWx0ZXIgPSBmYWxzZTtcblx0XG5cdGZ1bmN0aW9uIGdldFNlcGFyYXRvcnMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVsZW1lbnQ6IHByZWZzLmdldCgnYmVtLmVsZW1lbnRTZXBhcmF0b3InKSxcblx0XHRcdG1vZGlmaWVyOiBwcmVmcy5nZXQoJ2JlbS5tb2RpZmllclNlcGFyYXRvcicpXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbVxuXHQgKi9cblx0ZnVuY3Rpb24gYmVtUGFyc2UoaXRlbSkge1xuXHRcdGlmIChyZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpLmlzU25pcHBldChpdGVtKSlcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFxuXHRcdC8vIHNhdmUgQkVNIHN0dWZmIGluIGNhY2hlIGZvciBmYXN0ZXIgbG9va3Vwc1xuXHRcdGl0ZW0uX19iZW0gPSB7XG5cdFx0XHRibG9jazogJycsXG5cdFx0XHRlbGVtZW50OiAnJyxcblx0XHRcdG1vZGlmaWVyOiAnJ1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGNsYXNzTmFtZXMgPSBub3JtYWxpemVDbGFzc05hbWUoaXRlbS5hdHRyaWJ1dGUoJ2NsYXNzJykpLnNwbGl0KCcgJyk7XG5cdFx0XG5cdFx0Ly8gZ3Vlc3MgYmVzdCBtYXRjaCBmb3IgYmxvY2sgbmFtZVxuXHRcdHZhciByZUJsb2NrTmFtZSA9IC9eW2Etel1cXC0vaTtcblx0XHRpdGVtLl9fYmVtLmJsb2NrID0gXy5maW5kKGNsYXNzTmFtZXMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHJldHVybiByZUJsb2NrTmFtZS50ZXN0KG5hbWUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdC8vIGd1ZXNzaW5nIGRvZXNuJ3Qgd29ya2VkLCBwaWNrIGZpcnN0IGNsYXNzIG5hbWUgYXMgYmxvY2sgbmFtZVxuXHRcdGlmICghaXRlbS5fX2JlbS5ibG9jaykge1xuXHRcdFx0cmVCbG9ja05hbWUgPSAvXlthLXpdL2k7XG5cdFx0XHRpdGVtLl9fYmVtLmJsb2NrID0gXy5maW5kKGNsYXNzTmFtZXMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHJlQmxvY2tOYW1lLnRlc3QobmFtZSk7XG5cdFx0XHR9KSB8fCAnJztcblx0XHR9XG5cdFx0XG5cdFx0Y2xhc3NOYW1lcyA9IF8uY2hhaW4oY2xhc3NOYW1lcylcblx0XHRcdC5tYXAoZnVuY3Rpb24obmFtZSkge3JldHVybiBwcm9jZXNzQ2xhc3NOYW1lKG5hbWUsIGl0ZW0pO30pXG5cdFx0XHQuZmxhdHRlbigpXG5cdFx0XHQudW5pcSgpXG5cdFx0XHQudmFsdWUoKVxuXHRcdFx0LmpvaW4oJyAnKTtcblx0XHRcblx0XHRpZiAoY2xhc3NOYW1lcylcblx0XHRcdGl0ZW0uYXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZXMpO1xuXHRcdFxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lKGNsYXNzTmFtZSkge1xuXHRcdHZhciB1dGlscyA9IHJlcXVpcmUoJ3V0aWxzJyk7XG5cdFx0Y2xhc3NOYW1lID0gKCcgJyArIChjbGFzc05hbWUgfHwgJycpICsgJyAnKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG5cdFx0XG5cdFx0dmFyIHNob3J0U3ltYm9sID0gcHJlZnMuZ2V0KCdiZW0uc2hvcnRFbGVtZW50UHJlZml4Jyk7XG5cdFx0aWYgKHNob3J0U3ltYm9sKSB7XG5cdFx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxccygnICsgdXRpbHMuZXNjYXBlRm9yUmVnZXhwKHNob3J0U3ltYm9sKSArICcrKScsICdnJyk7XG5cdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZShyZSwgZnVuY3Rpb24oc3RyLCBwMSkge1xuXHRcdFx0XHRyZXR1cm4gJyAnICsgdXRpbHMucmVwZWF0U3RyaW5nKGdldFNlcGFyYXRvcnMoKS5lbGVtZW50LCBwMS5sZW5ndGgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB1dGlscy50cmltKGNsYXNzTmFtZSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgY2xhc3MgbmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBDbGFzcyBuYW1lIGl0ZW0gdG8gcHJvY2Vzc1xuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW0gSG9zdCBub2RlIGZvciBwcm92aWRlZCBjbGFzcyBuYW1lXG5cdCAqIEByZXR1cm5zIFByb2Nlc3NlZCBjbGFzcyBuYW1lLiBNYXkgcmV0dXJuIDxjb2RlPkFycmF5PC9jb2RlPiBvZlxuXHQgKiBjbGFzcyBuYW1lcyBcblx0ICovXG5cdGZ1bmN0aW9uIHByb2Nlc3NDbGFzc05hbWUobmFtZSwgaXRlbSkge1xuXHRcdG5hbWUgPSB0cmFuc2Zvcm1DbGFzc05hbWUobmFtZSwgaXRlbSwgJ2VsZW1lbnQnKTtcblx0XHRuYW1lID0gdHJhbnNmb3JtQ2xhc3NOYW1lKG5hbWUsIGl0ZW0sICdtb2RpZmllcicpO1xuXHRcdFxuXHRcdC8vIGV4cGFuZCBjbGFzcyBuYW1lXG5cdFx0Ly8gcG9zc2libGUgdmFsdWVzOlxuXHRcdC8vICogYmxvY2tfX2VsZW1lbnRcblx0XHQvLyAqIGJsb2NrX19lbGVtZW50X21vZGlmaWVyXG5cdFx0Ly8gKiBibG9ja19fZWxlbWVudF9tb2RpZmllcjFfbW9kaWZpZXIyXG5cdFx0Ly8gKiBibG9ja19tb2RpZmllclxuXHRcdHZhciBibG9jayA9ICcnLCBlbGVtZW50ID0gJycsIG1vZGlmaWVyID0gJyc7XG5cdFx0dmFyIHNlcGFyYXRvcnMgPSBnZXRTZXBhcmF0b3JzKCk7XG5cdFx0aWYgKH5uYW1lLmluZGV4T2Yoc2VwYXJhdG9ycy5lbGVtZW50KSkge1xuXHRcdFx0dmFyIGJsb2NrRWxlbSA9IG5hbWUuc3BsaXQoc2VwYXJhdG9ycy5lbGVtZW50KTtcblx0XHRcdHZhciBlbGVtTW9kaWZpZXJzID0gYmxvY2tFbGVtWzFdLnNwbGl0KHNlcGFyYXRvcnMubW9kaWZpZXIpO1xuXHRcdFx0XG5cdFx0XHRibG9jayA9IGJsb2NrRWxlbVswXTtcblx0XHRcdGVsZW1lbnQgPSBlbGVtTW9kaWZpZXJzLnNoaWZ0KCk7XG5cdFx0XHRtb2RpZmllciA9IGVsZW1Nb2RpZmllcnMuam9pbihzZXBhcmF0b3JzLm1vZGlmaWVyKTtcblx0XHR9IGVsc2UgaWYgKH5uYW1lLmluZGV4T2Yoc2VwYXJhdG9ycy5tb2RpZmllcikpIHtcblx0XHRcdHZhciBibG9ja01vZGlmaWVycyA9IG5hbWUuc3BsaXQoc2VwYXJhdG9ycy5tb2RpZmllcik7XG5cdFx0XHRcblx0XHRcdGJsb2NrID0gYmxvY2tNb2RpZmllcnMuc2hpZnQoKTtcblx0XHRcdG1vZGlmaWVyID0gYmxvY2tNb2RpZmllcnMuam9pbihzZXBhcmF0b3JzLm1vZGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGJsb2NrIHx8IGVsZW1lbnQgfHwgbW9kaWZpZXIpIHtcblx0XHRcdGlmICghYmxvY2spIHtcblx0XHRcdFx0YmxvY2sgPSBpdGVtLl9fYmVtLmJsb2NrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBpbmhlcml0IHBhcmVudCBiZW0gZWxlbWVudCwgaWYgZXhpc3RzXG4vL1x0XHRcdGlmIChpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5fX2JlbSAmJiBpdGVtLnBhcmVudC5fX2JlbS5lbGVtZW50KVxuLy9cdFx0XHRcdGVsZW1lbnQgPSBpdGVtLnBhcmVudC5fX2JlbS5lbGVtZW50ICsgc2VwYXJhdG9ycy5lbGVtZW50ICsgZWxlbWVudDtcblx0XHRcdFxuXHRcdFx0Ly8gcHJvZHVjZSBtdWx0aXBsZSBjbGFzc2VzXG5cdFx0XHR2YXIgcHJlZml4ID0gYmxvY2s7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHRcblx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdHByZWZpeCArPSBzZXBhcmF0b3JzLmVsZW1lbnQgKyBlbGVtZW50O1xuXHRcdFx0XHRyZXN1bHQucHVzaChwcmVmaXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2gocHJlZml4KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHByZWZpeCArIHNlcGFyYXRvcnMubW9kaWZpZXIgKyBtb2RpZmllcik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGl0ZW0uX19iZW0uYmxvY2sgPSBibG9jaztcblx0XHRcdGl0ZW0uX19iZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRpdGVtLl9fYmVtLm1vZGlmaWVyID0gbW9kaWZpZXI7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIC4uLm90aGVyd2lzZSwgcmV0dXJuIHByb2Nlc3NlZCBvciBvcmlnaW5hbCBjbGFzcyBuYW1lXG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBMb3ctbGV2ZWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHVzZXItdHlwZWQgY2xhc3MgbmFtZSBpbnRvIGZ1bGwgQkVNIGNsYXNzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIENsYXNzIG5hbWUgaXRlbSB0byBwcm9jZXNzXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbSBIb3N0IG5vZGUgZm9yIHByb3ZpZGVkIGNsYXNzIG5hbWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVudGl0eVR5cGUgVHlwZSBvZiBlbnRpdHkgdG8gYmUgdHJpZWQgdG8gdHJhbnNmb3JtIFxuXHQgKiAoJ2VsZW1lbnQnIG9yICdtb2RpZmllcicpXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2Nlc3NlZCBjbGFzcyBuYW1lIG9yIG9yaWdpbmFsIG9uZSBpZiBpdCBjYW4ndCBiZVxuXHQgKiB0cmFuc2Zvcm1lZFxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NOYW1lKG5hbWUsIGl0ZW0sIGVudGl0eVR5cGUpIHtcblx0XHR2YXIgc2VwYXJhdG9ycyA9IGdldFNlcGFyYXRvcnMoKTtcblx0XHR2YXIgcmVTZXAgPSBuZXcgUmVnRXhwKCdeKCcgKyBzZXBhcmF0b3JzW2VudGl0eVR5cGVdICsgJykrJywgJ2cnKTtcblx0XHRpZiAocmVTZXAudGVzdChuYW1lKSkge1xuXHRcdFx0dmFyIGRlcHRoID0gMDsgLy8gcGFyZW50IGxvb2t1cCBkZXB0aFxuXHRcdFx0dmFyIGNsZWFuTmFtZSA9IG5hbWUucmVwbGFjZShyZVNlcCwgZnVuY3Rpb24oc3RyLCBwMSkge1xuXHRcdFx0XHRkZXB0aCA9IHN0ci5sZW5ndGggLyBzZXBhcmF0b3JzW2VudGl0eVR5cGVdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIGZpbmQgZG9ub3IgZWxlbWVudFxuXHRcdFx0dmFyIGRvbm9yID0gaXRlbTtcblx0XHRcdHdoaWxlIChkb25vci5wYXJlbnQgJiYgZGVwdGgtLSkge1xuXHRcdFx0XHRkb25vciA9IGRvbm9yLnBhcmVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFkb25vciB8fCAhZG9ub3IuX19iZW0pXG5cdFx0XHRcdGRvbm9yID0gaXRlbTtcblx0XHRcdFxuXHRcdFx0aWYgKGRvbm9yICYmIGRvbm9yLl9fYmVtKSB7XG5cdFx0XHRcdHZhciBwcmVmaXggPSBkb25vci5fX2JlbS5ibG9jaztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGRlY2lkZSBpZiB3ZSBzaG91bGQgaW5oZXJpdCBlbGVtZW50IG5hbWVcbi8vXHRcdFx0XHRpZiAoZW50aXR5VHlwZSA9PSAnZWxlbWVudCcpIHtcbi8vXHRcdFx0XHRcdHZhciBjdXJFbGVtID0gY2xlYW5OYW1lLnNwbGl0KHNlcGFyYXRvcnMubW9kaWZpZXIsIDEpWzBdO1xuLy9cdFx0XHRcdFx0aWYgKGRvbm9yLl9fYmVtLmVsZW1lbnQgJiYgZG9ub3IuX19iZW0uZWxlbWVudCAhPSBjdXJFbGVtKVxuLy9cdFx0XHRcdFx0XHRwcmVmaXggKz0gc2VwYXJhdG9ycy5lbGVtZW50ICsgZG9ub3IuX19iZW0uZWxlbWVudDtcbi8vXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZW50aXR5VHlwZSA9PSAnbW9kaWZpZXInICYmICBkb25vci5fX2JlbS5lbGVtZW50KVxuXHRcdFx0XHRcdHByZWZpeCArPSBzZXBhcmF0b3JzLmVsZW1lbnQgKyBkb25vci5fX2JlbS5lbGVtZW50O1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHByZWZpeCArIHNlcGFyYXRvcnNbZW50aXR5VHlwZV0gKyBjbGVhbk5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmVjdXJzaXZlIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIHRhZ3MsIHdoaWNoIGV4dGVuZHMgY2xhc3MgbmFtZXMgXG5cdCAqIGFjY29yZGluZyB0byBCRU0gc3BlY3M6IGh0dHA6Ly9iZW0uZ2l0aHViLmNvbS9iZW0tbWV0aG9kL3BhZ2VzL2JlZ2lubmluZy9iZWdpbm5pbmcucnUuaHRtbFxuXHQgKiA8YnI+PGJyPlxuXHQgKiBJdCBkb2VzIHNldmVyYWwgdGhpbmdzOjxicj5cblx0ICogPHVsPlxuXHQgKiA8bGk+RXhwYW5kcyBjb21wbGV4IGNsYXNzIG5hbWUgKGFjY29yZGluZyB0byBCRU0gc3ltYm9sIHNlbWFudGljcyk6XG5cdCAqIC5ibG9ja19fZWxlbV9tb2RpZmllciDihpIgLmJsb2NrLmJsb2NrX19lbGVtLmJsb2NrX19lbGVtX21vZGlmaWVyXG5cdCAqIDwvbGk+XG5cdCAqIDxsaT5Jbmhlcml0cyBibG9jayBuYW1lIG9uIGNoaWxkIGVsZW1lbnRzOiBcblx0ICogLmItYmxvY2sgPiAuX19lbCA+IC5fX2VsIOKGkiAuYi1ibG9jayA+IC5iLWJsb2NrX19lbCA+IC5iLWJsb2NrX19lbF9fZWxcblx0ICogPC9saT5cblx0ICogPGxpPlRyZWF0cyBmaXJzdCBkYXNoIHN5bWJvbCBhcyAnX18nPC9saT5cblx0ICogPGxpPkRvdWJsZSB1bmRlcnNjb3JlIChvciB0eXBvZ3JhcGhpYyAn4oCTJykgaXMgYWxzbyB0cmVhdGVkIGFzIGFuIGVsZW1lbnQgXG5cdCAqIGxldmVsIGxvb2t1cCwgZS5nLiBfX19fZWwgd2lsbCBzZWFyY2ggZm9yIGVsZW1lbnQgZGVmaW5pdGlvbiBpbiBwYXJlbnTigJlzIFxuXHQgKiBwYXJlbnQgZWxlbWVudDpcblx0ICogLmItYmxvY2sgPiAuX19lbDEgPiAuX19fX2VsMiDihpIgLmItYmxvY2sgPiAuYi1ibG9ja19fZWwxID4gLmItYmxvY2tfX2VsMlxuXHQgKiA8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSB0cmVlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9jZXNzKHRyZWUsIHByb2ZpbGUpIHtcblx0XHRpZiAodHJlZS5uYW1lKVxuXHRcdFx0YmVtUGFyc2UodHJlZSwgcHJvZmlsZSk7XG5cdFx0XG5cdFx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJ2FiYnJldmlhdGlvblV0aWxzJyk7XG5cdFx0Xy5lYWNoKHRyZWUuY2hpbGRyZW4sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHByb2Nlc3MoaXRlbSwgcHJvZmlsZSk7XG5cdFx0XHRpZiAoIWFiYnJVdGlscy5pc1NuaXBwZXQoaXRlbSkgJiYgaXRlbS5zdGFydClcblx0XHRcdFx0c2hvdWxkUnVuSHRtbEZpbHRlciA9IHRydWU7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH07XG5cdFxuXHRyZXF1aXJlKCdmaWx0ZXJzJykuYWRkKCdiZW0nLCBmdW5jdGlvbih0cmVlLCBwcm9maWxlKSB7XG5cdFx0c2hvdWxkUnVuSHRtbEZpbHRlciA9IGZhbHNlO1xuXHRcdHRyZWUgPSBwcm9jZXNzKHRyZWUsIHByb2ZpbGUpO1xuXHRcdC8vIGluIGNhc2UgJ2JlbScgZmlsdGVyIGlzIGFwcGxpZWQgYWZ0ZXIgJ2h0bWwnIGZpbHRlcjogcnVuIGl0IGFnYWluXG5cdFx0Ly8gdG8gdXBkYXRlIG91dHB1dFxuXHRcdGlmIChzaG91bGRSdW5IdG1sRmlsdGVyKSB7XG5cdFx0XHR0cmVlID0gcmVxdWlyZSgnZmlsdGVycycpLmFwcGx5KHRyZWUsICdodG1sJywgcHJvZmlsZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9KTtcbn0pO1xuXG4vKipcbiAqIENvbW1lbnQgaW1wb3J0YW50IHRhZ3MgKHdpdGggJ2lkJyBhbmQgJ2NsYXNzJyBhdHRyaWJ1dGVzKVxuICogQGF1dGhvciBTZXJnZXkgQ2hpa3V5b25vayAoc2VyZ2UuY2hlQGdtYWlsLmNvbSlcbiAqIEBsaW5rIGh0dHA6Ly9jaGlrdXlvbm9rLnJ1XG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX2NvbW1lbnRGaWx0ZXJEZWZpbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0Ly8gZGVmaW5lIHNvbWUgcHJlZmVyZW5jZXNcblx0LyoqIEB0eXBlIGVtbWV0LnByZWZlcmVuY2VzICovXG5cdHZhciBwcmVmcyA9IHJlcXVpcmUoJ3ByZWZlcmVuY2VzJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2ZpbHRlci5jb21tZW50QWZ0ZXInLCBcblx0XHRcdCdcXG48IS0tIC88JT0gYXR0cihcImlkXCIsIFwiI1wiKSAlPjwlPSBhdHRyKFwiY2xhc3NcIiwgXCIuXCIpICU+IC0tPicsXG5cdFx0XHQnQSBkZWZpbml0aW9uIG9mIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgcGxhY2VkIDxpPmFmdGVyPC9pPiBtYXRjaGVkICdcblx0XHRcdCsgJ2VsZW1lbnQgd2hlbiA8Y29kZT5jb21tZW50PC9jb2RlPiBmaWx0ZXIgaXMgYXBwbGllZC4gVGhpcyBkZWZpbml0aW9uICdcblx0XHRcdCsgJ2lzIGFuIEVSQi1zdHlsZSB0ZW1wbGF0ZSBwYXNzZWQgdG8gPGNvZGU+Xy50ZW1wbGF0ZSgpPC9jb2RlPiAnXG5cdFx0XHQrICdmdW5jdGlvbiAoc2VlIFVuZGVyc2NvcmUuanMgZG9jcyBmb3IgZGV0YWlscykuIEluIHRlbXBsYXRlIGNvbnRleHQsICdcblx0XHRcdCsgJ3RoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zIGFyZSBhdmFpbGFiZTpcXG4nXG5cdFx0XHQrICc8dWw+J1xuXHRcdFx0XG5cdFx0XHQrICc8bGk+PGNvZGU+YXR0cihuYW1lLCBiZWZvcmUsIGFmdGVyKTwvY29kZT4g4oCTIGEgZnVuY3Rpb24gdGhhdCBvdXRwdXRzJyBcblx0XHRcdCsgJ3NwZWNpZmllZCBhdHRyaWJ1dGUgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggPGNvZGU+YmVmb3JlPC9jb2RlPiAnIFxuXHRcdFx0KyAnYW5kIDxjb2RlPmFmdGVyPC9jb2RlPiBzdHJpbmdzLiBJZiBhdHRyaWJ1dGUgZG9lc25cXCd0IGV4aXN0cywgdGhlICcgXG5cdFx0XHQrICdlbXB0eSBzdHJpbmcgd2lsbCBiZSByZXR1cm5lZC48L2xpPidcblx0XHRcdFxuXHRcdFx0KyAnPGxpPjxjb2RlPm5vZGU8L2NvZGU+IOKAkyBjdXJyZW50IG5vZGUgKGluc3RhbmNlIG9mIDxjb2RlPkFiYnJldmlhdGlvbk5vZGU8L2NvZGU+KTwvbGk+J1xuXHRcdFx0XG5cdFx0XHQrICc8bGk+PGNvZGU+bmFtZTwvY29kZT4g4oCTIG5hbWUgb2YgY3VycmVudCB0YWc8L2xpPidcblx0XHRcdFxuXHRcdFx0KyAnPGxpPjxjb2RlPnBhZGRpbmc8L2NvZGU+IOKAkyBjdXJyZW50IHN0cmluZyBwYWRkaW5nLCBjYW4gYmUgdXNlZCAnIFxuXHRcdFx0KyAnZm9yIGZvcm1hdHRpbmc8L2xpPidcblx0XHRcdFxuXHRcdFx0Kyc8L3VsPicpO1xuXHRcblx0cHJlZnMuZGVmaW5lKCdmaWx0ZXIuY29tbWVudEJlZm9yZScsIFxuXHRcdFx0JycsXG5cdFx0XHQnQSBkZWZpbml0aW9uIG9mIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgcGxhY2VkIDxpPmJlZm9yZTwvaT4gbWF0Y2hlZCAnXG5cdFx0XHQrICdlbGVtZW50IHdoZW4gPGNvZGU+Y29tbWVudDwvY29kZT4gZmlsdGVyIGlzIGFwcGxpZWQuICdcblx0XHRcdCsgJ0ZvciBtb3JlIGluZm8sIHJlYWQgZGVzY3JpcHRpb24gb2YgPGNvZGU+ZmlsdGVyLmNvbW1lbnRBZnRlcjwvY29kZT4gJ1xuXHRcdFx0KyAncHJvcGVydHknKTtcblx0XG5cdHByZWZzLmRlZmluZSgnZmlsdGVyLmNvbW1lbnRUcmlnZ2VyJywgJ2lkLCBjbGFzcycsXG5cdFx0XHQnQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBzaG91bGQgZXhpc3QgaW4gYWJicmV2aWF0b2luICdcblx0XHRcdCsgJ3doZXJlIGNvbW1lbnQgc2hvdWxkIGJlIGFkZGVkLiBJZiB5b3Ugd2lzaCB0byBhZGQgY29tbWVudCBmb3IgJ1xuXHRcdFx0KyAnZXZlcnkgZWxlbWVudCwgc2V0IHRoaXMgb3B0aW9uIHRvIDxjb2RlPio8L2NvZGU+Jyk7XG5cdFxuXHQvKipcblx0ICogQWRkIGNvbW1lbnRzIHRvIHRhZ1xuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkZENvbW1lbnRzKG5vZGUsIHRlbXBsYXRlQmVmb3JlLCB0ZW1wbGF0ZUFmdGVyKSB7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcblx0XHQvLyBjaGVjayBpZiBjb21tZW50cyBzaG91bGQgYmUgYWRkZWRcblx0XHR2YXIgdHJpZ2dlciA9IHByZWZzLmdldCgnZmlsdGVyLmNvbW1lbnRUcmlnZ2VyJyk7XG5cdFx0aWYgKHRyaWdnZXIgIT0gJyonKSB7XG5cdFx0XHR2YXIgc2hvdWxkQWRkID0gXy5maW5kKHRyaWdnZXIuc3BsaXQoJywnKSwgZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gISFub2RlLmF0dHJpYnV0ZSh1dGlscy50cmltKG5hbWUpKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCFzaG91bGRBZGQpIHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0dmFyIGN0eCA9IHtcblx0XHRcdG5vZGU6IG5vZGUsXG5cdFx0XHRuYW1lOiBub2RlLm5hbWUoKSxcblx0XHRcdHBhZGRpbmc6IG5vZGUucGFyZW50ID8gbm9kZS5wYXJlbnQucGFkZGluZyA6ICcnLFxuXHRcdFx0YXR0cjogZnVuY3Rpb24obmFtZSwgYmVmb3JlLCBhZnRlcikge1xuXHRcdFx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRpZiAoYXR0cikge1xuXHRcdFx0XHRcdHJldHVybiAoYmVmb3JlIHx8ICcnKSArIGF0dHIgKyAoYWZ0ZXIgfHwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgbm9kZUJlZm9yZSA9IHV0aWxzLm5vcm1hbGl6ZU5ld2xpbmUodGVtcGxhdGVCZWZvcmUgPyB0ZW1wbGF0ZUJlZm9yZShjdHgpIDogJycpO1xuXHRcdHZhciBub2RlQWZ0ZXIgPSB1dGlscy5ub3JtYWxpemVOZXdsaW5lKHRlbXBsYXRlQWZ0ZXIgPyB0ZW1wbGF0ZUFmdGVyKGN0eCkgOiAnJyk7XG5cdFx0XG5cdFx0bm9kZS5zdGFydCA9IG5vZGUuc3RhcnQucmVwbGFjZSgvPC8sIG5vZGVCZWZvcmUgKyAnPCcpO1xuXHRcdG5vZGUuZW5kID0gbm9kZS5lbmQucmVwbGFjZSgvPi8sICc+JyArIG5vZGVBZnRlcik7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHByb2Nlc3ModHJlZSwgYmVmb3JlLCBhZnRlcikge1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdF8uZWFjaCh0cmVlLmNoaWxkcmVuLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoYWJiclV0aWxzLmlzQmxvY2soaXRlbSkpXG5cdFx0XHRcdGFkZENvbW1lbnRzKGl0ZW0sIGJlZm9yZSwgYWZ0ZXIpO1xuXHRcdFx0XG5cdFx0XHRwcm9jZXNzKGl0ZW0sIGJlZm9yZSwgYWZ0ZXIpO1xuXHRcdH0pO1xuXHRcdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH1cblx0XG5cdHJlcXVpcmUoJ2ZpbHRlcnMnKS5hZGQoJ2MnLCBmdW5jdGlvbih0cmVlKSB7XG5cdFx0dmFyIHRlbXBsYXRlQmVmb3JlID0gXy50ZW1wbGF0ZShwcmVmcy5nZXQoJ2ZpbHRlci5jb21tZW50QmVmb3JlJykpO1xuXHRcdHZhciB0ZW1wbGF0ZUFmdGVyID0gXy50ZW1wbGF0ZShwcmVmcy5nZXQoJ2ZpbHRlci5jb21tZW50QWZ0ZXInKSk7XG5cdFx0XG5cdFx0cmV0dXJuIHByb2Nlc3ModHJlZSwgdGVtcGxhdGVCZWZvcmUsIHRlbXBsYXRlQWZ0ZXIpO1xuXHR9KTtcbn0pO1xuLyoqXG4gKiBGaWx0ZXIgZm9yIGVzY2FwaW5nIHVuc2FmZSBYTUwgY2hhcmFjdGVyczogPCwgPiwgJlxuICogQGF1dGhvciBTZXJnZXkgQ2hpa3V5b25vayAoc2VyZ2UuY2hlQGdtYWlsLmNvbSlcbiAqIEBsaW5rIGh0dHA6Ly9jaGlrdXlvbm9rLnJ1XG4gKi9cbmVtbWV0LmV4ZWMoZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHR2YXIgY2hhck1hcCA9IHtcblx0XHQnPCc6ICcmbHQ7Jyxcblx0XHQnPic6ICcmZ3Q7Jyxcblx0XHQnJic6ICcmYW1wOydcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGVzY2FwZUNoYXJzKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvKFs8PiZdKS9nLCBmdW5jdGlvbihzdHIsIHAxKXtcblx0XHRcdHJldHVybiBjaGFyTWFwW3AxXTtcblx0XHR9KTtcblx0fVxuXHRcblx0cmVxdWlyZSgnZmlsdGVycycpLmFkZCgnZScsIGZ1bmN0aW9uIHByb2Nlc3ModHJlZSkge1xuXHRcdF8uZWFjaCh0cmVlLmNoaWxkcmVuLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpdGVtLnN0YXJ0ID0gZXNjYXBlQ2hhcnMoaXRlbS5zdGFydCk7XG5cdFx0XHRpdGVtLmVuZCA9IGVzY2FwZUNoYXJzKGl0ZW0uZW5kKTtcblx0XHRcdGl0ZW0uY29udGVudCA9IGVzY2FwZUNoYXJzKGl0ZW0uY29udGVudCk7XG5cdFx0XHRwcm9jZXNzKGl0ZW0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9KTtcbn0pOy8qKlxuICogR2VuZXJpYyBmb3JtYXR0aW5nIGZpbHRlcjogY3JlYXRlcyBwcm9wZXIgaW5kZW50YXRpb24gZm9yIGVhY2ggdHJlZSBub2RlLFxuICogcGxhY2luZyBcIiVzXCIgcGxhY2Vob2xkZXIgd2hlcmUgdGhlIGFjdHVhbCBvdXRwdXQgc2hvdWxkIGJlLiBZb3UgY2FuIHVzZVxuICogdGhpcyBmaWx0ZXIgdG8gcHJlZm9ybWF0IHRyZWUgYW5kIHRoZW4gcmVwbGFjZSAlcyBwbGFjZWhvbGRlciB0byB3aGF0ZXZlciB5b3VcbiAqIG5lZWQuIFRoaXMgZmlsdGVyIHNob3VsZCd0IGJlIGNhbGxlZCBkaXJlY3RseSBmcm9tIGVkaXRvciBhcyBhIHBhcnQgXG4gKiBvZiBhYmJyZXZpYXRpb24uXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKVxuICogQGxpbmsgaHR0cDovL2NoaWt1eW9ub2sucnVcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1lbWJlck9mIF9fZm9ybWF0RmlsdGVyRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKXtcblx0dmFyIHBsYWNlaG9sZGVyID0gJyVzJztcblx0XG5cdC8qKiBAdHlwZSBwcmVmZXJlbmNlcyAqL1xuXHR2YXIgcHJlZnMgPSByZXF1aXJlKCdwcmVmZXJlbmNlcycpO1xuXHRwcmVmcy5kZWZpbmUoJ2Zvcm1hdC5ub0luZGVudFRhZ3MnLCAnaHRtbCcsIFxuXHRcdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkIG5vdCBnZXQgaW5uZXIgaW5kZW50YXRpb24uJyk7XG5cdFxuXHRwcmVmcy5kZWZpbmUoJ2Zvcm1hdC5mb3JjZUluZGVudGF0aW9uRm9yVGFncycsICdib2R5JywgXG5cdFx0J0EgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkIDxlbT5hbHdheXM8L2VtPiBnZXQgaW5uZXIgaW5kZW50YXRpb24uJyk7XG5cdFxuXHQvKipcblx0ICogR2V0IGluZGVudGF0aW9uIGZvciBnaXZlbiBub2RlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gbm9kZVxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24obm9kZSkge1xuXHRcdGlmIChfLmluY2x1ZGUocHJlZnMuZ2V0QXJyYXkoJ2Zvcm1hdC5ub0luZGVudFRhZ3MnKSB8fCBbXSwgbm9kZS5uYW1lKCkpKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiByZXF1aXJlKCdyZXNvdXJjZXMnKS5nZXRWYXJpYWJsZSgnaW5kZW50YXRpb24nKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRlc3QgaWYgcGFzc2VkIG5vZGUgaGFzIGJsb2NrLWxldmVsIHNpYmxpbmcgZWxlbWVudFxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW1cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGhhc0Jsb2NrU2libGluZyhpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0ucGFyZW50ICYmIHJlcXVpcmUoJ2FiYnJldmlhdGlvblV0aWxzJykuaGFzQmxvY2tDaGlsZHJlbihpdGVtLnBhcmVudCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUZXN0IGlmIHBhc3NlZCBpdGVtIGlzIHZlcnkgZmlyc3QgY2hpbGQgaW4gcGFyc2VkIHRyZWVcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1ZlcnlGaXJzdENoaWxkKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5wYXJlbnQgJiYgIWl0ZW0ucGFyZW50LnBhcmVudCAmJiAhaXRlbS5pbmRleCgpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBuZXdsaW5lIHNob3VsZCBiZSBhZGRlZCBiZWZvcmUgZWxlbWVudFxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBzaG91bGRBZGRMaW5lQnJlYWsobm9kZSwgcHJvZmlsZSkge1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdGlmIChwcm9maWxlLnRhZ19ubCA9PT0gdHJ1ZSB8fCBhYmJyVXRpbHMuaXNCbG9jayhub2RlKSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFxuXHRcdGlmICghbm9kZS5wYXJlbnQgfHwgIXByb2ZpbGUuaW5saW5lX2JyZWFrKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdC8vIGNoZWNrIGlmIHRoZXJlIGFyZSByZXF1aXJlZCBhbW91bnQgb2YgYWRqYWNlbnQgaW5saW5lIGVsZW1lbnRcblx0XHRyZXR1cm4gc2hvdWxkRm9ybWF0SW5saW5lKG5vZGUucGFyZW50LCBwcm9maWxlKTtcbn1cblx0XG5cdC8qKlxuXHQgKiBOZWVkIHRvIGFkZCBuZXdsaW5lIGJlY2F1c2UgPGNvZGU+aXRlbTwvY29kZT4gaGFzIHRvbyBtYW55IGlubGluZSBjaGlsZHJlblxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBzaG91bGRCcmVha0NoaWxkKG5vZGUsIHByb2ZpbGUpIHtcblx0XHQvLyB3ZSBuZWVkIHRvIHRlc3Qgb25seSBvbmUgY2hpbGQgZWxlbWVudCwgYmVjYXVzZSBcblx0XHQvLyBoYXNCbG9ja0NoaWxkcmVuKCkgbWV0aG9kIHdpbGwgZG8gdGhlIHJlc3Rcblx0XHRyZXR1cm4gbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgc2hvdWxkQWRkTGluZUJyZWFrKG5vZGUuY2hpbGRyZW5bMF0sIHByb2ZpbGUpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzaG91bGRGb3JtYXRJbmxpbmUobm9kZSwgcHJvZmlsZSkge1xuXHRcdHZhciBub2RlQ291bnQgPSAwO1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdHJldHVybiAhIV8uZmluZChub2RlLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkLmlzVGV4dE5vZGUoKSB8fCAhYWJiclV0aWxzLmlzSW5saW5lKGNoaWxkKSlcblx0XHRcdFx0bm9kZUNvdW50ID0gMDtcblx0XHRcdGVsc2UgaWYgKGFiYnJVdGlscy5pc0lubGluZShjaGlsZCkpXG5cdFx0XHRcdG5vZGVDb3VudCsrO1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZUNvdW50ID49IHByb2ZpbGUuaW5saW5lX2JyZWFrKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNSb290KGl0ZW0pIHtcblx0XHRyZXR1cm4gIWl0ZW0ucGFyZW50O1xuXHR9XG5cdFxuXHQvKipcblx0ICogUHJvY2Vzc2VzIGVsZW1lbnQgd2l0aCBtYXRjaGVkIHJlc291cmNlIG9mIHR5cGUgPGNvZGU+c25pcHBldDwvY29kZT5cblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqIEBwYXJhbSB7T3V0cHV0UHJvZmlsZX0gcHJvZmlsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgRGVwdGggbGV2ZWxcblx0ICovXG5cdGZ1bmN0aW9uIHByb2Nlc3NTbmlwcGV0KGl0ZW0sIHByb2ZpbGUsIGxldmVsKSB7XG5cdFx0aXRlbS5zdGFydCA9IGl0ZW0uZW5kID0gJyc7XG5cdFx0aWYgKCFpc1ZlcnlGaXJzdENoaWxkKGl0ZW0pICYmIHByb2ZpbGUudGFnX25sICE9PSBmYWxzZSAmJiBzaG91bGRBZGRMaW5lQnJlYWsoaXRlbSwgcHJvZmlsZSkpIHtcblx0XHRcdC8vIGNoZWNrIGlmIHdl4oCZcmUgbm90IGluc2lkZSBpbmxpbmUgZWxlbWVudFxuXHRcdFx0aWYgKGlzUm9vdChpdGVtLnBhcmVudCkgfHwgIXJlcXVpcmUoJ2FiYnJldmlhdGlvblV0aWxzJykuaXNJbmxpbmUoaXRlbS5wYXJlbnQpKSB7XG5cdFx0XHRcdGl0ZW0uc3RhcnQgPSByZXF1aXJlKCd1dGlscycpLmdldE5ld2xpbmUoKSArIGl0ZW0uc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgd2Ugc2hvdWxkIGFkZCBsaW5lIGJyZWFrcyBpbnNpZGUgaW5saW5lIGVsZW1lbnRcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqIEBwYXJhbSB7T3V0cHV0UHJvZmlsZX0gcHJvZmlsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gc2hvdWxkQnJlYWtJbnNpZGVJbmxpbmUobm9kZSwgcHJvZmlsZSkge1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdHZhciBoYXNCbG9ja0VsZW1zID0gXy5hbnkobm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcblx0XHRcdGlmIChhYmJyVXRpbHMuaXNTbmlwcGV0KGNoaWxkKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gIWFiYnJVdGlscy5pc0lubGluZShjaGlsZCk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKCFoYXNCbG9ja0VsZW1zKSB7XG5cdFx0XHRyZXR1cm4gc2hvdWxkRm9ybWF0SW5saW5lKG5vZGUsIHByb2ZpbGUpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBlbGVtZW50IHdpdGggPGNvZGU+dGFnPC9jb2RlPiB0eXBlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbVxuXHQgKiBAcGFyYW0ge091dHB1dFByb2ZpbGV9IHByb2ZpbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIERlcHRoIGxldmVsXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUsIGxldmVsKSB7XG5cdFx0aXRlbS5zdGFydCA9IGl0ZW0uZW5kID0gcGxhY2Vob2xkZXI7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHR2YXIgYWJiclV0aWxzID0gcmVxdWlyZSgnYWJicmV2aWF0aW9uVXRpbHMnKTtcblx0XHR2YXIgaXNVbmFyeSA9IGFiYnJVdGlscy5pc1VuYXJ5KGl0ZW0pO1xuXHRcdHZhciBubCA9IHV0aWxzLmdldE5ld2xpbmUoKTtcblx0XHR2YXIgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oaXRlbSk7XG5cdFx0XHRcblx0XHQvLyBmb3JtYXR0aW5nIG91dHB1dFxuXHRcdGlmIChwcm9maWxlLnRhZ19ubCAhPT0gZmFsc2UpIHtcblx0XHRcdHZhciBmb3JjZU5sID0gcHJvZmlsZS50YWdfbmwgPT09IHRydWUgJiYgKHByb2ZpbGUudGFnX25sX2xlYWYgfHwgaXRlbS5jaGlsZHJlbi5sZW5ndGgpO1xuXHRcdFx0aWYgKCFmb3JjZU5sKSB7XG5cdFx0XHRcdGZvcmNlTmwgPSBfLmluY2x1ZGUocHJlZnMuZ2V0QXJyYXkoJ2Zvcm1hdC5mb3JjZUluZGVudGF0aW9uRm9yVGFncycpIHx8IFtdLCBpdGVtLm5hbWUoKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGZvcm1hdHRpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHNcblx0XHRcdGlmICghaXRlbS5pc1RleHROb2RlKCkpIHtcblx0XHRcdFx0aWYgKHNob3VsZEFkZExpbmVCcmVhayhpdGVtLCBwcm9maWxlKSkge1xuXHRcdFx0XHRcdC8vIC0gZG8gbm90IGluZGVudCB0aGUgdmVyeSBmaXJzdCBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gLSBkbyBub3QgaW5kZW50IGZpcnN0IGNoaWxkIG9mIGEgc25pcHBldFxuXHRcdFx0XHRcdGlmICghaXNWZXJ5Rmlyc3RDaGlsZChpdGVtKSAmJiAoIWFiYnJVdGlscy5pc1NuaXBwZXQoaXRlbS5wYXJlbnQpIHx8IGl0ZW0uaW5kZXgoKSkpXG5cdFx0XHRcdFx0XHRpdGVtLnN0YXJ0ID0gbmwgKyBpdGVtLnN0YXJ0O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGFiYnJVdGlscy5oYXNCbG9ja0NoaWxkcmVuKGl0ZW0pIHx8IHNob3VsZEJyZWFrQ2hpbGQoaXRlbSwgcHJvZmlsZSkgfHwgKGZvcmNlTmwgJiYgIWlzVW5hcnkpKVxuXHRcdFx0XHRcdFx0aXRlbS5lbmQgPSBubCArIGl0ZW0uZW5kO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGFiYnJVdGlscy5oYXNUYWdzSW5Db250ZW50KGl0ZW0pIHx8IChmb3JjZU5sICYmICFpdGVtLmNoaWxkcmVuLmxlbmd0aCAmJiAhaXNVbmFyeSkpXG5cdFx0XHRcdFx0XHRpdGVtLnN0YXJ0ICs9IG5sICsgaW5kZW50O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFiYnJVdGlscy5pc0lubGluZShpdGVtKSAmJiBoYXNCbG9ja1NpYmxpbmcoaXRlbSkgJiYgIWlzVmVyeUZpcnN0Q2hpbGQoaXRlbSkpIHtcblx0XHRcdFx0XHRpdGVtLnN0YXJ0ID0gbmwgKyBpdGVtLnN0YXJ0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFiYnJVdGlscy5pc0lubGluZShpdGVtKSAmJiBzaG91bGRCcmVha0luc2lkZUlubGluZShpdGVtLCBwcm9maWxlKSkge1xuXHRcdFx0XHRcdGl0ZW0uZW5kID0gbmwgKyBpdGVtLmVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aXRlbS5wYWRkaW5nID0gaW5kZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBzaW1wbGlmaWVkIHRyZWUsIG1ha2luZyBpdCBzdWl0YWJsZSBmb3Igb3V0cHV0IGFzIEhUTUwgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKiBAcGFyYW0ge091dHB1dFByb2ZpbGV9IHByb2ZpbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIERlcHRoIGxldmVsXG5cdCAqL1xuXHRyZXF1aXJlKCdmaWx0ZXJzJykuYWRkKCdfZm9ybWF0JywgZnVuY3Rpb24gcHJvY2Vzcyh0cmVlLCBwcm9maWxlLCBsZXZlbCkge1xuXHRcdGxldmVsID0gbGV2ZWwgfHwgMDtcblx0XHR2YXIgYWJiclV0aWxzID0gcmVxdWlyZSgnYWJicmV2aWF0aW9uVXRpbHMnKTtcblx0XHRcblx0XHRfLmVhY2godHJlZS5jaGlsZHJlbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGFiYnJVdGlscy5pc1NuaXBwZXQoaXRlbSkpXG5cdFx0XHRcdHByb2Nlc3NTbmlwcGV0KGl0ZW0sIHByb2ZpbGUsIGxldmVsKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cHJvY2Vzc1RhZyhpdGVtLCBwcm9maWxlLCBsZXZlbCk7XG5cdFx0XHRcblx0XHRcdHByb2Nlc3MoaXRlbSwgcHJvZmlsZSwgbGV2ZWwgKyAxKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fSk7XG59KTsvKipcbiAqIEZpbHRlciBmb3IgcHJvZHVjaW5nIEhBTUwgY29kZSBmcm9tIGFiYnJldmlhdGlvbi5cbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pXG4gKiBAbGluayBodHRwOi8vY2hpa3V5b25vay5ydVxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX19oYW1sRmlsdGVyRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciBjaGlsZFRva2VuID0gJyR7Y2hpbGR9Jztcblx0XG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUNsYXNzTmFtZShjbGFzc05hbWUpIHtcblx0XHRyZXR1cm4gcmVxdWlyZSgndXRpbHMnKS50cmltKGNsYXNzTmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLicpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBIQU1MIGF0dHJpYnV0ZXMgc3RyaW5nIGZyb20gdGFnIGFjY29yZGluZyB0byBwcm9maWxlIHNldHRpbmdzXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlQXR0cmlidXRlc1N0cmluZyh0YWcsIHByb2ZpbGUpIHtcblx0XHR2YXIgYXR0cnMgPSAnJztcblx0XHR2YXIgb3RoZXJBdHRycyA9IFtdO1xuXHRcdHZhciBhdHRyUXVvdGUgPSBwcm9maWxlLmF0dHJpYnV0ZVF1b3RlKCk7XG5cdFx0dmFyIGN1cnNvciA9IHByb2ZpbGUuY3Vyc29yKCk7XG5cdFx0XG5cdFx0Xy5lYWNoKHRhZy5hdHRyaWJ1dGVMaXN0KCksIGZ1bmN0aW9uKGEpIHtcblx0XHRcdHZhciBhdHRyTmFtZSA9IHByb2ZpbGUuYXR0cmlidXRlTmFtZShhLm5hbWUpO1xuXHRcdFx0c3dpdGNoIChhdHRyTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdC8vIHVzZSBzaG9ydCBub3RhdGlvbiBmb3IgSUQgYW5kIENMQVNTIGF0dHJpYnV0ZXNcblx0XHRcdFx0Y2FzZSAnaWQnOlxuXHRcdFx0XHRcdGF0dHJzICs9ICcjJyArIChhLnZhbHVlIHx8IGN1cnNvcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2NsYXNzJzpcblx0XHRcdFx0XHRhdHRycyArPSAnLicgKyB0cmFuc2Zvcm1DbGFzc05hbWUoYS52YWx1ZSB8fCBjdXJzb3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHQvLyBwcm9jZXNzIG90aGVyIGF0dHJpYnV0ZXNcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvdGhlckF0dHJzLnB1c2goJzonICthdHRyTmFtZSArICcgPT4gJyArIGF0dHJRdW90ZSArIChhLnZhbHVlIHx8IGN1cnNvcikgKyBhdHRyUXVvdGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChvdGhlckF0dHJzLmxlbmd0aClcblx0XHRcdGF0dHJzICs9ICd7JyArIG90aGVyQXR0cnMuam9pbignLCAnKSArICd9Jztcblx0XHRcblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUZXN0IGlmIHBhc3NlZCBub2RlIGhhcyBibG9jay1sZXZlbCBzaWJsaW5nIGVsZW1lbnRcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBpdGVtXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNCbG9ja1NpYmxpbmcoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5oYXNCbG9ja0NoaWxkcmVuKCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQcm9jZXNzZXMgZWxlbWVudCB3aXRoIDxjb2RlPnRhZzwvY29kZT4gdHlwZVxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IGl0ZW1cblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBEZXB0aCBsZXZlbFxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvY2Vzc1RhZyhpdGVtLCBwcm9maWxlLCBsZXZlbCkge1xuXHRcdGlmICghaXRlbS5wYXJlbnQpXG5cdFx0XHQvLyBsb29rcyBsaWtlIGl0J3Mgcm9vdCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcblx0XHR2YXIgYWJiclV0aWxzID0gcmVxdWlyZSgnYWJicmV2aWF0aW9uVXRpbHMnKTtcblx0XHR2YXIgdXRpbHMgPSByZXF1aXJlKCd1dGlscycpO1xuXHRcdFxuXHRcdHZhciBhdHRycyA9IG1ha2VBdHRyaWJ1dGVzU3RyaW5nKGl0ZW0sIHByb2ZpbGUpO1xuXHRcdHZhciBjdXJzb3IgPSBwcm9maWxlLmN1cnNvcigpO1xuXHRcdHZhciBpc1VuYXJ5ID0gYWJiclV0aWxzLmlzVW5hcnkoaXRlbSk7XG5cdFx0dmFyIHNlbGZDbG9zaW5nID0gcHJvZmlsZS5zZWxmX2Nsb3NpbmdfdGFnICYmIGlzVW5hcnkgPyAnLycgOiAnJztcblx0XHR2YXIgc3RhcnQ9ICcnO1xuXHRcdFx0XG5cdFx0Ly8gZGVmaW5lIHRhZyBuYW1lXG5cdFx0dmFyIHRhZ05hbWUgPSAnJScgKyBwcm9maWxlLnRhZ05hbWUoaXRlbS5uYW1lKCkpO1xuXHRcdGlmICh0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJyVkaXYnICYmIGF0dHJzICYmIGF0dHJzLmluZGV4T2YoJ3snKSA9PSAtMSlcblx0XHRcdC8vIG9taXQgZGl2IHRhZ1xuXHRcdFx0dGFnTmFtZSA9ICcnO1xuXHRcdFx0XG5cdFx0aXRlbS5lbmQgPSAnJztcblx0XHRzdGFydCA9IHRhZ05hbWUgKyBhdHRycyArIHNlbGZDbG9zaW5nICsgJyAnO1xuXHRcdFxuXHRcdHZhciBwbGFjZWhvbGRlciA9ICclcyc7XG5cdFx0Ly8gV2UgY2FuJ3QganVzdCByZXBsYWNlIHBsYWNlaG9sZGVyIHdpdGggbmV3IHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBKYXZhU2NyaXB0IHdpbGwgdHJlYXQgZG91YmxlICQgY2hhcmFjdGVyIGFzIGEgc2luZ2xlIG9uZSwgYXNzdW1pbmdcblx0XHQvLyB3ZSdyZSB1c2luZyBSZWdFeHAgbGl0ZXJhbC5cblx0XHRpdGVtLnN0YXJ0ID0gdXRpbHMucmVwbGFjZVN1YnN0cmluZyhpdGVtLnN0YXJ0LCBzdGFydCwgaXRlbS5zdGFydC5pbmRleE9mKHBsYWNlaG9sZGVyKSwgcGxhY2Vob2xkZXIpO1xuXHRcdFxuXHRcdGlmICghaXRlbS5jaGlsZHJlbi5sZW5ndGggJiYgIWlzVW5hcnkpXG5cdFx0XHRpdGVtLnN0YXJ0ICs9IGN1cnNvcjtcblx0XHRcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBzaW1wbGlmaWVkIHRyZWUsIG1ha2luZyBpdCBzdWl0YWJsZSBmb3Igb3V0cHV0IGFzIEhUTUwgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgRGVwdGggbGV2ZWxcblx0ICovXG5cdHJlcXVpcmUoJ2ZpbHRlcnMnKS5hZGQoJ2hhbWwnLCBmdW5jdGlvbiBwcm9jZXNzKHRyZWUsIHByb2ZpbGUsIGxldmVsKSB7XG5cdFx0bGV2ZWwgPSBsZXZlbCB8fCAwO1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdFxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdHRyZWUgPSByZXF1aXJlKCdmaWx0ZXJzJykuYXBwbHkodHJlZSwgJ19mb3JtYXQnLCBwcm9maWxlKTtcblx0XHR9XG5cdFx0XG5cdFx0Xy5lYWNoKHRyZWUuY2hpbGRyZW4sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICghYWJiclV0aWxzLmlzU25pcHBldChpdGVtKSlcblx0XHRcdFx0cHJvY2Vzc1RhZyhpdGVtLCBwcm9maWxlLCBsZXZlbCk7XG5cdFx0XHRcblx0XHRcdHByb2Nlc3MoaXRlbSwgcHJvZmlsZSwgbGV2ZWwgKyAxKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fSk7XG59KTsvKipcbiAqIEZpbHRlciB0aGF0IHByb2R1Y2VzIEhUTUwgdHJlZVxuICogQGF1dGhvciBTZXJnZXkgQ2hpa3V5b25vayAoc2VyZ2UuY2hlQGdtYWlsLmNvbSlcbiAqIEBsaW5rIGh0dHA6Ly9jaGlrdXlvbm9rLnJ1XG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX2h0bWxGaWx0ZXJEZWZpbmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVpcmVcbiAqIEBwYXJhbSB7VW5kZXJzY29yZX0gX1xuICovXG5lbW1ldC5leGVjKGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgSFRNTCBhdHRyaWJ1dGVzIHN0cmluZyBmcm9tIHRhZyBhY2NvcmRpbmcgdG8gcHJvZmlsZSBzZXR0aW5nc1xuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGVcblx0ICogQHBhcmFtIHtPdXRwdXRQcm9maWxlfSBwcm9maWxlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlQXR0cmlidXRlc1N0cmluZyhub2RlLCBwcm9maWxlKSB7XG5cdFx0dmFyIGF0dHJRdW90ZSA9IHByb2ZpbGUuYXR0cmlidXRlUXVvdGUoKTtcblx0XHR2YXIgY3Vyc29yID0gcHJvZmlsZS5jdXJzb3IoKTtcblx0XHRcblx0XHRyZXR1cm4gXy5tYXAobm9kZS5hdHRyaWJ1dGVMaXN0KCksIGZ1bmN0aW9uKGEpIHtcblx0XHRcdHZhciBhdHRyTmFtZSA9IHByb2ZpbGUuYXR0cmlidXRlTmFtZShhLm5hbWUpO1xuXHRcdFx0cmV0dXJuICcgJyArIGF0dHJOYW1lICsgJz0nICsgYXR0clF1b3RlICsgKGEudmFsdWUgfHwgY3Vyc29yKSArIGF0dHJRdW90ZTtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBlbGVtZW50IHdpdGggPGNvZGU+dGFnPC9jb2RlPiB0eXBlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gaXRlbVxuXHQgKiBAcGFyYW0ge091dHB1dFByb2ZpbGV9IHByb2ZpbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIERlcHRoIGxldmVsXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9jZXNzVGFnKGl0ZW0sIHByb2ZpbGUsIGxldmVsKSB7XG5cdFx0aWYgKCFpdGVtLnBhcmVudCkgLy8gbG9va3MgbGlrZSBpdCdzIHJvb3QgZWxlbWVudFxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XG5cdFx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJ2FiYnJldmlhdGlvblV0aWxzJyk7XG5cdFx0dmFyIHV0aWxzID0gcmVxdWlyZSgndXRpbHMnKTtcblx0XHRcblx0XHR2YXIgYXR0cnMgPSBtYWtlQXR0cmlidXRlc1N0cmluZyhpdGVtLCBwcm9maWxlKTsgXG5cdFx0dmFyIGN1cnNvciA9IHByb2ZpbGUuY3Vyc29yKCk7XG5cdFx0dmFyIGlzVW5hcnkgPSBhYmJyVXRpbHMuaXNVbmFyeShpdGVtKTtcblx0XHR2YXIgc3RhcnQ9ICcnO1xuXHRcdHZhciBlbmQgPSAnJztcblx0XHRcdFxuXHRcdC8vIGRlZmluZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3Ncblx0XHRpZiAoIWl0ZW0uaXNUZXh0Tm9kZSgpKSB7XG5cdFx0XHR2YXIgdGFnTmFtZSA9IHByb2ZpbGUudGFnTmFtZShpdGVtLm5hbWUoKSk7XG5cdFx0XHRpZiAoaXNVbmFyeSkge1xuXHRcdFx0XHRzdGFydCA9ICc8JyArIHRhZ05hbWUgKyBhdHRycyArIHByb2ZpbGUuc2VsZkNsb3NpbmcoKSArICc+Jztcblx0XHRcdFx0aXRlbS5lbmQgPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXJ0ID0gJzwnICsgdGFnTmFtZSArIGF0dHJzICsgJz4nO1xuXHRcdFx0XHRlbmQgPSAnPC8nICsgdGFnTmFtZSArICc+Jztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHBsYWNlaG9sZGVyID0gJyVzJztcblx0XHQvLyBXZSBjYW4ndCBqdXN0IHJlcGxhY2UgcGxhY2Vob2xkZXIgd2l0aCBuZXcgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIEphdmFTY3JpcHQgd2lsbCB0cmVhdCBkb3VibGUgJCBjaGFyYWN0ZXIgYXMgYSBzaW5nbGUgb25lLCBhc3N1bWluZ1xuXHRcdC8vIHdlJ3JlIHVzaW5nIFJlZ0V4cCBsaXRlcmFsLlxuXHRcdGl0ZW0uc3RhcnQgPSB1dGlscy5yZXBsYWNlU3Vic3RyaW5nKGl0ZW0uc3RhcnQsIHN0YXJ0LCBpdGVtLnN0YXJ0LmluZGV4T2YocGxhY2Vob2xkZXIpLCBwbGFjZWhvbGRlcik7XG5cdFx0aXRlbS5lbmQgPSB1dGlscy5yZXBsYWNlU3Vic3RyaW5nKGl0ZW0uZW5kLCBlbmQsIGl0ZW0uZW5kLmluZGV4T2YocGxhY2Vob2xkZXIpLCBwbGFjZWhvbGRlcik7XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHdlIHB1dCBjYXJldCBwbGFjZWhvbGRlciBhZnRlciBvcGVuaW5nIHRhZz9cblx0XHRpZiAoXG5cdFx0XHRcdCFpdGVtLmNoaWxkcmVuLmxlbmd0aCBcblx0XHRcdFx0JiYgIWlzVW5hcnkgXG5cdFx0XHRcdCYmICF+aXRlbS5jb250ZW50LmluZGV4T2YoY3Vyc29yKVxuXHRcdFx0XHQmJiAhcmVxdWlyZSgndGFiU3RvcHMnKS5leHRyYWN0KGl0ZW0uY29udGVudCkudGFic3RvcHMubGVuZ3RoXG5cdFx0XHQpIHtcblx0XHRcdGl0ZW0uc3RhcnQgKz0gY3Vyc29yO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBzaW1wbGlmaWVkIHRyZWUsIG1ha2luZyBpdCBzdWl0YWJsZSBmb3Igb3V0cHV0IGFzIEhUTUwgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSB7QWJicmV2aWF0aW9uTm9kZX0gdHJlZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgRGVwdGggbGV2ZWxcblx0ICovXG5cdHJlcXVpcmUoJ2ZpbHRlcnMnKS5hZGQoJ2h0bWwnLCBmdW5jdGlvbiBwcm9jZXNzKHRyZWUsIHByb2ZpbGUsIGxldmVsKSB7XG5cdFx0bGV2ZWwgPSBsZXZlbCB8fCAwO1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdFxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdHRyZWUgPSByZXF1aXJlKCdmaWx0ZXJzJykuYXBwbHkodHJlZSwgJ19mb3JtYXQnLCBwcm9maWxlKTtcblx0XHR9XG5cdFx0XG5cdFx0Xy5lYWNoKHRyZWUuY2hpbGRyZW4sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICghYWJiclV0aWxzLmlzU25pcHBldChpdGVtKSlcblx0XHRcdFx0cHJvY2Vzc1RhZyhpdGVtLCBwcm9maWxlLCBsZXZlbCk7XG5cdFx0XHRcblx0XHRcdHByb2Nlc3MoaXRlbSwgcHJvZmlsZSwgbGV2ZWwgKyAxKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fSk7XG59KTsvKipcbiAqIE91dHB1dCBhYmJyZXZpYXRpb24gb24gYSBzaW5nbGUgbGluZSAoaS5lLiBubyBsaW5lIGJyZWFrcylcbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pXG4gKiBAbGluayBodHRwOi8vY2hpa3V5b25vay5ydVxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX19zaW5nbGVMaW5lRmlsdGVyRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciByZVBhZCA9IC9eXFxzKy87XG5cdHZhciByZU5sID0gL1tcXG5cXHJdL2c7XG5cdFxuXHRyZXF1aXJlKCdmaWx0ZXJzJykuYWRkKCdzJywgZnVuY3Rpb24gcHJvY2Vzcyh0cmVlLCBwcm9maWxlLCBsZXZlbCkge1xuXHRcdHZhciBhYmJyVXRpbHMgPSByZXF1aXJlKCdhYmJyZXZpYXRpb25VdGlscycpO1xuXHRcdFxuXHRcdF8uZWFjaCh0cmVlLmNoaWxkcmVuLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoIWFiYnJVdGlscy5pc1NuaXBwZXQoaXRlbSkpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIHBhZGRpbmcgZnJvbSBpdGVtIFxuXHRcdFx0XHRpdGVtLnN0YXJ0ID0gaXRlbS5zdGFydC5yZXBsYWNlKHJlUGFkLCAnJyk7XG5cdFx0XHRcdGl0ZW0uZW5kID0gaXRlbS5lbmQucmVwbGFjZShyZVBhZCwgJycpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyByZW1vdmUgbmV3bGluZXMgXG5cdFx0XHRpdGVtLnN0YXJ0ID0gaXRlbS5zdGFydC5yZXBsYWNlKHJlTmwsICcnKTtcblx0XHRcdGl0ZW0uZW5kID0gaXRlbS5lbmQucmVwbGFjZShyZU5sLCAnJyk7XG5cdFx0XHRpdGVtLmNvbnRlbnQgPSBpdGVtLmNvbnRlbnQucmVwbGFjZShyZU5sLCAnJyk7XG5cdFx0XHRcblx0XHRcdHByb2Nlc3MoaXRlbSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRyZWU7XG5cdH0pO1xufSk7XG4vKipcbiAqIFRyaW0gZmlsdGVyOiByZW1vdmVzIGNoYXJhY3RlcnMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dFxuICogY29udGVudCB0aGF0IGluZGljYXRlcyBsaXN0czogbnVtYmVycywgIywgKiwgLSwgZXRjLlxuICogXG4gKiBVc2VmdWwgZm9yIHdyYXBwaW5nIGxpc3RzIHdpdGggYWJicmV2aWF0aW9uLlxuICogXG4gKiBAYXV0aG9yIFNlcmdleSBDaGlrdXlvbm9rIChzZXJnZS5jaGVAZ21haWwuY29tKVxuICogQGxpbmsgaHR0cDovL2NoaWt1eW9ub2sucnVcbiAqIFxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX190cmltRmlsdGVyRGVmaW5lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF9cbiAqL1xuZW1tZXQuZXhlYyhmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHJlcXVpcmUoJ3ByZWZlcmVuY2VzJykuZGVmaW5lKCdmaWx0ZXIudHJpbVJlZ2V4cCcsICdbXFxcXHN8XFxcXHUwMGEwXSpbXFxcXGR8I3xcXFxcLXxcXCp8XFxcXHUyMDIyXStcXFxcLj9cXFxccyonLFxuXHRcdFx0J1JlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHJlbW92ZSBsaXN0IG1hcmtlcnMgKG51bWJlcnMsIGRhc2hlcywgJyBcblx0XHRcdCsgJ2J1bGxldHMsIGV0Yy4pIGluIDxjb2RlPnQ8L2NvZGU+ICh0cmltKSBmaWx0ZXIuIFRoZSB0cmltIGZpbHRlciAnXG5cdFx0XHQrICdpcyB1c2VmdWwgZm9yIHdyYXBwaW5nIHdpdGggYWJicmV2aWF0aW9uIGxpc3RzLCBwYXNlZCBmcm9tIG90aGVyICcgXG5cdFx0XHQrICdkb2N1bWVudHMgKGZvciBleGFtcGxlLCBXb3JkIGRvY3VtZW50cykuJyk7XG5cdFxuXHRmdW5jdGlvbiBwcm9jZXNzKHRyZWUsIHJlKSB7XG5cdFx0Xy5lYWNoKHRyZWUuY2hpbGRyZW4sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChpdGVtLmNvbnRlbnQpXG5cdFx0XHRcdGl0ZW0uY29udGVudCA9IGl0ZW0uY29udGVudC5yZXBsYWNlKHJlLCAnJyk7XG5cdFx0XHRcblx0XHRcdHByb2Nlc3MoaXRlbSwgcmUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0cmVlO1xuXHR9XG5cdFxuXHRyZXF1aXJlKCdmaWx0ZXJzJykuYWRkKCd0JywgZnVuY3Rpb24odHJlZSkge1xuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAocmVxdWlyZSgncHJlZmVyZW5jZXMnKS5nZXQoJ2ZpbHRlci50cmltUmVnZXhwJykpO1xuXHRcdHJldHVybiBwcm9jZXNzKHRyZWUsIHJlKTtcblx0fSk7XG59KTtcbi8qKlxuICogRmlsdGVyIGZvciB0cmltbWluZyBcInNlbGVjdFwiIGF0dHJpYnV0ZXMgZnJvbSBzb21lIHRhZ3MgdGhhdCBjb250YWluc1xuICogY2hpbGQgZWxlbWVudHNcbiAqIEBhdXRob3IgU2VyZ2V5IENoaWt1eW9ub2sgKHNlcmdlLmNoZUBnbWFpbC5jb20pXG4gKiBAbGluayBodHRwOi8vY2hpa3V5b25vay5ydVxuICogXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBfX3hzbEZpbHRlckRlZmluZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfXG4gKi9cbmVtbWV0LmV4ZWMoZnVuY3Rpb24ocmVxdWlyZSwgXykge1xuXHR2YXIgdGFncyA9IHtcblx0XHQneHNsOnZhcmlhYmxlJzogMSxcblx0XHQneHNsOndpdGgtcGFyYW0nOiAxXG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlcyBcInNlbGVjdFwiIGF0dHJpYnV0ZSBmcm9tIG5vZGVcblx0ICogQHBhcmFtIHtBYmJyZXZpYXRpb25Ob2RlfSBub2RlXG5cdCAqL1xuXHRmdW5jdGlvbiB0cmltQXR0cmlidXRlKG5vZGUpIHtcblx0XHRub2RlLnN0YXJ0ID0gbm9kZS5zdGFydC5yZXBsYWNlKC9cXHMrc2VsZWN0XFxzKj1cXHMqKFsnXCJdKS4qP1xcMS8sICcnKTtcblx0fVxuXHRcblx0cmVxdWlyZSgnZmlsdGVycycpLmFkZCgneHNsJywgZnVuY3Rpb24gcHJvY2Vzcyh0cmVlKSB7XG5cdFx0dmFyIGFiYnJVdGlscyA9IHJlcXVpcmUoJ2FiYnJldmlhdGlvblV0aWxzJyk7XG5cdFx0Xy5lYWNoKHRyZWUuY2hpbGRyZW4sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmICghYWJiclV0aWxzLmlzU25pcHBldChpdGVtKVxuXHRcdFx0XHRcdCYmIChpdGVtLm5hbWUoKSB8fCAnJykudG9Mb3dlckNhc2UoKSBpbiB0YWdzIFxuXHRcdFx0XHRcdCYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKVxuXHRcdFx0XHR0cmltQXR0cmlidXRlKGl0ZW0pO1xuXHRcdFx0cHJvY2VzcyhpdGVtKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJlZTtcblx0fSk7XG59KTsvKipcbiAqIFwiTG9yZW0gaXBzdW1cIiB0ZXh0IGdlbmVyYXRvci4gTWF0Y2hlcyA8Y29kZT5saXBzdW0obnVtKT88L2NvZGU+IG9yIFxuICogPGNvZGU+bG9yZW0obnVtKT88L2NvZGU+IGFiYnJldmlhdGlvbi5cbiAqIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBEamFuZ28ncyBjb250cmlidXRpb246IFxuICogaHR0cHM6Ly9jb2RlLmRqYW5nb3Byb2plY3QuY29tL2Jyb3dzZXIvZGphbmdvL3RydW5rL2RqYW5nby9jb250cmliL3dlYmRlc2lnbi9sb3JlbV9pcHN1bS5weVxuICogPGJyPjxicj5cbiAqIEV4YW1wbGVzIHRvIHRlc3Q6PGJyPlxuICogPGNvZGU+bGlwc3VtPC9jb2RlPiDigJMgZ2VuZXJhdGVzIDMwIHdvcmRzIHRleHQuPGJyPlxuICogPGNvZGU+bGlwc3VtKjY8L2NvZGU+IOKAkyBnZW5lcmF0ZXMgNiBwYXJhZ3JhcGhzIChhdXRvd3JhcHBlZCB3aXRoICZsdDtwJmd0OyBlbGVtZW50KSBvZiB0ZXh0Ljxicj5cbiAqIDxjb2RlPm9sPmxpcHN1bTEwKjU8L2NvZGU+IOKAlCBnZW5lcmF0ZXMgb3JkZXJlZCBsaXN0IHdpdGggNSBsaXN0IGl0ZW1zIChhdXRvd3JhcHBlZCB3aXRoICZsdDtsaSZndDsgdGFnKVxuICogd2l0aCB0ZXh0IG9mIDEwIHdvcmRzIG9uIGVhY2ggbGluZTxicj5cbiAqIDxjb2RlPnNwYW4qMz5saXBzdW0yMDwvY29kZT4g4oCTIGdlbmVyYXRlcyAzIHBhcmFncmFwaHMgb2YgMjAtd29yZHMgdGV4dCwgZWFjaCB3cmFwcGVkIHdpdGggJmx0O3NwYW4mZ3Q7IGVsZW1lbnQgLlxuICogRWFjaCBwYXJhZ3JhcGggcGhyYXNlIGlzIHVuaXF1ZSAgIFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVxdWlyZVxuICogQHBhcmFtIHtVbmRlcnNjb3JlfSBfIFxuICogQGNvbnN0cnVjdG9yXG4gKiBAbWVtYmVyT2YgX19sb3JlbUlwc3VtR2VuZXJhdG9yRGVmaW5lXG4gKi9cbmVtbWV0LmRlZmluZSgnbG9yZW0nLCBmdW5jdGlvbihyZXF1aXJlLCBfKSB7XG5cdHZhciBsYW5ncyA9IHtcblx0XHRlbjoge1xuXHRcdFx0Y29tbW9uOiBbJ2xvcmVtJywgJ2lwc3VtJywgJ2RvbG9yJywgJ3NpdCcsICdhbWV0JywgJ2NvbnNlY3RldHVyJywgJ2FkaXBpc2ljaW5nJywgJ2VsaXQnXSxcblx0XHRcdHdvcmRzOiBbJ2V4ZXJjaXRhdGlvbmVtJywgJ3BlcmZlcmVuZGlzJywgJ3BlcnNwaWNpYXRpcycsICdsYWJvcnVtJywgJ2V2ZW5pZXQnLFxuXHQgICAgICAgICAgICAgJ3N1bnQnLCAnaXVyZScsICduYW0nLCAnbm9iaXMnLCAnZXVtJywgJ2N1bScsICdvZmZpY2lpcycsICdleGNlcHR1cmknLFxuXHQgICAgICAgICAgICAgJ29kaW8nLCAnY29uc2VjdGV0dXInLCAncXVhc2knLCAnYXV0JywgJ3F1aXNxdWFtJywgJ3ZlbCcsICdlbGlnZW5kaScsXG5cdCAgICAgICAgICAgICAnaXRhcXVlJywgJ25vbicsICdvZGl0JywgJ3RlbXBvcmUnLCAncXVhZXJhdCcsICdkaWduaXNzaW1vcycsXG5cdCAgICAgICAgICAgICAnZmFjaWxpcycsICduZXF1ZScsICduaWhpbCcsICdleHBlZGl0YScsICd2aXRhZScsICd2ZXJvJywgJ2lwc3VtJyxcblx0ICAgICAgICAgICAgICduaXNpJywgJ2FuaW1pJywgJ2N1bXF1ZScsICdwYXJpYXR1cicsICd2ZWxpdCcsICdtb2RpJywgJ25hdHVzJyxcblx0ICAgICAgICAgICAgICdpdXN0bycsICdlYXF1ZScsICdzZXF1aScsICdpbGxvJywgJ3NlZCcsICdleCcsICdldCcsICd2b2x1cHRhdGlidXMnLFxuXHQgICAgICAgICAgICAgJ3RlbXBvcmEnLCAndmVyaXRhdGlzJywgJ3JhdGlvbmUnLCAnYXNzdW1lbmRhJywgJ2luY2lkdW50JywgJ25vc3RydW0nLFxuXHQgICAgICAgICAgICAgJ3BsYWNlYXQnLCAnYWxpcXVpZCcsICdmdWdhJywgJ3Byb3ZpZGVudCcsICdwcmFlc2VudGl1bScsICdyZW0nLFxuXHQgICAgICAgICAgICAgJ25lY2Vzc2l0YXRpYnVzJywgJ3N1c2NpcGl0JywgJ2FkaXBpc2NpJywgJ3F1aWRlbScsICdwb3NzaW11cycsXG5cdCAgICAgICAgICAgICAndm9sdXB0YXMnLCAnZGViaXRpcycsICdzaW50JywgJ2FjY3VzYW50aXVtJywgJ3VuZGUnLCAnc2FwaWVudGUnLFxuXHQgICAgICAgICAgICAgJ3ZvbHVwdGF0ZScsICdxdWknLCAnYXNwZXJuYXR1cicsICdsYXVkYW50aXVtJywgJ3NvbHV0YScsICdhbWV0Jyxcblx0ICAgICAgICAgICAgICdxdW8nLCAnYWxpcXVhbScsICdzYWVwZScsICdjdWxwYScsICdsaWJlcm8nLCAnaXBzYScsICdkaWN0YScsXG5cdCAgICAgICAgICAgICAncmVpY2llbmRpcycsICduZXNjaXVudCcsICdkb2xvcmlidXMnLCAnYXV0ZW0nLCAnaW1wZWRpdCcsICdtaW5pbWEnLFxuXHQgICAgICAgICAgICAgJ21haW9yZXMnLCAncmVwdWRpYW5kYWUnLCAnaXBzYW0nLCAnb2JjYWVjYXRpJywgJ3VsbGFtJywgJ2VuaW0nLFxuXHQgICAgICAgICAgICAgJ3RvdGFtJywgJ2RlbGVjdHVzJywgJ2R1Y2ltdXMnLCAncXVpcycsICd2b2x1cHRhdGVzJywgJ2RvbG9yZXMnLFxuXHQgICAgICAgICAgICAgJ21vbGVzdGlhZScsICdoYXJ1bScsICdkb2xvcmVtJywgJ3F1aWEnLCAndm9sdXB0YXRlbScsICdtb2xlc3RpYXMnLFxuXHQgICAgICAgICAgICAgJ21hZ25pJywgJ2Rpc3RpbmN0aW8nLCAnb21uaXMnLCAnaWxsdW0nLCAnZG9sb3J1bScsICd2b2x1cHRhdHVtJywgJ2VhJyxcblx0ICAgICAgICAgICAgICdxdWFzJywgJ3F1YW0nLCAnY29ycG9yaXMnLCAncXVhZScsICdibGFuZGl0aWlzJywgJ2F0cXVlJywgJ2Rlc2VydW50Jyxcblx0ICAgICAgICAgICAgICdsYWJvcmlvc2FtJywgJ2VhcnVtJywgJ2NvbnNlcXV1bnR1cicsICdoaWMnLCAnY3VwaWRpdGF0ZScsXG5cdCAgICAgICAgICAgICAncXVpYnVzZGFtJywgJ2FjY3VzYW11cycsICd1dCcsICdyZXJ1bScsICdlcnJvcicsICdtaW51cycsICdlaXVzJyxcblx0ICAgICAgICAgICAgICdhYicsICdhZCcsICduZW1vJywgJ2Z1Z2l0JywgJ29mZmljaWEnLCAnYXQnLCAnaW4nLCAnaWQnLCAncXVvcycsXG5cdCAgICAgICAgICAgICAncmVwcmVoZW5kZXJpdCcsICdudW1xdWFtJywgJ2lzdGUnLCAnZnVnaWF0JywgJ3NpdCcsICdpbnZlbnRvcmUnLFxuXHQgICAgICAgICAgICAgJ2JlYXRhZScsICdyZXBlbGxlbmR1cycsICdtYWduYW0nLCAncmVjdXNhbmRhZScsICdxdW9kJywgJ2V4cGxpY2FibycsXG5cdCAgICAgICAgICAgICAnZG9sb3JlbXF1ZScsICdhcGVyaWFtJywgJ2NvbnNlcXVhdHVyJywgJ2FzcGVyaW9yZXMnLCAnY29tbW9kaScsXG5cdCAgICAgICAgICAgICAnb3B0aW8nLCAnZG9sb3InLCAnbGFib3JlJywgJ3RlbXBvcmlidXMnLCAncmVwZWxsYXQnLCAndmVuaWFtJyxcblx0ICAgICAgICAgICAgICdhcmNoaXRlY3RvJywgJ2VzdCcsICdlc3NlJywgJ21vbGxpdGlhJywgJ251bGxhJywgJ2EnLCAnc2ltaWxpcXVlJyxcblx0ICAgICAgICAgICAgICdlb3MnLCAnYWxpYXMnLCAnZG9sb3JlJywgJ3RlbmV0dXInLCAnZGVsZW5pdGknLCAncG9ycm8nLCAnZmFjZXJlJyxcblx0ICAgICAgICAgICAgICdtYXhpbWUnLCAnY29ycnVwdGknXVxuXHRcdH0sXG5cdFx0cnU6IHtcblx0XHRcdGNvbW1vbjogWyfQtNCw0LvQtdC60L4t0LTQsNC70LXQutC+JywgJ9C30LAnLCAn0YHQu9C+0LLQtdGB0L3Ri9C80LgnLCAn0LPQvtGA0LDQvNC4JywgJ9CyINGB0YLRgNCw0L3QtScsICfQs9C70LDRgdC90YvRhScsICfQuCDRgdC+0LPQu9Cw0YHQvdGL0YUnLCAn0LbQuNCy0YPRgicsICfRgNGL0LHQvdGL0LUnLCAn0YLQtdC60YHRgtGLJ10sXG5cdFx0XHR3b3JkczogWyfQstC00LDQu9C4JywgJ9C+0YIg0LLRgdC10YUnLCAn0L7QvdC4JywgJ9Cx0YPQutCy0LXQvdC90YvRhScsICfQtNC+0LzQsNGFJywgJ9C90LAg0LHQtdGA0LXQs9GDJywgJ9GB0LXQvNCw0L3RgtC40LrQsCcsIFxuXHRcdCAgICAgICAgICAgICfQsdC+0LvRjNGI0L7Qs9C+JywgJ9GP0LfRi9C60L7QstC+0LPQvicsICfQvtC60LXQsNC90LAnLCAn0LzQsNC70LXQvdGM0LrQuNC5JywgJ9GA0YPRh9C10LXQuicsICfQtNCw0LvRjCcsIFxuXHRcdCAgICAgICAgICAgICfQttGD0YDRh9C40YInLCAn0L/QviDQstGB0LXQuScsICfQvtCx0LXRgdC/0LXRh9C40LLQsNC10YInLCAn0LXQtScsJ9Cy0YHQtdC80LgnLCAn0L3QtdC+0LHRhdC+0LTQuNC80YvQvNC4JywgXG5cdFx0ICAgICAgICAgICAgJ9C/0YDQsNCy0LjQu9Cw0LzQuCcsICfRjdGC0LAnLCAn0L/QsNGA0LDQtNC40LPQvNCw0YLQuNGH0LXRgdC60LDRjycsICfRgdGC0YDQsNC90LAnLCAn0LrQvtGC0L7RgNC+0LknLCAn0LbQsNGA0LXQvdC90YvQtScsIFxuXHRcdCAgICAgICAgICAgICfQv9GA0LXQtNC70L7QttC10L3QuNGPJywgJ9C30LDQu9C10YLQsNGO0YInLCAn0L/RgNGP0LzQvicsICfRgNC+0YInLCAn0LTQsNC20LUnLCAn0LLRgdC10LzQvtCz0YPRidCw0Y8nLCBcblx0XHQgICAgICAgICAgICAn0L/Rg9C90LrRgtGD0LDRhtC40Y8nLCAn0L3QtScsICfQuNC80LXQtdGCJywgJ9Cy0LvQsNGB0YLQuCcsICfQvdCw0LQnLCAn0YDRi9Cx0L3Ri9C80LgnLCAn0YLQtdC60YHRgtCw0LzQuCcsIFxuXHRcdCAgICAgICAgICAgICfQstC10LTRg9GJ0LjQvNC4JywgJ9Cx0LXQt9C+0YDRhNC+0LPRgNCw0YTQuNGH0L3Ri9C5JywgJ9C+0LHRgNCw0LcnLCAn0LbQuNC30L3QuCcsICfQvtC00L3QsNC20LTRiycsICfQvtC00L3QsCcsIFxuXHRcdCAgICAgICAgICAgICfQvNCw0LvQtdC90YzQutCw0Y8nLCAn0YHRgtGA0L7Rh9C60LAnLCfRgNGL0LHQvdC+0LPQvicsICfRgtC10LrRgdGC0LAnLCAn0LjQvNC10L3QuCcsICdsb3JlbScsICdpcHN1bScsIFxuXHRcdCAgICAgICAgICAgICfRgNC10YjQuNC70LAnLCAn0LLRi9C50YLQuCcsICfQsdC+0LvRjNGI0L7QuScsICfQvNC40YAnLCAn0LPRgNCw0LzQvNCw0YLQuNC60LgnLCAn0LLQtdC70LjQutC40LknLCAn0L7QutGB0LzQvtC60YEnLCBcblx0XHQgICAgICAgICAgICAn0L/RgNC10LTRg9C/0YDQtdC20LTQsNC7JywgJ9C+JywgJ9C30LvRi9GFJywgJ9C30LDQv9GP0YLRi9GFJywgJ9C00LjQutC40YUnLCAn0LfQvdCw0LrQsNGFJywgJ9Cy0L7Qv9GA0L7RgdCwJywgXG5cdFx0ICAgICAgICAgICAgJ9C60L7QstCw0YDQvdGL0YUnLCAn0YLQvtGH0LrQsNGFJywgJ9C30LDQv9GP0YLQvtC5JywgJ9C90L4nLCAn0YLQtdC60YHRgicsICfQtNCw0LsnLCAn0YHQsdC40YLRjCcsIFxuXHRcdCAgICAgICAgICAgICfRgdC10LHRjycsICfRgtC+0LvQutGDJywgJ9C+0L0nLCAn0YHQvtCx0YDQsNC7JywgJ9GB0LXQvNGMJywgJ9GB0LLQvtC40YUnLCAn0LfQsNCz0LvQsNCy0L3Ri9GFJywgJ9Cx0YPQutCyJywgXG5cdFx0ICAgICAgICAgICAgJ9C/0L7QtNC/0L7Rj9GB0LDQuycsICfQuNC90LjRhtC40LDQuycsICfQt9CwJywgJ9C/0L7Rj9GBJywgJ9C/0YPRgdGC0LjQu9GB0Y8nLCAn0LTQvtGA0L7Qs9GDJywgXG5cdFx0ICAgICAgICAgICAgJ9Cy0LfQvtCx0YDQsNCy0YjQuNGB0YwnLCAn0L/QtdGA0LLRg9GOJywgJ9Cy0LXRgNGI0LjQvdGDJywgJ9C60YPRgNGB0LjQstC90YvRhScsICfQs9C+0YAnLCAn0LHRgNC+0YHQuNC7JywgXG5cdFx0ICAgICAgICAgICAgJ9C/0L7RgdC70LXQtNC90LjQuScsICfQstC30LPQu9GP0LQnLCAn0L3QsNC30LDQtCcsICfRgdC40LvRg9GN0YInLCAn0YHQstC+0LXQs9C+JywgJ9GA0L7QtNC90L7Qs9C+JywgJ9Cz0L7RgNC+0LTQsCcsIFxuXHRcdCAgICAgICAgICAgICfQsdGD0LrQstC+0LPRgNCw0LQnLCAn0LfQsNCz0L7Qu9C+0LLQvtC6JywgJ9C00LXRgNC10LLQvdC4JywgJ9Cw0LvRhNCw0LLQuNGCJywgJ9C/0L7QtNC30LDQs9C+0LvQvtCy0L7QuicsICfRgdCy0L7QtdCz0L4nLCBcblx0XHQgICAgICAgICAgICAn0L/QtdGA0LXRg9C70LrQsCcsICfQs9GA0YPRgdGC0L3Ri9C5JywgJ9GA0LXRgtC+0YDQuNGH0LXRgdC60LjQuScsICfQstC+0L/RgNC+0YEnLCAn0YHQutCw0YLQuNC70YHRjycsICfQtdCz0L4nLCBcblx0XHQgICAgICAgICAgICAn0YnQtdC60LUnLCAn0L/RgNC+0LTQvtC70LbQuNC7JywgJ9GB0LLQvtC5JywgJ9C/0YPRgtGMJywgJ9C00L7RgNC+0LPQtScsICfQstGB0YLRgNC10YLQuNC7JywgJ9GA0YPQutC+0L/QuNGB0YwnLCBcblx0XHQgICAgICAgICAgICAn0L7QvdCwJywgJ9C/0YDQtdC00YPQv9GA0LXQtNC40LvQsCcsICAn0LzQvtC10LknLCAn0LLRgdC1JywgJ9C/0LXRgNC10L/QuNGB0YvQstCw0LXRgtGB0Y8nLCAn0L3QtdGB0LrQvtC70YzQutC+JywgXG5cdFx0ICAgICAgICAgICAgJ9GA0LDQtycsICfQtdC00LjQvdGB0YLQstC10L3QvdC+0LUnLCAn0YfRgtC+JywgJ9C80LXQvdGPJywgJ9C+0YHRgtCw0LvQvtGB0YwnLCAn0Y3RgtC+JywgJ9C/0YDQuNGB0YLQsNCy0LrQsCcsIFxuXHRcdCAgICAgICAgICAgICfQstC+0LfQstGA0LDRidCw0LnRgdGPJywgJ9GC0YsnLCAn0LvRg9GH0YjQtScsICfRgdCy0L7RjicsICfQsdC10LfQvtC/0LDRgdC90YPRjicsICfRgdGC0YDQsNC90YMnLCAn0L/QvtGB0LvRg9GI0LDQstGI0LjRgdGMJywgXG5cdFx0ICAgICAgICAgICAgJ9GA0YPQutC+0L/QuNGB0LgnLCAn0L3QsNGIJywgJ9C/0YDQvtC00L7Qu9C20LjQuycsICfRgdCy0L7QuScsICfQv9GD0YLRjCcsICfQstGB0LrQvtGA0LUnLCAn0LXQvNGDJywgXG5cdFx0ICAgICAgICAgICAgJ9C/0L7QstGB0YLRgNC10YfQsNC70YHRjycsICfQutC+0LLQsNGA0L3Ri9C5JywgJ9GB0L7RgdGC0LDQstC40YLQtdC70YwnLCAn0YDQtdC60LvQsNC80L3Ri9GFJywgJ9GC0LXQutGB0YLQvtCyJywgXG5cdFx0ICAgICAgICAgICAgJ9C90LDQv9C+0LjQstGI0LjQuScsICfRj9C30YvQutC+0LwnLCAn0YDQtdGH0YzRjicsICfQt9Cw0LzQsNC90LjQstGI0LjQuScsICfRgdCy0L7QtScsICfQsNCz0LXQvdGB0YLQstC+JywgXG5cdFx0ICAgICAgICAgICAgJ9C60L7RgtC+0YDQvtC1JywgJ9C40YHQv9C+0LvRjNC30L7QstCw0LvQvicsICfRgdC90L7QstCwJywgJ9GB0L3QvtCy0LAnLCAn0YHQstC+0LjRhScsICfQv9GA0L7QtdC60YLQsNGFJywgXG5cdFx0ICAgICAgICAgICAgJ9C10YHQu9C4JywgJ9C/0LXRgNC10L/QuNGB0LDQu9C4JywgJ9GC0L4nLCAn0LbQuNCy0LXRgicsICfRgtCw0LwnLCAn0LTQvicsICfRgdC40YUnLCAn0L/QvtGAJ11cblx0XHR9XG5cdH07XG5cblx0dmFyIHByZWZzID0gcmVxdWlyZSgncHJlZmVyZW5jZXMnKTtcblx0cHJlZnMuZGVmaW5lKCdsb3JlbS5kZWZhdWx0TGFuZycsICdlbicpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IHRyZWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdHJlcXVpcmUoJ2FiYnJldmlhdGlvblBhcnNlcicpLmFkZFByZXByb2Nlc3NvcihmdW5jdGlvbih0cmVlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlID0gL14oPzpsb3JlbXxsaXBzdW0pKFthLXpdezJ9KT8oXFxkKikkL2ksIG1hdGNoO1xuXHRcdFxuXHRcdC8qKiBAcGFyYW0ge0FiYnJldmlhdGlvbk5vZGV9IG5vZGUgKi9cblx0XHR0cmVlLmZpbmRBbGwoZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0aWYgKG5vZGUuX25hbWUgJiYgKG1hdGNoID0gbm9kZS5fbmFtZS5tYXRjaChyZSkpKSB7XG5cdFx0XHRcdHZhciB3b3JkQ291bmQgPSBtYXRjaFsyXSB8fCAzMDtcblx0XHRcdFx0dmFyIGxhbmcgPSBtYXRjaFsxXSB8fCBwcmVmcy5nZXQoJ2xvcmVtLmRlZmF1bHRMYW5nJykgfHwgJ2VuJztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGZvcmNlIG5vZGUgbmFtZSByZXNvbHZpbmcgaWYgbm9kZSBzaG91bGQgYmUgcmVwZWF0ZWRcblx0XHRcdFx0Ly8gb3IgY29udGFpbnMgYXR0cmlidXRlcy4gSW4gdGhpcyBjYXNlLCBub2RlIHNob3VsZCBiZSBvdXRwdXRlZFxuXHRcdFx0XHQvLyBhcyB0YWcsIG90aGVyd2lzZSBhcyB0ZXh0LW9ubHkgbm9kZVxuXHRcdFx0XHRub2RlLl9uYW1lID0gJyc7XG5cdFx0XHRcdG5vZGUuZGF0YSgnZm9yY2VOYW1lUmVzb2x2aW5nJywgbm9kZS5pc1JlcGVhdGluZygpIHx8IG5vZGUuYXR0cmlidXRlTGlzdCgpLmxlbmd0aCk7XG5cdFx0XHRcdG5vZGUuZGF0YSgncGFzdGVPdmVyd3JpdGVzJywgdHJ1ZSk7XG5cdFx0XHRcdG5vZGUuZGF0YSgncGFzdGUnLCBmdW5jdGlvbihpLCBjb250ZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmFncmFwaChsYW5nLCB3b3JkQ291bmQsICFpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgcmFuZG9tIGludGVnZXIgYmV0d2VlbiA8Y29kZT5mcm9tPC9jb2RlPiBhbmQgPGNvZGU+dG88L2NvZGU+IHZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJvbVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9cblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHJhbmRpbnQoZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKHRvIC0gZnJvbSkgKyBmcm9tKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY291bnRcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gc2FtcGxlKGFyciwgY291bnQpIHtcblx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0XHR2YXIgaXRlcmF0aW9ucyA9IE1hdGgubWluKGxlbiwgY291bnQpO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGl0ZXJhdGlvbnMpIHtcblx0XHRcdHZhciByYW5kSXggPSByYW5kaW50KDAsIGxlbiAtIDEpO1xuXHRcdFx0aWYgKCFfLmluY2x1ZGUocmVzdWx0LCByYW5kSXgpKVxuXHRcdFx0XHRyZXN1bHQucHVzaChyYW5kSXgpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gXy5tYXAocmVzdWx0LCBmdW5jdGlvbihpeCkge1xuXHRcdFx0cmV0dXJuIGFycltpeF07XG5cdFx0fSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNob2ljZSh2YWwpIHtcblx0XHRpZiAoXy5pc1N0cmluZyh2YWwpKVxuXHRcdFx0cmV0dXJuIHZhbC5jaGFyQXQocmFuZGludCgwLCB2YWwubGVuZ3RoIC0gMSkpO1xuXHRcdFxuXHRcdHJldHVybiB2YWxbcmFuZGludCgwLCB2YWwubGVuZ3RoIC0gMSldO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzZW50ZW5jZSh3b3JkcywgZW5kKSB7XG5cdFx0aWYgKHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0d29yZHNbMF0gPSB3b3Jkc1swXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmRzWzBdLnN1YnN0cmluZygxKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHdvcmRzLmpvaW4oJyAnKSArIChlbmQgfHwgY2hvaWNlKCc/IS4uLicpKTsgLy8gbW9yZSBkb3RzIHRoYXQgcXVlc3Rpb24gbWFya3Ncblx0fVxuXHRcblx0LyoqXG5cdCAqIEluc2VydCBjb21tYXMgYXQgcmFuZG9tbHkgc2VsZWN0ZWQgd29yZHMuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdmFsdWVzXG5cdCAqIGluc2lkZSA8Y29kZT53b3JkczwvY29kZT4gYXJyYXkgXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnNlcnRDb21tYXMod29yZHMpIHtcblx0XHR2YXIgbGVuID0gd29yZHMubGVuZ3RoO1xuXHRcdHZhciB0b3RhbENvbW1hcyA9IDA7XG5cdFx0XG5cdFx0aWYgKGxlbiA+IDMgJiYgbGVuIDw9IDYpIHtcblx0XHRcdHRvdGFsQ29tbWFzID0gcmFuZGludCgwLCAxKTtcblx0XHR9IGVsc2UgaWYgKGxlbiA+IDYgJiYgbGVuIDw9IDEyKSB7XG5cdFx0XHR0b3RhbENvbW1hcyA9IHJhbmRpbnQoMCwgMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvdGFsQ29tbWFzID0gcmFuZGludCgxLCA0KTtcblx0XHR9XG5cblx0XHRfLmVhY2goXy5yYW5nZSh0b3RhbENvbW1hcyksIGZ1bmN0aW9uKGl4KSB7XG5cdFx0XHRpZiAoaXggPCB3b3Jkcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHdvcmRzW2l4XSArPSAnLCc7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHBhcmFncmFwaCBvZiBcIkxvcmVtIGlwc3VtXCIgdGV4dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gd29yZENvdW50IFdvcmRzIGNvdW50IGluIHBhcmFncmFwaFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXJ0V2l0aENvbW1vbiBTaG91bGQgcGFyYWdyYXBoIHN0YXJ0IHdpdGggY29tbW9uIFxuXHQgKiBcImxvcmVtIGlwc3VtXCIgc2VudGVuY2UuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJhZ3JhcGgobGFuZywgd29yZENvdW50LCBzdGFydFdpdGhDb21tb24pIHtcblx0XHR2YXIgZGF0YSA9IGxhbmdzW2xhbmddO1xuXHRcdGlmICghZGF0YSkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR2YXIgdG90YWxXb3JkcyA9IDA7XG5cdFx0dmFyIHdvcmRzO1xuXHRcdFxuXHRcdHdvcmRDb3VudCA9IHBhcnNlSW50KHdvcmRDb3VudCwgMTApO1xuXHRcdFxuXHRcdGlmIChzdGFydFdpdGhDb21tb24gJiYgZGF0YS5jb21tb24pIHtcblx0XHRcdHdvcmRzID0gZGF0YS5jb21tb24uc2xpY2UoMCwgd29yZENvdW50KTtcblx0XHRcdGlmICh3b3Jkcy5sZW5ndGggPiA1KVxuXHRcdFx0XHR3b3Jkc1s0XSArPSAnLCc7XG5cdFx0XHR0b3RhbFdvcmRzICs9IHdvcmRzLmxlbmd0aDtcblx0XHRcdHJlc3VsdC5wdXNoKHNlbnRlbmNlKHdvcmRzLCAnLicpKTtcblx0XHR9XG5cdFx0XG5cdFx0d2hpbGUgKHRvdGFsV29yZHMgPCB3b3JkQ291bnQpIHtcblx0XHRcdHdvcmRzID0gc2FtcGxlKGRhdGEud29yZHMsIE1hdGgubWluKHJhbmRpbnQoMywgMTIpICogcmFuZGludCgxLCA1KSwgd29yZENvdW50IC0gdG90YWxXb3JkcykpO1xuXHRcdFx0dG90YWxXb3JkcyArPSB3b3Jkcy5sZW5ndGg7XG5cdFx0XHRpbnNlcnRDb21tYXMod29yZHMpO1xuXHRcdFx0cmVzdWx0LnB1c2goc2VudGVuY2Uod29yZHMpKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIEFkZHMgbmV3IGxhbmd1YWdlIHdvcmRzIGZvciBMb3JlbSBJcHN1bSBnZW5lcmF0b3Jcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGFuZyBUd28tbGV0dGVyIGxhbmcgZGVmaW5pdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFdvcmRzIGZvciBsYW5ndWFnZS4gTWFpZ2h0IGJlIGVpdGhlciBhIHNwYWNlLXNlcGFyYXRlZCBcblx0XHQgKiBsaXN0IG9mIHdvcmRzIChTdHJpbmcpLCBBcnJheSBvZiB3b3JkcyBvciBvYmplY3Qgd2l0aCA8Y29kZT50ZXh0PC9jb2RlPiBhbmRcblx0XHQgKiA8Y29kZT5jb21tb248L2NvZGU+IHByb3BlcnRpZXNcblx0XHQgKi9cblx0XHRhZGRMYW5nOiBmdW5jdGlvbihsYW5nLCBkYXRhKSB7XG5cdFx0XHRpZiAoXy5pc1N0cmluZyhkYXRhKSkge1xuXHRcdFx0XHRkYXRhID0ge3dvcmRzOiBfLmNvbXBhY3QoZGF0YS5zcGxpdCgnICcpKX07XG5cdFx0XHR9IGVsc2UgaWYgKF8uaXNBcnJheShkYXRhKSkge1xuXHRcdFx0XHRkYXRhID0ge3dvcmRzOiBkYXRhfTtcblx0XHRcdH1cblxuXHRcdFx0bGFuZ3NbbGFuZ10gPSBkYXRhO1xuXHRcdH1cblx0fVxufSk7LyoqXG4gKiBBIGJhY2stZW5kIGJvb3RzdHJhcCBtb2R1bGUgd2l0aCBjb21tb25seSB1c2VkIG1ldGhvZHMgZm9yIGxvYWRpbmcgdXNlciBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1aXJlXG4gKiBAcGFyYW0ge1VuZGVyc2NvcmV9IF8gIFxuICovXG5lbW1ldC5kZWZpbmUoJ2Jvb3RzdHJhcCcsIGZ1bmN0aW9uKHJlcXVpcmUsIF8pIHtcbnZhciBzbmlwcGV0cyA9IHtcblx0XCJ2YXJpYWJsZXNcIjoge1xuXHRcdFwibGFuZ1wiOiBcImVuXCIsXG5cdFx0XCJsb2NhbGVcIjogXCJlbi1VU1wiLFxuXHRcdFwiY2hhcnNldFwiOiBcIlVURi04XCIsXG5cdFx0XCJpbmRlbnRhdGlvblwiOiBcIlxcdFwiLFxuXHRcdFwibmV3bGluZVwiOiBcIlxcblwiXG5cdH0sXG5cdFxuXHRcImNzc1wiOiB7XG5cdFx0XCJmaWx0ZXJzXCI6IFwiaHRtbFwiLFxuXHRcdFwic25pcHBldHNcIjoge1xuXHRcdFx0XCJAaVwiOiBcIkBpbXBvcnQgdXJsKHwpO1wiLFxuXHRcdFx0XCJAaW1wb3J0XCI6IFwiQGltcG9ydCB1cmwofCk7XCIsXG5cdFx0XHRcIkBtXCI6IFwiQG1lZGlhICR7MTpzY3JlZW59IHtcXG5cXHR8XFxufVwiLFxuXHRcdFx0XCJAbWVkaWFcIjogXCJAbWVkaWEgJHsxOnNjcmVlbn0ge1xcblxcdHxcXG59XCIsXG5cdFx0XHRcIkBmXCI6IFwiQGZvbnQtZmFjZSB7XFxuXFx0Zm9udC1mYW1pbHk6fDtcXG5cXHRzcmM6dXJsKHwpO1xcbn1cIixcblx0XHRcdFwiQGYrXCI6IFwiQGZvbnQtZmFjZSB7XFxuXFx0Zm9udC1mYW1pbHk6ICckezE6Rm9udE5hbWV9JztcXG5cXHRzcmM6IHVybCgnJHsyOkZpbGVOYW1lfS5lb3QnKTtcXG5cXHRzcmM6IHVybCgnJHsyOkZpbGVOYW1lfS5lb3Q/I2llZml4JykgZm9ybWF0KCdlbWJlZGRlZC1vcGVudHlwZScpLFxcblxcdFxcdCB1cmwoJyR7MjpGaWxlTmFtZX0ud29mZicpIGZvcm1hdCgnd29mZicpLFxcblxcdFxcdCB1cmwoJyR7MjpGaWxlTmFtZX0udHRmJykgZm9ybWF0KCd0cnVldHlwZScpLFxcblxcdFxcdCB1cmwoJyR7MjpGaWxlTmFtZX0uc3ZnIyR7MTpGb250TmFtZX0nKSBmb3JtYXQoJ3N2ZycpO1xcblxcdGZvbnQtc3R5bGU6ICR7Mzpub3JtYWx9O1xcblxcdGZvbnQtd2VpZ2h0OiAkezQ6bm9ybWFsfTtcXG59XCIsXG5cblx0XHRcdFwiQGtmXCI6IFwiQC13ZWJraXQta2V5ZnJhbWVzICR7MTppZGVudGlmaWVyfSB7XFxuXFx0JHsyOmZyb219IHsgJHszfSB9JHs2fVxcblxcdCR7NDp0b30geyAkezV9IH1cXG59XFxuQC1vLWtleWZyYW1lcyAkezE6aWRlbnRpZmllcn0ge1xcblxcdCR7Mjpmcm9tfSB7ICR7M30gfSR7Nn1cXG5cXHQkezQ6dG99IHsgJHs1fSB9XFxufVxcbkAtbW96LWtleWZyYW1lcyAkezE6aWRlbnRpZmllcn0ge1xcblxcdCR7Mjpmcm9tfSB7ICR7M30gfSR7Nn1cXG5cXHQkezQ6dG99IHsgJHs1fSB9XFxufVxcbkBrZXlmcmFtZXMgJHsxOmlkZW50aWZpZXJ9IHtcXG5cXHQkezI6ZnJvbX0geyAkezN9IH0kezZ9XFxuXFx0JHs0OnRvfSB7ICR7NX0gfVxcbn1cIixcblxuXG5cdFx0XHRcImFuaW1cIjogXCJhbmltYXRpb246fDtcIixcblx0XHRcdFwiYW5pbS1cIjogXCJhbmltYXRpb246JHsxOm5hbWV9ICR7MjpkdXJhdGlvbn0gJHszOnRpbWluZy1mdW5jdGlvbn0gJHs0OmRlbGF5fSAkezU6aXRlcmF0aW9uLWNvdW50fSAkezY6ZGlyZWN0aW9ufSAkezc6ZmlsbC1tb2RlfTtcIixcblx0XHRcdFwiYW5pbWRlbFwiOiBcImFuaW1hdGlvbi1kZWxheTokezE6dGltZX07XCIsXG5cdFx0XHRcblx0XHRcdFwiYW5pbWRpclwiOiBcImFuaW1hdGlvbi1kaXJlY3Rpb246JHsxOm5vcm1hbH07XCIsXG5cdFx0XHRcImFuaW1kaXI6blwiOiBcImFuaW1hdGlvbi1kaXJlY3Rpb246bm9ybWFsO1wiLFxuXHRcdFx0XCJhbmltZGlyOnJcIjogXCJhbmltYXRpb24tZGlyZWN0aW9uOnJldmVyc2U7XCIsXG5cdFx0XHRcImFuaW1kaXI6YVwiOiBcImFuaW1hdGlvbi1kaXJlY3Rpb246YWx0ZXJuYXRlO1wiLFxuXHRcdFx0XCJhbmltZGlyOmFyXCI6IFwiYW5pbWF0aW9uLWRpcmVjdGlvbjphbHRlcm5hdGUtcmV2ZXJzZTtcIixcblx0XHRcdFxuXHRcdFx0XCJhbmltZHVyXCI6IFwiYW5pbWF0aW9uLWR1cmF0aW9uOiR7MTowfXM7XCIsXG5cdFx0XHRcblx0XHRcdFwiYW5pbWZtXCI6IFwiYW5pbWF0aW9uLWZpbGwtbW9kZTokezE6Ym90aH07XCIsXG5cdFx0XHRcImFuaW1mbTpmXCI6IFwiYW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkcztcIixcblx0XHRcdFwiYW5pbWZtOmJcIjogXCJhbmltYXRpb24tZmlsbC1tb2RlOmJhY2t3YXJkcztcIixcblx0XHRcdFwiYW5pbWZtOmJ0XCI6IFwiYW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO1wiLFxuXHRcdFx0XCJhbmltZm06YmhcIjogXCJhbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7XCIsXG5cdFx0XHRcblx0XHRcdFwiYW5pbWljXCI6IFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDokezE6MX07XCIsXG5cdFx0XHRcImFuaW1pYzppXCI6IFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZTtcIixcblx0XHRcdFxuXHRcdFx0XCJhbmltblwiOiBcImFuaW1hdGlvbi1uYW1lOiR7MTpub25lfTtcIixcblxuXHRcdFx0XCJhbmltcHNcIjogXCJhbmltYXRpb24tcGxheS1zdGF0ZTokezE6cnVubmluZ307XCIsXG5cdFx0XHRcImFuaW1wczpwXCI6IFwiYW5pbWF0aW9uLXBsYXktc3RhdGU6cGF1c2VkO1wiLFxuXHRcdFx0XCJhbmltcHM6clwiOiBcImFuaW1hdGlvbi1wbGF5LXN0YXRlOnJ1bm5pbmc7XCIsXG5cblx0XHRcdFwiYW5pbXRmXCI6IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjokezE6bGluZWFyfTtcIixcblx0XHRcdFwiYW5pbXRmOmVcIjogXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2U7XCIsXG5cdFx0XHRcImFuaW10ZjplaVwiOiBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbjtcIixcblx0XHRcdFwiYW5pbXRmOmVvXCI6IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDtcIixcblx0XHRcdFwiYW5pbXRmOmVpb1wiOiBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXQ7XCIsXG5cdFx0XHRcImFuaW10ZjpsXCI6IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7XCIsXG5cdFx0XHRcImFuaW10ZjpjYlwiOiBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKCR7MTowLjF9LCAkezI6MC43fSwgJHszOjEuMH0sICR7MzowLjF9KTtcIixcblx0XHRcdFxuXHRcdFx0XCJhcFwiOiBcImFwcGVhcmFuY2U6JHtub25lfTtcIixcblxuXHRcdFx0XCIhXCI6IFwiIWltcG9ydGFudFwiLFxuXHRcdFx0XCJwb3NcIjogXCJwb3NpdGlvbjokezE6cmVsYXRpdmV9O1wiLFxuXHRcdFx0XCJwb3M6c1wiOiBcInBvc2l0aW9uOnN0YXRpYztcIixcblx0XHRcdFwicG9zOmFcIjogXCJwb3NpdGlvbjphYnNvbHV0ZTtcIixcblx0XHRcdFwicG9zOnJcIjogXCJwb3NpdGlvbjpyZWxhdGl2ZTtcIixcblx0XHRcdFwicG9zOmZcIjogXCJwb3NpdGlvbjpmaXhlZDtcIixcblx0XHRcdFwidFwiOiBcInRvcDp8O1wiLFxuXHRcdFx0XCJ0OmFcIjogXCJ0b3A6YXV0bztcIixcblx0XHRcdFwiclwiOiBcInJpZ2h0Onw7XCIsXG5cdFx0XHRcInI6YVwiOiBcInJpZ2h0OmF1dG87XCIsXG5cdFx0XHRcImJcIjogXCJib3R0b206fDtcIixcblx0XHRcdFwiYjphXCI6IFwiYm90dG9tOmF1dG87XCIsXG5cdFx0XHRcImxcIjogXCJsZWZ0Onw7XCIsXG5cdFx0XHRcImw6YVwiOiBcImxlZnQ6YXV0bztcIixcblx0XHRcdFwielwiOiBcInotaW5kZXg6fDtcIixcblx0XHRcdFwiejphXCI6IFwiei1pbmRleDphdXRvO1wiLFxuXHRcdFx0XCJmbFwiOiBcImZsb2F0OiR7MTpsZWZ0fTtcIixcblx0XHRcdFwiZmw6blwiOiBcImZsb2F0Om5vbmU7XCIsXG5cdFx0XHRcImZsOmxcIjogXCJmbG9hdDpsZWZ0O1wiLFxuXHRcdFx0XCJmbDpyXCI6IFwiZmxvYXQ6cmlnaHQ7XCIsXG5cdFx0XHRcImNsXCI6IFwiY2xlYXI6JHsxOmJvdGh9O1wiLFxuXHRcdFx0XCJjbDpuXCI6IFwiY2xlYXI6bm9uZTtcIixcblx0XHRcdFwiY2w6bFwiOiBcImNsZWFyOmxlZnQ7XCIsXG5cdFx0XHRcImNsOnJcIjogXCJjbGVhcjpyaWdodDtcIixcblx0XHRcdFwiY2w6YlwiOiBcImNsZWFyOmJvdGg7XCIsXG5cblx0XHRcdFwiY29sbVwiOiBcImNvbHVtbnM6fDtcIixcblx0XHRcdFwiY29sbWNcIjogXCJjb2x1bW4tY291bnQ6fDtcIixcblx0XHRcdFwiY29sbWZcIjogXCJjb2x1bW4tZmlsbDp8O1wiLFxuXHRcdFx0XCJjb2xtZ1wiOiBcImNvbHVtbi1nYXA6fDtcIixcblx0XHRcdFwiY29sbXJcIjogXCJjb2x1bW4tcnVsZTp8O1wiLFxuXHRcdFx0XCJjb2xtcmNcIjogXCJjb2x1bW4tcnVsZS1jb2xvcjp8O1wiLFxuXHRcdFx0XCJjb2xtcnNcIjogXCJjb2x1bW4tcnVsZS1zdHlsZTp8O1wiLFxuXHRcdFx0XCJjb2xtcndcIjogXCJjb2x1bW4tcnVsZS13aWR0aDp8O1wiLFxuXHRcdFx0XCJjb2xtc1wiOiBcImNvbHVtbi1zcGFuOnw7XCIsXG5cdFx0XHRcImNvbG13XCI6IFwiY29sdW1uLXdpZHRoOnw7XCIsXG5cblx0XHRcdFwiZFwiOiBcImRpc3BsYXk6JHsxOmJsb2NrfTtcIixcblx0XHRcdFwiZDpuXCI6IFwiZGlzcGxheTpub25lO1wiLFxuXHRcdFx0XCJkOmJcIjogXCJkaXNwbGF5OmJsb2NrO1wiLFxuXHRcdFx0XCJkOmlcIjogXCJkaXNwbGF5OmlubGluZTtcIixcblx0XHRcdFwiZDppYlwiOiBcImRpc3BsYXk6aW5saW5lLWJsb2NrO1wiLFxuXHRcdFx0XCJkOmliK1wiOiBcImRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4qZGlzcGxheTogaW5saW5lO1xcbip6b29tOiAxO1wiLFxuXHRcdFx0XCJkOmxpXCI6IFwiZGlzcGxheTpsaXN0LWl0ZW07XCIsXG5cdFx0XHRcImQ6cmlcIjogXCJkaXNwbGF5OnJ1bi1pbjtcIixcblx0XHRcdFwiZDpjcFwiOiBcImRpc3BsYXk6Y29tcGFjdDtcIixcblx0XHRcdFwiZDp0YlwiOiBcImRpc3BsYXk6dGFibGU7XCIsXG5cdFx0XHRcImQ6aXRiXCI6IFwiZGlzcGxheTppbmxpbmUtdGFibGU7XCIsXG5cdFx0XHRcImQ6dGJjcFwiOiBcImRpc3BsYXk6dGFibGUtY2FwdGlvbjtcIixcblx0XHRcdFwiZDp0YmNsXCI6IFwiZGlzcGxheTp0YWJsZS1jb2x1bW47XCIsXG5cdFx0XHRcImQ6dGJjbGdcIjogXCJkaXNwbGF5OnRhYmxlLWNvbHVtbi1ncm91cDtcIixcblx0XHRcdFwiZDp0YmhnXCI6IFwiZGlzcGxheTp0YWJsZS1oZWFkZXItZ3JvdXA7XCIsXG5cdFx0XHRcImQ6dGJmZ1wiOiBcImRpc3BsYXk6dGFibGUtZm9vdGVyLWdyb3VwO1wiLFxuXHRcdFx0XCJkOnRiclwiOiBcImRpc3BsYXk6dGFibGUtcm93O1wiLFxuXHRcdFx0XCJkOnRicmdcIjogXCJkaXNwbGF5OnRhYmxlLXJvdy1ncm91cDtcIixcblx0XHRcdFwiZDp0YmNcIjogXCJkaXNwbGF5OnRhYmxlLWNlbGw7XCIsXG5cdFx0XHRcImQ6cmJcIjogXCJkaXNwbGF5OnJ1Ynk7XCIsXG5cdFx0XHRcImQ6cmJiXCI6IFwiZGlzcGxheTpydWJ5LWJhc2U7XCIsXG5cdFx0XHRcImQ6cmJiZ1wiOiBcImRpc3BsYXk6cnVieS1iYXNlLWdyb3VwO1wiLFxuXHRcdFx0XCJkOnJidFwiOiBcImRpc3BsYXk6cnVieS10ZXh0O1wiLFxuXHRcdFx0XCJkOnJidGdcIjogXCJkaXNwbGF5OnJ1YnktdGV4dC1ncm91cDtcIixcblx0XHRcdFwidlwiOiBcInZpc2liaWxpdHk6JHsxOmhpZGRlbn07XCIsXG5cdFx0XHRcInY6dlwiOiBcInZpc2liaWxpdHk6dmlzaWJsZTtcIixcblx0XHRcdFwidjpoXCI6IFwidmlzaWJpbGl0eTpoaWRkZW47XCIsXG5cdFx0XHRcInY6Y1wiOiBcInZpc2liaWxpdHk6Y29sbGFwc2U7XCIsXG5cdFx0XHRcIm92XCI6IFwib3ZlcmZsb3c6JHsxOmhpZGRlbn07XCIsXG5cdFx0XHRcIm92OnZcIjogXCJvdmVyZmxvdzp2aXNpYmxlO1wiLFxuXHRcdFx0XCJvdjpoXCI6IFwib3ZlcmZsb3c6aGlkZGVuO1wiLFxuXHRcdFx0XCJvdjpzXCI6IFwib3ZlcmZsb3c6c2Nyb2xsO1wiLFxuXHRcdFx0XCJvdjphXCI6IFwib3ZlcmZsb3c6YXV0bztcIixcblx0XHRcdFwib3Z4XCI6IFwib3ZlcmZsb3cteDokezE6aGlkZGVufTtcIixcblx0XHRcdFwib3Z4OnZcIjogXCJvdmVyZmxvdy14OnZpc2libGU7XCIsXG5cdFx0XHRcIm92eDpoXCI6IFwib3ZlcmZsb3cteDpoaWRkZW47XCIsXG5cdFx0XHRcIm92eDpzXCI6IFwib3ZlcmZsb3cteDpzY3JvbGw7XCIsXG5cdFx0XHRcIm92eDphXCI6IFwib3ZlcmZsb3cteDphdXRvO1wiLFxuXHRcdFx0XCJvdnlcIjogXCJvdmVyZmxvdy15OiR7MTpoaWRkZW59O1wiLFxuXHRcdFx0XCJvdnk6dlwiOiBcIm92ZXJmbG93LXk6dmlzaWJsZTtcIixcblx0XHRcdFwib3Z5OmhcIjogXCJvdmVyZmxvdy15OmhpZGRlbjtcIixcblx0XHRcdFwib3Z5OnNcIjogXCJvdmVyZmxvdy15OnNjcm9sbDtcIixcblx0XHRcdFwib3Z5OmFcIjogXCJvdmVyZmxvdy15OmF1dG87XCIsXG5cdFx0XHRcIm92c1wiOiBcIm92ZXJmbG93LXN0eWxlOiR7MTpzY3JvbGxiYXJ9O1wiLFxuXHRcdFx0XCJvdnM6YVwiOiBcIm92ZXJmbG93LXN0eWxlOmF1dG87XCIsXG5cdFx0XHRcIm92czpzXCI6IFwib3ZlcmZsb3ctc3R5bGU6c2Nyb2xsYmFyO1wiLFxuXHRcdFx0XCJvdnM6cFwiOiBcIm92ZXJmbG93LXN0eWxlOnBhbm5lcjtcIixcblx0XHRcdFwib3ZzOm1cIjogXCJvdmVyZmxvdy1zdHlsZTptb3ZlO1wiLFxuXHRcdFx0XCJvdnM6bXFcIjogXCJvdmVyZmxvdy1zdHlsZTptYXJxdWVlO1wiLFxuXHRcdFx0XCJ6b29cIjogXCJ6b29tOjE7XCIsXG5cdFx0XHRcInptXCI6IFwiem9vbToxO1wiLFxuXHRcdFx0XCJjcFwiOiBcImNsaXA6fDtcIixcblx0XHRcdFwiY3A6YVwiOiBcImNsaXA6YXV0bztcIixcblx0XHRcdFwiY3A6clwiOiBcImNsaXA6cmVjdCgkezE6dG9wfSAkezI6cmlnaHR9ICR7Mzpib3R0b219ICR7NDpsZWZ0fSk7XCIsXG5cdFx0XHRcImJ4elwiOiBcImJveC1zaXppbmc6JHsxOmJvcmRlci1ib3h9O1wiLFxuXHRcdFx0XCJieHo6Y2JcIjogXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiLFxuXHRcdFx0XCJieHo6YmJcIjogXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIsXG5cdFx0XHRcImJ4c2hcIjogXCJib3gtc2hhZG93OiR7MTppbnNldCB9JHsyOmhvZmZ9ICR7Mzp2b2ZmfSAkezQ6Ymx1cn0gJHs1OmNvbG9yfTtcIixcblx0XHRcdFwiYnhzaDpyXCI6IFwiYm94LXNoYWRvdzokezE6aW5zZXQgfSR7Mjpob2ZmfSAkezM6dm9mZn0gJHs0OmJsdXJ9ICR7NTpzcHJlYWQgfXJnYigkezY6MH0sICR7NzowfSwgJHs4OjB9KTtcIixcblx0XHRcdFwiYnhzaDpyYVwiOiBcImJveC1zaGFkb3c6JHsxOmluc2V0IH0kezI6aH0gJHszOnZ9ICR7NDpibHVyfSAkezU6c3ByZWFkIH1yZ2JhKCR7NjowfSwgJHs3OjB9LCAkezg6MH0sIC4kezk6NX0pO1wiLFxuXHRcdFx0XCJieHNoOm5cIjogXCJib3gtc2hhZG93Om5vbmU7XCIsXG5cdFx0XHRcIm1cIjogXCJtYXJnaW46fDtcIixcblx0XHRcdFwibTphXCI6IFwibWFyZ2luOmF1dG87XCIsXG5cdFx0XHRcIm10XCI6IFwibWFyZ2luLXRvcDp8O1wiLFxuXHRcdFx0XCJtdDphXCI6IFwibWFyZ2luLXRvcDphdXRvO1wiLFxuXHRcdFx0XCJtclwiOiBcIm1hcmdpbi1yaWdodDp8O1wiLFxuXHRcdFx0XCJtcjphXCI6IFwibWFyZ2luLXJpZ2h0OmF1dG87XCIsXG5cdFx0XHRcIm1iXCI6IFwibWFyZ2luLWJvdHRvbTp8O1wiLFxuXHRcdFx0XCJtYjphXCI6IFwibWFyZ2luLWJvdHRvbTphdXRvO1wiLFxuXHRcdFx0XCJtbFwiOiBcIm1hcmdpbi1sZWZ0Onw7XCIsXG5cdFx0XHRcIm1sOmFcIjogXCJtYXJnaW4tbGVmdDphdXRvO1wiLFxuXHRcdFx0XCJwXCI6IFwicGFkZGluZzp8O1wiLFxuXHRcdFx0XCJwdFwiOiBcInBhZGRpbmctdG9wOnw7XCIsXG5cdFx0XHRcInByXCI6IFwicGFkZGluZy1yaWdodDp8O1wiLFxuXHRcdFx0XCJwYlwiOiBcInBhZGRpbmctYm90dG9tOnw7XCIsXG5cdFx0XHRcInBsXCI6IFwicGFkZGluZy1sZWZ0Onw7XCIsXG5cdFx0XHRcIndcIjogXCJ3aWR0aDp8O1wiLFxuXHRcdFx0XCJ3OmFcIjogXCJ3aWR0aDphdXRvO1wiLFxuXHRcdFx0XCJoXCI6IFwiaGVpZ2h0Onw7XCIsXG5cdFx0XHRcImg6YVwiOiBcImhlaWdodDphdXRvO1wiLFxuXHRcdFx0XCJtYXdcIjogXCJtYXgtd2lkdGg6fDtcIixcblx0XHRcdFwibWF3Om5cIjogXCJtYXgtd2lkdGg6bm9uZTtcIixcblx0XHRcdFwibWFoXCI6IFwibWF4LWhlaWdodDp8O1wiLFxuXHRcdFx0XCJtYWg6blwiOiBcIm1heC1oZWlnaHQ6bm9uZTtcIixcblx0XHRcdFwibWl3XCI6IFwibWluLXdpZHRoOnw7XCIsXG5cdFx0XHRcIm1paFwiOiBcIm1pbi1oZWlnaHQ6fDtcIixcblx0XHRcdFwibWFyXCI6IFwibWF4LXJlc29sdXRpb246JHsxOnJlc307XCIsXG5cdFx0XHRcIm1pclwiOiBcIm1pbi1yZXNvbHV0aW9uOiR7MTpyZXN9O1wiLFxuXHRcdFx0XCJvcmlcIjogXCJvcmllbnRhdGlvbjp8O1wiLFxuXHRcdFx0XCJvcmk6bFwiOiBcIm9yaWVudGF0aW9uOmxhbmRzY2FwZTtcIixcblx0XHRcdFwib3JpOnBcIjogXCJvcmllbnRhdGlvbjpwb3J0cmFpdDtcIixcblx0XHRcdFwib2xcIjogXCJvdXRsaW5lOnw7XCIsXG5cdFx0XHRcIm9sOm5cIjogXCJvdXRsaW5lOm5vbmU7XCIsXG5cdFx0XHRcIm9sb1wiOiBcIm91dGxpbmUtb2Zmc2V0Onw7XCIsXG5cdFx0XHRcIm9sd1wiOiBcIm91dGxpbmUtd2lkdGg6fDtcIixcblx0XHRcdFwib2x3OnRuXCI6IFwib3V0bGluZS13aWR0aDp0aGluO1wiLFxuXHRcdFx0XCJvbHc6bVwiOiBcIm91dGxpbmUtd2lkdGg6bWVkaXVtO1wiLFxuXHRcdFx0XCJvbHc6dGNcIjogXCJvdXRsaW5lLXdpZHRoOnRoaWNrO1wiLFxuXHRcdFx0XCJvbHNcIjogXCJvdXRsaW5lLXN0eWxlOnw7XCIsXG5cdFx0XHRcIm9sczpuXCI6IFwib3V0bGluZS1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJvbHM6ZHRcIjogXCJvdXRsaW5lLXN0eWxlOmRvdHRlZDtcIixcblx0XHRcdFwib2xzOmRzXCI6IFwib3V0bGluZS1zdHlsZTpkYXNoZWQ7XCIsXG5cdFx0XHRcIm9sczpzXCI6IFwib3V0bGluZS1zdHlsZTpzb2xpZDtcIixcblx0XHRcdFwib2xzOmRiXCI6IFwib3V0bGluZS1zdHlsZTpkb3VibGU7XCIsXG5cdFx0XHRcIm9sczpnXCI6IFwib3V0bGluZS1zdHlsZTpncm9vdmU7XCIsXG5cdFx0XHRcIm9sczpyXCI6IFwib3V0bGluZS1zdHlsZTpyaWRnZTtcIixcblx0XHRcdFwib2xzOmlcIjogXCJvdXRsaW5lLXN0eWxlOmluc2V0O1wiLFxuXHRcdFx0XCJvbHM6b1wiOiBcIm91dGxpbmUtc3R5bGU6b3V0c2V0O1wiLFxuXHRcdFx0XCJvbGNcIjogXCJvdXRsaW5lLWNvbG9yOiMkezE6MDAwfTtcIixcblx0XHRcdFwib2xjOmlcIjogXCJvdXRsaW5lLWNvbG9yOmludmVydDtcIixcblx0XHRcdFwiYmRcIjogXCJib3JkZXI6fDtcIixcblx0XHRcdFwiYmQrXCI6IFwiYm9yZGVyOiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZDpuXCI6IFwiYm9yZGVyOm5vbmU7XCIsXG5cdFx0XHRcImJkYmtcIjogXCJib3JkZXItYnJlYWs6JHsxOmNsb3NlfTtcIixcblx0XHRcdFwiYmRiazpjXCI6IFwiYm9yZGVyLWJyZWFrOmNsb3NlO1wiLFxuXHRcdFx0XCJiZGNsXCI6IFwiYm9yZGVyLWNvbGxhcHNlOnw7XCIsXG5cdFx0XHRcImJkY2w6Y1wiOiBcImJvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtcIixcblx0XHRcdFwiYmRjbDpzXCI6IFwiYm9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlO1wiLFxuXHRcdFx0XCJiZGNcIjogXCJib3JkZXItY29sb3I6IyR7MTowMDB9O1wiLFxuXHRcdFx0XCJiZGM6dFwiOiBcImJvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtcIixcblx0XHRcdFwiYmRpXCI6IFwiYm9yZGVyLWltYWdlOnVybCh8KTtcIixcblx0XHRcdFwiYmRpOm5cIjogXCJib3JkZXItaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmR0aVwiOiBcImJvcmRlci10b3AtaW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZHRpOm5cIjogXCJib3JkZXItdG9wLWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkcmlcIjogXCJib3JkZXItcmlnaHQtaW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZHJpOm5cIjogXCJib3JkZXItcmlnaHQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmRiaVwiOiBcImJvcmRlci1ib3R0b20taW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZGJpOm5cIjogXCJib3JkZXItYm90dG9tLWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkbGlcIjogXCJib3JkZXItbGVmdC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkbGk6blwiOiBcImJvcmRlci1sZWZ0LWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkY2lcIjogXCJib3JkZXItY29ybmVyLWltYWdlOnVybCh8KTtcIixcblx0XHRcdFwiYmRjaTpuXCI6IFwiYm9yZGVyLWNvcm5lci1pbWFnZTpub25lO1wiLFxuXHRcdFx0XCJiZGNpOmNcIjogXCJib3JkZXItY29ybmVyLWltYWdlOmNvbnRpbnVlO1wiLFxuXHRcdFx0XCJiZHRsaVwiOiBcImJvcmRlci10b3AtbGVmdC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkdGxpOm5cIjogXCJib3JkZXItdG9wLWxlZnQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmR0bGk6Y1wiOiBcImJvcmRlci10b3AtbGVmdC1pbWFnZTpjb250aW51ZTtcIixcblx0XHRcdFwiYmR0cmlcIjogXCJib3JkZXItdG9wLXJpZ2h0LWltYWdlOnVybCh8KTtcIixcblx0XHRcdFwiYmR0cmk6blwiOiBcImJvcmRlci10b3AtcmlnaHQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmR0cmk6Y1wiOiBcImJvcmRlci10b3AtcmlnaHQtaW1hZ2U6Y29udGludWU7XCIsXG5cdFx0XHRcImJkYnJpXCI6IFwiYm9yZGVyLWJvdHRvbS1yaWdodC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkYnJpOm5cIjogXCJib3JkZXItYm90dG9tLXJpZ2h0LWltYWdlOm5vbmU7XCIsXG5cdFx0XHRcImJkYnJpOmNcIjogXCJib3JkZXItYm90dG9tLXJpZ2h0LWltYWdlOmNvbnRpbnVlO1wiLFxuXHRcdFx0XCJiZGJsaVwiOiBcImJvcmRlci1ib3R0b20tbGVmdC1pbWFnZTp1cmwofCk7XCIsXG5cdFx0XHRcImJkYmxpOm5cIjogXCJib3JkZXItYm90dG9tLWxlZnQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmRibGk6Y1wiOiBcImJvcmRlci1ib3R0b20tbGVmdC1pbWFnZTpjb250aW51ZTtcIixcblx0XHRcdFwiYmRmXCI6IFwiYm9yZGVyLWZpdDokezE6cmVwZWF0fTtcIixcblx0XHRcdFwiYmRmOmNcIjogXCJib3JkZXItZml0OmNsaXA7XCIsXG5cdFx0XHRcImJkZjpyXCI6IFwiYm9yZGVyLWZpdDpyZXBlYXQ7XCIsXG5cdFx0XHRcImJkZjpzY1wiOiBcImJvcmRlci1maXQ6c2NhbGU7XCIsXG5cdFx0XHRcImJkZjpzdFwiOiBcImJvcmRlci1maXQ6c3RyZXRjaDtcIixcblx0XHRcdFwiYmRmOm93XCI6IFwiYm9yZGVyLWZpdDpvdmVyd3JpdGU7XCIsXG5cdFx0XHRcImJkZjpvZlwiOiBcImJvcmRlci1maXQ6b3ZlcmZsb3c7XCIsXG5cdFx0XHRcImJkZjpzcFwiOiBcImJvcmRlci1maXQ6c3BhY2U7XCIsXG5cdFx0XHRcImJkbGVuXCI6IFwiYm9yZGVyLWxlbmd0aDp8O1wiLFxuXHRcdFx0XCJiZGxlbjphXCI6IFwiYm9yZGVyLWxlbmd0aDphdXRvO1wiLFxuXHRcdFx0XCJiZHNwXCI6IFwiYm9yZGVyLXNwYWNpbmc6fDtcIixcblx0XHRcdFwiYmRzXCI6IFwiYm9yZGVyLXN0eWxlOnw7XCIsXG5cdFx0XHRcImJkczpuXCI6IFwiYm9yZGVyLXN0eWxlOm5vbmU7XCIsXG5cdFx0XHRcImJkczpoXCI6IFwiYm9yZGVyLXN0eWxlOmhpZGRlbjtcIixcblx0XHRcdFwiYmRzOmR0XCI6IFwiYm9yZGVyLXN0eWxlOmRvdHRlZDtcIixcblx0XHRcdFwiYmRzOmRzXCI6IFwiYm9yZGVyLXN0eWxlOmRhc2hlZDtcIixcblx0XHRcdFwiYmRzOnNcIjogXCJib3JkZXItc3R5bGU6c29saWQ7XCIsXG5cdFx0XHRcImJkczpkYlwiOiBcImJvcmRlci1zdHlsZTpkb3VibGU7XCIsXG5cdFx0XHRcImJkczpkdGRzXCI6IFwiYm9yZGVyLXN0eWxlOmRvdC1kYXNoO1wiLFxuXHRcdFx0XCJiZHM6ZHRkdGRzXCI6IFwiYm9yZGVyLXN0eWxlOmRvdC1kb3QtZGFzaDtcIixcblx0XHRcdFwiYmRzOndcIjogXCJib3JkZXItc3R5bGU6d2F2ZTtcIixcblx0XHRcdFwiYmRzOmdcIjogXCJib3JkZXItc3R5bGU6Z3Jvb3ZlO1wiLFxuXHRcdFx0XCJiZHM6clwiOiBcImJvcmRlci1zdHlsZTpyaWRnZTtcIixcblx0XHRcdFwiYmRzOmlcIjogXCJib3JkZXItc3R5bGU6aW5zZXQ7XCIsXG5cdFx0XHRcImJkczpvXCI6IFwiYm9yZGVyLXN0eWxlOm91dHNldDtcIixcblx0XHRcdFwiYmR3XCI6IFwiYm9yZGVyLXdpZHRoOnw7XCIsXG5cdFx0XHRcImJkdHdcIjogXCJib3JkZXItdG9wLXdpZHRoOnw7XCIsXG5cdFx0XHRcImJkcndcIjogXCJib3JkZXItcmlnaHQtd2lkdGg6fDtcIixcblx0XHRcdFwiYmRid1wiOiBcImJvcmRlci1ib3R0b20td2lkdGg6fDtcIixcblx0XHRcdFwiYmRsd1wiOiBcImJvcmRlci1sZWZ0LXdpZHRoOnw7XCIsXG5cdFx0XHRcImJkdFwiOiBcImJvcmRlci10b3A6fDtcIixcblx0XHRcdFwiYnRcIjogXCJib3JkZXItdG9wOnw7XCIsXG5cdFx0XHRcImJkdCtcIjogXCJib3JkZXItdG9wOiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZHQ6blwiOiBcImJvcmRlci10b3A6bm9uZTtcIixcblx0XHRcdFwiYmR0c1wiOiBcImJvcmRlci10b3Atc3R5bGU6fDtcIixcblx0XHRcdFwiYmR0czpuXCI6IFwiYm9yZGVyLXRvcC1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJiZHRjXCI6IFwiYm9yZGVyLXRvcC1jb2xvcjojJHsxOjAwMH07XCIsXG5cdFx0XHRcImJkdGM6dFwiOiBcImJvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJkclwiOiBcImJvcmRlci1yaWdodDp8O1wiLFxuXHRcdFx0XCJiclwiOiBcImJvcmRlci1yaWdodDp8O1wiLFxuXHRcdFx0XCJiZHIrXCI6IFwiYm9yZGVyLXJpZ2h0OiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZHI6blwiOiBcImJvcmRlci1yaWdodDpub25lO1wiLFxuXHRcdFx0XCJiZHJzdFwiOiBcImJvcmRlci1yaWdodC1zdHlsZTp8O1wiLFxuXHRcdFx0XCJiZHJzdDpuXCI6IFwiYm9yZGVyLXJpZ2h0LXN0eWxlOm5vbmU7XCIsXG5cdFx0XHRcImJkcmNcIjogXCJib3JkZXItcmlnaHQtY29sb3I6IyR7MTowMDB9O1wiLFxuXHRcdFx0XCJiZHJjOnRcIjogXCJib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJkYlwiOiBcImJvcmRlci1ib3R0b206fDtcIixcblx0XHRcdFwiYmJcIjogXCJib3JkZXItYm90dG9tOnw7XCIsXG5cdFx0XHRcImJkYitcIjogXCJib3JkZXItYm90dG9tOiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZGI6blwiOiBcImJvcmRlci1ib3R0b206bm9uZTtcIixcblx0XHRcdFwiYmRic1wiOiBcImJvcmRlci1ib3R0b20tc3R5bGU6fDtcIixcblx0XHRcdFwiYmRiczpuXCI6IFwiYm9yZGVyLWJvdHRvbS1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJiZGJjXCI6IFwiYm9yZGVyLWJvdHRvbS1jb2xvcjojJHsxOjAwMH07XCIsXG5cdFx0XHRcImJkYmM6dFwiOiBcImJvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJkbFwiOiBcImJvcmRlci1sZWZ0Onw7XCIsXG5cdFx0XHRcImJsXCI6IFwiYm9yZGVyLWxlZnQ6fDtcIixcblx0XHRcdFwiYmRsK1wiOiBcImJvcmRlci1sZWZ0OiR7MToxcHh9ICR7Mjpzb2xpZH0gJHszOiMwMDB9O1wiLFxuXHRcdFx0XCJiZGw6blwiOiBcImJvcmRlci1sZWZ0Om5vbmU7XCIsXG5cdFx0XHRcImJkbHNcIjogXCJib3JkZXItbGVmdC1zdHlsZTp8O1wiLFxuXHRcdFx0XCJiZGxzOm5cIjogXCJib3JkZXItbGVmdC1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJiZGxjXCI6IFwiYm9yZGVyLWxlZnQtY29sb3I6IyR7MTowMDB9O1wiLFxuXHRcdFx0XCJiZGxjOnRcIjogXCJib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtcIixcblx0XHRcdFwiYmRyc1wiOiBcImJvcmRlci1yYWRpdXM6fDtcIixcblx0XHRcdFwiYmR0cnJzXCI6IFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6fDtcIixcblx0XHRcdFwiYmR0bHJzXCI6IFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czp8O1wiLFxuXHRcdFx0XCJiZGJycnNcIjogXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp8O1wiLFxuXHRcdFx0XCJiZGJscnNcIjogXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnw7XCIsXG5cdFx0XHRcImJnXCI6IFwiYmFja2dyb3VuZDojJHsxOjAwMH07XCIsXG5cdFx0XHRcImJnK1wiOiBcImJhY2tncm91bmQ6JHsxOiNmZmZ9IHVybCgkezJ9KSAkezM6MH0gJHs0OjB9ICR7NTpuby1yZXBlYXR9O1wiLFxuXHRcdFx0XCJiZzpuXCI6IFwiYmFja2dyb3VuZDpub25lO1wiLFxuXHRcdFx0XCJiZzppZVwiOiBcImZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyR7MTp4fS5wbmcnLHNpemluZ01ldGhvZD0nJHsyOmNyb3B9Jyk7XCIsXG5cdFx0XHRcImJnY1wiOiBcImJhY2tncm91bmQtY29sb3I6IyR7MTpmZmZ9O1wiLFxuXHRcdFx0XCJiZ2M6dFwiOiBcImJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7XCIsXG5cdFx0XHRcImJnaVwiOiBcImJhY2tncm91bmQtaW1hZ2U6dXJsKHwpO1wiLFxuXHRcdFx0XCJiZ2k6blwiOiBcImJhY2tncm91bmQtaW1hZ2U6bm9uZTtcIixcblx0XHRcdFwiYmdyXCI6IFwiYmFja2dyb3VuZC1yZXBlYXQ6fDtcIixcblx0XHRcdFwiYmdyOm5cIjogXCJiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7XCIsXG5cdFx0XHRcImJncjp4XCI6IFwiYmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7XCIsXG5cdFx0XHRcImJncjp5XCI6IFwiYmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXk7XCIsXG5cdFx0XHRcImJncjpzcFwiOiBcImJhY2tncm91bmQtcmVwZWF0OnNwYWNlO1wiLFxuXHRcdFx0XCJiZ3I6cmRcIjogXCJiYWNrZ3JvdW5kLXJlcGVhdDpyb3VuZDtcIixcblx0XHRcdFwiYmdhXCI6IFwiYmFja2dyb3VuZC1hdHRhY2htZW50Onw7XCIsXG5cdFx0XHRcImJnYTpmXCI6IFwiYmFja2dyb3VuZC1hdHRhY2htZW50OmZpeGVkO1wiLFxuXHRcdFx0XCJiZ2E6c1wiOiBcImJhY2tncm91bmQtYXR0YWNobWVudDpzY3JvbGw7XCIsXG5cdFx0XHRcImJncFwiOiBcImJhY2tncm91bmQtcG9zaXRpb246JHsxOjB9ICR7MjowfTtcIixcblx0XHRcdFwiYmdweFwiOiBcImJhY2tncm91bmQtcG9zaXRpb24teDp8O1wiLFxuXHRcdFx0XCJiZ3B5XCI6IFwiYmFja2dyb3VuZC1wb3NpdGlvbi15Onw7XCIsXG5cdFx0XHRcImJnYmtcIjogXCJiYWNrZ3JvdW5kLWJyZWFrOnw7XCIsXG5cdFx0XHRcImJnYms6YmJcIjogXCJiYWNrZ3JvdW5kLWJyZWFrOmJvdW5kaW5nLWJveDtcIixcblx0XHRcdFwiYmdiazplYlwiOiBcImJhY2tncm91bmQtYnJlYWs6ZWFjaC1ib3g7XCIsXG5cdFx0XHRcImJnYms6Y1wiOiBcImJhY2tncm91bmQtYnJlYWs6Y29udGludW91cztcIixcblx0XHRcdFwiYmdjcFwiOiBcImJhY2tncm91bmQtY2xpcDokezE6cGFkZGluZy1ib3h9O1wiLFxuXHRcdFx0XCJiZ2NwOmJiXCI6IFwiYmFja2dyb3VuZC1jbGlwOmJvcmRlci1ib3g7XCIsXG5cdFx0XHRcImJnY3A6cGJcIjogXCJiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7XCIsXG5cdFx0XHRcImJnY3A6Y2JcIjogXCJiYWNrZ3JvdW5kLWNsaXA6Y29udGVudC1ib3g7XCIsXG5cdFx0XHRcImJnY3A6bmNcIjogXCJiYWNrZ3JvdW5kLWNsaXA6bm8tY2xpcDtcIixcblx0XHRcdFwiYmdvXCI6IFwiYmFja2dyb3VuZC1vcmlnaW46fDtcIixcblx0XHRcdFwiYmdvOnBiXCI6IFwiYmFja2dyb3VuZC1vcmlnaW46cGFkZGluZy1ib3g7XCIsXG5cdFx0XHRcImJnbzpiYlwiOiBcImJhY2tncm91bmQtb3JpZ2luOmJvcmRlci1ib3g7XCIsXG5cdFx0XHRcImJnbzpjYlwiOiBcImJhY2tncm91bmQtb3JpZ2luOmNvbnRlbnQtYm94O1wiLFxuXHRcdFx0XCJiZ3N6XCI6IFwiYmFja2dyb3VuZC1zaXplOnw7XCIsXG5cdFx0XHRcImJnc3o6YVwiOiBcImJhY2tncm91bmQtc2l6ZTphdXRvO1wiLFxuXHRcdFx0XCJiZ3N6OmN0XCI6IFwiYmFja2dyb3VuZC1zaXplOmNvbnRhaW47XCIsXG5cdFx0XHRcImJnc3o6Y3ZcIjogXCJiYWNrZ3JvdW5kLXNpemU6Y292ZXI7XCIsXG5cdFx0XHRcImNcIjogXCJjb2xvcjojJHsxOjAwMH07XCIsXG5cdFx0XHRcImM6clwiOiBcImNvbG9yOnJnYigkezE6MH0sICR7MjowfSwgJHszOjB9KTtcIixcblx0XHRcdFwiYzpyYVwiOiBcImNvbG9yOnJnYmEoJHsxOjB9LCAkezI6MH0sICR7MzowfSwgLiR7NDo1fSk7XCIsXG5cdFx0XHRcImNtXCI6IFwiLyogfCR7Y2hpbGR9ICovXCIsXG5cdFx0XHRcImNudFwiOiBcImNvbnRlbnQ6J3wnO1wiLFxuXHRcdFx0XCJjbnQ6blwiOiBcImNvbnRlbnQ6bm9ybWFsO1wiLFxuXHRcdFx0XCJjbnQ6b3FcIjogXCJjb250ZW50Om9wZW4tcXVvdGU7XCIsXG5cdFx0XHRcImNudDpub3FcIjogXCJjb250ZW50Om5vLW9wZW4tcXVvdGU7XCIsXG5cdFx0XHRcImNudDpjcVwiOiBcImNvbnRlbnQ6Y2xvc2UtcXVvdGU7XCIsXG5cdFx0XHRcImNudDpuY3FcIjogXCJjb250ZW50Om5vLWNsb3NlLXF1b3RlO1wiLFxuXHRcdFx0XCJjbnQ6YVwiOiBcImNvbnRlbnQ6YXR0cih8KTtcIixcblx0XHRcdFwiY250OmNcIjogXCJjb250ZW50OmNvdW50ZXIofCk7XCIsXG5cdFx0XHRcImNudDpjc1wiOiBcImNvbnRlbnQ6Y291bnRlcnMofCk7XCIsXG5cblxuXHRcdFx0XCJ0YmxcIjogXCJ0YWJsZS1sYXlvdXQ6fDtcIixcblx0XHRcdFwidGJsOmFcIjogXCJ0YWJsZS1sYXlvdXQ6YXV0bztcIixcblx0XHRcdFwidGJsOmZcIjogXCJ0YWJsZS1sYXlvdXQ6Zml4ZWQ7XCIsXG5cdFx0XHRcImNwc1wiOiBcImNhcHRpb24tc2lkZTp8O1wiLFxuXHRcdFx0XCJjcHM6dFwiOiBcImNhcHRpb24tc2lkZTp0b3A7XCIsXG5cdFx0XHRcImNwczpiXCI6IFwiY2FwdGlvbi1zaWRlOmJvdHRvbTtcIixcblx0XHRcdFwiZWNcIjogXCJlbXB0eS1jZWxsczp8O1wiLFxuXHRcdFx0XCJlYzpzXCI6IFwiZW1wdHktY2VsbHM6c2hvdztcIixcblx0XHRcdFwiZWM6aFwiOiBcImVtcHR5LWNlbGxzOmhpZGU7XCIsXG5cdFx0XHRcImxpc1wiOiBcImxpc3Qtc3R5bGU6fDtcIixcblx0XHRcdFwibGlzOm5cIjogXCJsaXN0LXN0eWxlOm5vbmU7XCIsXG5cdFx0XHRcImxpc3BcIjogXCJsaXN0LXN0eWxlLXBvc2l0aW9uOnw7XCIsXG5cdFx0XHRcImxpc3A6aVwiOiBcImxpc3Qtc3R5bGUtcG9zaXRpb246aW5zaWRlO1wiLFxuXHRcdFx0XCJsaXNwOm9cIjogXCJsaXN0LXN0eWxlLXBvc2l0aW9uOm91dHNpZGU7XCIsXG5cdFx0XHRcImxpc3RcIjogXCJsaXN0LXN0eWxlLXR5cGU6fDtcIixcblx0XHRcdFwibGlzdDpuXCI6IFwibGlzdC1zdHlsZS10eXBlOm5vbmU7XCIsXG5cdFx0XHRcImxpc3Q6ZFwiOiBcImxpc3Qtc3R5bGUtdHlwZTpkaXNjO1wiLFxuXHRcdFx0XCJsaXN0OmNcIjogXCJsaXN0LXN0eWxlLXR5cGU6Y2lyY2xlO1wiLFxuXHRcdFx0XCJsaXN0OnNcIjogXCJsaXN0LXN0eWxlLXR5cGU6c3F1YXJlO1wiLFxuXHRcdFx0XCJsaXN0OmRjXCI6IFwibGlzdC1zdHlsZS10eXBlOmRlY2ltYWw7XCIsXG5cdFx0XHRcImxpc3Q6ZGNselwiOiBcImxpc3Qtc3R5bGUtdHlwZTpkZWNpbWFsLWxlYWRpbmctemVybztcIixcblx0XHRcdFwibGlzdDpsclwiOiBcImxpc3Qtc3R5bGUtdHlwZTpsb3dlci1yb21hbjtcIixcblx0XHRcdFwibGlzdDp1clwiOiBcImxpc3Qtc3R5bGUtdHlwZTp1cHBlci1yb21hbjtcIixcblx0XHRcdFwibGlzaVwiOiBcImxpc3Qtc3R5bGUtaW1hZ2U6fDtcIixcblx0XHRcdFwibGlzaTpuXCI6IFwibGlzdC1zdHlsZS1pbWFnZTpub25lO1wiLFxuXHRcdFx0XCJxXCI6IFwicXVvdGVzOnw7XCIsXG5cdFx0XHRcInE6blwiOiBcInF1b3Rlczpub25lO1wiLFxuXHRcdFx0XCJxOnJ1XCI6IFwicXVvdGVzOidcXFxcMDBBQicgJ1xcXFwwMEJCJyAnXFxcXDIwMUUnICdcXFxcMjAxQyc7XCIsXG5cdFx0XHRcInE6ZW5cIjogXCJxdW90ZXM6J1xcXFwyMDFDJyAnXFxcXDIwMUQnICdcXFxcMjAxOCcgJ1xcXFwyMDE5JztcIixcblx0XHRcdFwiY3RcIjogXCJjb250ZW50Onw7XCIsXG5cdFx0XHRcImN0Om5cIjogXCJjb250ZW50Om5vcm1hbDtcIixcblx0XHRcdFwiY3Q6b3FcIjogXCJjb250ZW50Om9wZW4tcXVvdGU7XCIsXG5cdFx0XHRcImN0Om5vcVwiOiBcImNvbnRlbnQ6bm8tb3Blbi1xdW90ZTtcIixcblx0XHRcdFwiY3Q6Y3FcIjogXCJjb250ZW50OmNsb3NlLXF1b3RlO1wiLFxuXHRcdFx0XCJjdDpuY3FcIjogXCJjb250ZW50Om5vLWNsb3NlLXF1b3RlO1wiLFxuXHRcdFx0XCJjdDphXCI6IFwiY29udGVudDphdHRyKHwpO1wiLFxuXHRcdFx0XCJjdDpjXCI6IFwiY29udGVudDpjb3VudGVyKHwpO1wiLFxuXHRcdFx0XCJjdDpjc1wiOiBcImNvbnRlbnQ6Y291bnRlcnMofCk7XCIsXG5cdFx0XHRcImNvaVwiOiBcImNvdW50ZXItaW5jcmVtZW50Onw7XCIsXG5cdFx0XHRcImNvclwiOiBcImNvdW50ZXItcmVzZXQ6fDtcIixcblx0XHRcdFwidmFcIjogXCJ2ZXJ0aWNhbC1hbGlnbjokezE6dG9wfTtcIixcblx0XHRcdFwidmE6c3VwXCI6IFwidmVydGljYWwtYWxpZ246c3VwZXI7XCIsXG5cdFx0XHRcInZhOnRcIjogXCJ2ZXJ0aWNhbC1hbGlnbjp0b3A7XCIsXG5cdFx0XHRcInZhOnR0XCI6IFwidmVydGljYWwtYWxpZ246dGV4dC10b3A7XCIsXG5cdFx0XHRcInZhOm1cIjogXCJ2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XCIsXG5cdFx0XHRcInZhOmJsXCI6IFwidmVydGljYWwtYWxpZ246YmFzZWxpbmU7XCIsXG5cdFx0XHRcInZhOmJcIjogXCJ2ZXJ0aWNhbC1hbGlnbjpib3R0b207XCIsXG5cdFx0XHRcInZhOnRiXCI6IFwidmVydGljYWwtYWxpZ246dGV4dC1ib3R0b207XCIsXG5cdFx0XHRcInZhOnN1YlwiOiBcInZlcnRpY2FsLWFsaWduOnN1YjtcIixcblx0XHRcdFwidGFcIjogXCJ0ZXh0LWFsaWduOiR7MTpsZWZ0fTtcIixcblx0XHRcdFwidGE6bFwiOiBcInRleHQtYWxpZ246bGVmdDtcIixcblx0XHRcdFwidGE6Y1wiOiBcInRleHQtYWxpZ246Y2VudGVyO1wiLFxuXHRcdFx0XCJ0YTpyXCI6IFwidGV4dC1hbGlnbjpyaWdodDtcIixcblx0XHRcdFwidGE6alwiOiBcInRleHQtYWxpZ246anVzdGlmeTtcIixcblx0XHRcdFwidGEtbHN0XCI6IFwidGV4dC1hbGlnbi1sYXN0Onw7XCIsXG5cdFx0XHRcInRhbDphXCI6IFwidGV4dC1hbGlnbi1sYXN0OmF1dG87XCIsXG5cdFx0XHRcInRhbDpsXCI6IFwidGV4dC1hbGlnbi1sYXN0OmxlZnQ7XCIsXG5cdFx0XHRcInRhbDpjXCI6IFwidGV4dC1hbGlnbi1sYXN0OmNlbnRlcjtcIixcblx0XHRcdFwidGFsOnJcIjogXCJ0ZXh0LWFsaWduLWxhc3Q6cmlnaHQ7XCIsXG5cdFx0XHRcInRkXCI6IFwidGV4dC1kZWNvcmF0aW9uOiR7MTpub25lfTtcIixcblx0XHRcdFwidGQ6blwiOiBcInRleHQtZGVjb3JhdGlvbjpub25lO1wiLFxuXHRcdFx0XCJ0ZDp1XCI6IFwidGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtcIixcblx0XHRcdFwidGQ6b1wiOiBcInRleHQtZGVjb3JhdGlvbjpvdmVybGluZTtcIixcblx0XHRcdFwidGQ6bFwiOiBcInRleHQtZGVjb3JhdGlvbjpsaW5lLXRocm91Z2g7XCIsXG5cdFx0XHRcInRlXCI6IFwidGV4dC1lbXBoYXNpczp8O1wiLFxuXHRcdFx0XCJ0ZTpuXCI6IFwidGV4dC1lbXBoYXNpczpub25lO1wiLFxuXHRcdFx0XCJ0ZTphY1wiOiBcInRleHQtZW1waGFzaXM6YWNjZW50O1wiLFxuXHRcdFx0XCJ0ZTpkdFwiOiBcInRleHQtZW1waGFzaXM6ZG90O1wiLFxuXHRcdFx0XCJ0ZTpjXCI6IFwidGV4dC1lbXBoYXNpczpjaXJjbGU7XCIsXG5cdFx0XHRcInRlOmRzXCI6IFwidGV4dC1lbXBoYXNpczpkaXNjO1wiLFxuXHRcdFx0XCJ0ZTpiXCI6IFwidGV4dC1lbXBoYXNpczpiZWZvcmU7XCIsXG5cdFx0XHRcInRlOmFcIjogXCJ0ZXh0LWVtcGhhc2lzOmFmdGVyO1wiLFxuXHRcdFx0XCJ0aFwiOiBcInRleHQtaGVpZ2h0Onw7XCIsXG5cdFx0XHRcInRoOmFcIjogXCJ0ZXh0LWhlaWdodDphdXRvO1wiLFxuXHRcdFx0XCJ0aDpmXCI6IFwidGV4dC1oZWlnaHQ6Zm9udC1zaXplO1wiLFxuXHRcdFx0XCJ0aDp0XCI6IFwidGV4dC1oZWlnaHQ6dGV4dC1zaXplO1wiLFxuXHRcdFx0XCJ0aDptXCI6IFwidGV4dC1oZWlnaHQ6bWF4LXNpemU7XCIsXG5cdFx0XHRcInRpXCI6IFwidGV4dC1pbmRlbnQ6fDtcIixcblx0XHRcdFwidGk6LVwiOiBcInRleHQtaW5kZW50Oi05OTk5cHg7XCIsXG5cdFx0XHRcInRqXCI6IFwidGV4dC1qdXN0aWZ5Onw7XCIsXG5cdFx0XHRcInRqOmFcIjogXCJ0ZXh0LWp1c3RpZnk6YXV0bztcIixcblx0XHRcdFwidGo6aXdcIjogXCJ0ZXh0LWp1c3RpZnk6aW50ZXItd29yZDtcIixcblx0XHRcdFwidGo6aWlcIjogXCJ0ZXh0LWp1c3RpZnk6aW50ZXItaWRlb2dyYXBoO1wiLFxuXHRcdFx0XCJ0ajppY1wiOiBcInRleHQtanVzdGlmeTppbnRlci1jbHVzdGVyO1wiLFxuXHRcdFx0XCJ0ajpkXCI6IFwidGV4dC1qdXN0aWZ5OmRpc3RyaWJ1dGU7XCIsXG5cdFx0XHRcInRqOmtcIjogXCJ0ZXh0LWp1c3RpZnk6a2FzaGlkYTtcIixcblx0XHRcdFwidGo6dFwiOiBcInRleHQtanVzdGlmeTp0aWJldGFuO1wiLFxuXHRcdFx0XCJ0b3ZcIjogXCJ0ZXh0LW92ZXJmbG93OiR7ZWxsaXBzaXN9O1wiLFxuXHRcdFx0XCJ0b3Y6ZVwiOiBcInRleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7XCIsXG5cdFx0XHRcInRvdjpjXCI6IFwidGV4dC1vdmVyZmxvdzpjbGlwO1wiLFxuXHRcdFx0XCJ0b1wiOiBcInRleHQtb3V0bGluZTp8O1wiLFxuXHRcdFx0XCJ0bytcIjogXCJ0ZXh0LW91dGxpbmU6JHsxOjB9ICR7MjowfSAkezM6IzAwMH07XCIsXG5cdFx0XHRcInRvOm5cIjogXCJ0ZXh0LW91dGxpbmU6bm9uZTtcIixcblx0XHRcdFwidHJcIjogXCJ0ZXh0LXJlcGxhY2U6fDtcIixcblx0XHRcdFwidHI6blwiOiBcInRleHQtcmVwbGFjZTpub25lO1wiLFxuXHRcdFx0XCJ0dFwiOiBcInRleHQtdHJhbnNmb3JtOiR7MTp1cHBlcmNhc2V9O1wiLFxuXHRcdFx0XCJ0dDpuXCI6IFwidGV4dC10cmFuc2Zvcm06bm9uZTtcIixcblx0XHRcdFwidHQ6Y1wiOiBcInRleHQtdHJhbnNmb3JtOmNhcGl0YWxpemU7XCIsXG5cdFx0XHRcInR0OnVcIjogXCJ0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2U7XCIsXG5cdFx0XHRcInR0OmxcIjogXCJ0ZXh0LXRyYW5zZm9ybTpsb3dlcmNhc2U7XCIsXG5cdFx0XHRcInR3XCI6IFwidGV4dC13cmFwOnw7XCIsXG5cdFx0XHRcInR3Om5cIjogXCJ0ZXh0LXdyYXA6bm9ybWFsO1wiLFxuXHRcdFx0XCJ0dzpub1wiOiBcInRleHQtd3JhcDpub25lO1wiLFxuXHRcdFx0XCJ0dzp1XCI6IFwidGV4dC13cmFwOnVucmVzdHJpY3RlZDtcIixcblx0XHRcdFwidHc6c1wiOiBcInRleHQtd3JhcDpzdXBwcmVzcztcIixcblx0XHRcdFwidHNoXCI6IFwidGV4dC1zaGFkb3c6JHsxOmhvZmZ9ICR7Mjp2b2ZmfSAkezM6Ymx1cn0gJHs0OiMwMDB9O1wiLFxuXHRcdFx0XCJ0c2g6clwiOiBcInRleHQtc2hhZG93OiR7MTpofSAkezI6dn0gJHszOmJsdXJ9IHJnYigkezQ6MH0sICR7NTowfSwgJHs2OjB9KTtcIixcblx0XHRcdFwidHNoOnJhXCI6IFwidGV4dC1zaGFkb3c6JHsxOmh9ICR7Mjp2fSAkezM6Ymx1cn0gcmdiYSgkezQ6MH0sICR7NTowfSwgJHs2OjB9LCAuJHs3OjV9KTtcIixcblx0XHRcdFwidHNoK1wiOiBcInRleHQtc2hhZG93OiR7MTowfSAkezI6MH0gJHszOjB9ICR7NDojMDAwfTtcIixcblx0XHRcdFwidHNoOm5cIjogXCJ0ZXh0LXNoYWRvdzpub25lO1wiLFxuXHRcdFx0XCJ0cmZcIjogXCJ0cmFuc2Zvcm06fDtcIixcblx0XHRcdFwidHJmOnNreFwiOiBcInRyYW5zZm9ybTogc2tld1goJHsxOmFuZ2xlfSk7XCIsXG5cdFx0XHRcInRyZjpza3lcIjogXCJ0cmFuc2Zvcm06IHNrZXdZKCR7MTphbmdsZX0pO1wiLFxuXHRcdFx0XCJ0cmY6c2NcIjogXCJ0cmFuc2Zvcm06IHNjYWxlKCR7MTp4fSwgJHsyOnl9KTtcIixcblx0XHRcdFwidHJmOnNjeFwiOiBcInRyYW5zZm9ybTogc2NhbGVYKCR7MTp4fSk7XCIsXG5cdFx0XHRcInRyZjpzY3lcIjogXCJ0cmFuc2Zvcm06IHNjYWxlWSgkezE6eX0pO1wiLFxuXHRcdFx0XCJ0cmY6clwiOiBcInRyYW5zZm9ybTogcm90YXRlKCR7MTphbmdsZX0pO1wiLFxuXHRcdFx0XCJ0cmY6dFwiOiBcInRyYW5zZm9ybTogdHJhbnNsYXRlKCR7MTp4fSwgJHsyOnl9KTtcIixcblx0XHRcdFwidHJmOnR4XCI6IFwidHJhbnNmb3JtOiB0cmFuc2xhdGVYKCR7MTp4fSk7XCIsXG5cdFx0XHRcInRyZjp0eVwiOiBcInRyYW5zZm9ybTogdHJhbnNsYXRlWSgkezE6eX0pO1wiLFxuXHRcdFx0XCJ0cmZvXCI6IFwidHJhbnNmb3JtLW9yaWdpbjp8O1wiLFxuXHRcdFx0XCJ0cmZzXCI6IFwidHJhbnNmb3JtLXN0eWxlOiR7MTpwcmVzZXJ2ZS0zZH07XCIsXG5cdFx0XHRcInRyc1wiOiBcInRyYW5zaXRpb246JHsxOnByb3B9ICR7Mjp0aW1lfTtcIixcblx0XHRcdFwidHJzZGVcIjogXCJ0cmFuc2l0aW9uLWRlbGF5OiR7MTp0aW1lfTtcIixcblx0XHRcdFwidHJzZHVcIjogXCJ0cmFuc2l0aW9uLWR1cmF0aW9uOiR7MTp0aW1lfTtcIixcblx0XHRcdFwidHJzcFwiOiBcInRyYW5zaXRpb24tcHJvcGVydHk6JHsxOnByb3B9O1wiLFxuXHRcdFx0XCJ0cnN0ZlwiOiBcInRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiR7MTp0ZnVuY307XCIsXG5cdFx0XHRcImxoXCI6IFwibGluZS1oZWlnaHQ6fDtcIixcblx0XHRcdFwid2hzXCI6IFwid2hpdGUtc3BhY2U6fDtcIixcblx0XHRcdFwid2hzOm5cIjogXCJ3aGl0ZS1zcGFjZTpub3JtYWw7XCIsXG5cdFx0XHRcIndoczpwXCI6IFwid2hpdGUtc3BhY2U6cHJlO1wiLFxuXHRcdFx0XCJ3aHM6bndcIjogXCJ3aGl0ZS1zcGFjZTpub3dyYXA7XCIsXG5cdFx0XHRcIndoczpwd1wiOiBcIndoaXRlLXNwYWNlOnByZS13cmFwO1wiLFxuXHRcdFx0XCJ3aHM6cGxcIjogXCJ3aGl0ZS1zcGFjZTpwcmUtbGluZTtcIixcblx0XHRcdFwid2hzY1wiOiBcIndoaXRlLXNwYWNlLWNvbGxhcHNlOnw7XCIsXG5cdFx0XHRcIndoc2M6blwiOiBcIndoaXRlLXNwYWNlLWNvbGxhcHNlOm5vcm1hbDtcIixcblx0XHRcdFwid2hzYzprXCI6IFwid2hpdGUtc3BhY2UtY29sbGFwc2U6a2VlcC1hbGw7XCIsXG5cdFx0XHRcIndoc2M6bFwiOiBcIndoaXRlLXNwYWNlLWNvbGxhcHNlOmxvb3NlO1wiLFxuXHRcdFx0XCJ3aHNjOmJzXCI6IFwid2hpdGUtc3BhY2UtY29sbGFwc2U6YnJlYWstc3RyaWN0O1wiLFxuXHRcdFx0XCJ3aHNjOmJhXCI6IFwid2hpdGUtc3BhY2UtY29sbGFwc2U6YnJlYWstYWxsO1wiLFxuXHRcdFx0XCJ3b2JcIjogXCJ3b3JkLWJyZWFrOnw7XCIsXG5cdFx0XHRcIndvYjpuXCI6IFwid29yZC1icmVhazpub3JtYWw7XCIsXG5cdFx0XHRcIndvYjprXCI6IFwid29yZC1icmVhazprZWVwLWFsbDtcIixcblx0XHRcdFwid29iOmJhXCI6IFwid29yZC1icmVhazpicmVhay1hbGw7XCIsXG5cdFx0XHRcIndvc1wiOiBcIndvcmQtc3BhY2luZzp8O1wiLFxuXHRcdFx0XCJ3b3dcIjogXCJ3b3JkLXdyYXA6fDtcIixcblx0XHRcdFwid293Om5tXCI6IFwid29yZC13cmFwOm5vcm1hbDtcIixcblx0XHRcdFwid293Om5cIjogXCJ3b3JkLXdyYXA6bm9uZTtcIixcblx0XHRcdFwid293OnVcIjogXCJ3b3JkLXdyYXA6dW5yZXN0cmljdGVkO1wiLFxuXHRcdFx0XCJ3b3c6c1wiOiBcIndvcmQtd3JhcDpzdXBwcmVzcztcIixcblx0XHRcdFwid293OmJcIjogXCJ3b3JkLXdyYXA6YnJlYWstd29yZDtcIixcblx0XHRcdFwid21cIjogXCJ3cml0aW5nLW1vZGU6JHsxOmxyLXRifTtcIixcblx0XHRcdFwid206bHJ0XCI6IFwid3JpdGluZy1tb2RlOmxyLXRiO1wiLFxuXHRcdFx0XCJ3bTpscmJcIjogXCJ3cml0aW5nLW1vZGU6bHItYnQ7XCIsXG5cdFx0XHRcIndtOnJsdFwiOiBcIndyaXRpbmctbW9kZTpybC10YjtcIixcblx0XHRcdFwid206cmxiXCI6IFwid3JpdGluZy1tb2RlOnJsLWJ0O1wiLFxuXHRcdFx0XCJ3bTp0YnJcIjogXCJ3cml0aW5nLW1vZGU6dGItcmw7XCIsXG5cdFx0XHRcIndtOnRibFwiOiBcIndyaXRpbmctbW9kZTp0Yi1scjtcIixcblx0XHRcdFwid206YnRsXCI6IFwid3JpdGluZy1tb2RlOmJ0LWxyO1wiLFxuXHRcdFx0XCJ3bTpidHJcIjogXCJ3cml0aW5nLW1vZGU6YnQtcmw7XCIsXG5cdFx0XHRcImx0c1wiOiBcImxldHRlci1zcGFjaW5nOnw7XCIsXG5cdFx0XHRcImx0cy1uXCI6IFwibGV0dGVyLXNwYWNpbmc6bm9ybWFsO1wiLFxuXHRcdFx0XCJmXCI6IFwiZm9udDp8O1wiLFxuXHRcdFx0XCJmK1wiOiBcImZvbnQ6JHsxOjFlbX0gJHsyOkFyaWFsLHNhbnMtc2VyaWZ9O1wiLFxuXHRcdFx0XCJmd1wiOiBcImZvbnQtd2VpZ2h0Onw7XCIsXG5cdFx0XHRcImZ3Om5cIjogXCJmb250LXdlaWdodDpub3JtYWw7XCIsXG5cdFx0XHRcImZ3OmJcIjogXCJmb250LXdlaWdodDpib2xkO1wiLFxuXHRcdFx0XCJmdzpiclwiOiBcImZvbnQtd2VpZ2h0OmJvbGRlcjtcIixcblx0XHRcdFwiZnc6bHJcIjogXCJmb250LXdlaWdodDpsaWdodGVyO1wiLFxuXHRcdFx0XCJmc1wiOiBcImZvbnQtc3R5bGU6JHtpdGFsaWN9O1wiLFxuXHRcdFx0XCJmczpuXCI6IFwiZm9udC1zdHlsZTpub3JtYWw7XCIsXG5cdFx0XHRcImZzOmlcIjogXCJmb250LXN0eWxlOml0YWxpYztcIixcblx0XHRcdFwiZnM6b1wiOiBcImZvbnQtc3R5bGU6b2JsaXF1ZTtcIixcblx0XHRcdFwiZnZcIjogXCJmb250LXZhcmlhbnQ6fDtcIixcblx0XHRcdFwiZnY6blwiOiBcImZvbnQtdmFyaWFudDpub3JtYWw7XCIsXG5cdFx0XHRcImZ2OnNjXCI6IFwiZm9udC12YXJpYW50OnNtYWxsLWNhcHM7XCIsXG5cdFx0XHRcImZ6XCI6IFwiZm9udC1zaXplOnw7XCIsXG5cdFx0XHRcImZ6YVwiOiBcImZvbnQtc2l6ZS1hZGp1c3Q6fDtcIixcblx0XHRcdFwiZnphOm5cIjogXCJmb250LXNpemUtYWRqdXN0Om5vbmU7XCIsXG5cdFx0XHRcImZmXCI6IFwiZm9udC1mYW1pbHk6fDtcIixcblx0XHRcdFwiZmY6c1wiOiBcImZvbnQtZmFtaWx5OnNlcmlmO1wiLFxuXHRcdFx0XCJmZjpzc1wiOiBcImZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7XCIsXG5cdFx0XHRcImZmOmNcIjogXCJmb250LWZhbWlseTpjdXJzaXZlO1wiLFxuXHRcdFx0XCJmZjpmXCI6IFwiZm9udC1mYW1pbHk6ZmFudGFzeTtcIixcblx0XHRcdFwiZmY6bVwiOiBcImZvbnQtZmFtaWx5Om1vbm9zcGFjZTtcIixcblx0XHRcdFwiZmY6YVwiOiBcImZvbnQtZmFtaWx5OiBBcmlhbCwgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1wiLFxuXHRcdFx0XCJmZjp0XCI6IFwiZm9udC1mYW1pbHk6IFxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiLCBUaW1lcywgQmFza2VydmlsbGUsIEdlb3JnaWEsIHNlcmlmO1wiLFxuXHRcdFx0XCJmZjp2XCI6IFwiZm9udC1mYW1pbHk6IFZlcmRhbmEsIEdlbmV2YSwgc2Fucy1zZXJpZjtcIixcblx0XHRcdFwiZmVmXCI6IFwiZm9udC1lZmZlY3Q6fDtcIixcblx0XHRcdFwiZmVmOm5cIjogXCJmb250LWVmZmVjdDpub25lO1wiLFxuXHRcdFx0XCJmZWY6ZWdcIjogXCJmb250LWVmZmVjdDplbmdyYXZlO1wiLFxuXHRcdFx0XCJmZWY6ZWJcIjogXCJmb250LWVmZmVjdDplbWJvc3M7XCIsXG5cdFx0XHRcImZlZjpvXCI6IFwiZm9udC1lZmZlY3Q6b3V0bGluZTtcIixcblx0XHRcdFwiZmVtXCI6IFwiZm9udC1lbXBoYXNpemU6fDtcIixcblx0XHRcdFwiZmVtcFwiOiBcImZvbnQtZW1waGFzaXplLXBvc2l0aW9uOnw7XCIsXG5cdFx0XHRcImZlbXA6YlwiOiBcImZvbnQtZW1waGFzaXplLXBvc2l0aW9uOmJlZm9yZTtcIixcblx0XHRcdFwiZmVtcDphXCI6IFwiZm9udC1lbXBoYXNpemUtcG9zaXRpb246YWZ0ZXI7XCIsXG5cdFx0XHRcImZlbXNcIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTp8O1wiLFxuXHRcdFx0XCJmZW1zOm5cIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTpub25lO1wiLFxuXHRcdFx0XCJmZW1zOmFjXCI6IFwiZm9udC1lbXBoYXNpemUtc3R5bGU6YWNjZW50O1wiLFxuXHRcdFx0XCJmZW1zOmR0XCI6IFwiZm9udC1lbXBoYXNpemUtc3R5bGU6ZG90O1wiLFxuXHRcdFx0XCJmZW1zOmNcIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTpjaXJjbGU7XCIsXG5cdFx0XHRcImZlbXM6ZHNcIjogXCJmb250LWVtcGhhc2l6ZS1zdHlsZTpkaXNjO1wiLFxuXHRcdFx0XCJmc21cIjogXCJmb250LXNtb290aDp8O1wiLFxuXHRcdFx0XCJmc206YVwiOiBcImZvbnQtc21vb3RoOmF1dG87XCIsXG5cdFx0XHRcImZzbTpuXCI6IFwiZm9udC1zbW9vdGg6bmV2ZXI7XCIsXG5cdFx0XHRcImZzbTphd1wiOiBcImZvbnQtc21vb3RoOmFsd2F5cztcIixcblx0XHRcdFwiZnN0XCI6IFwiZm9udC1zdHJldGNoOnw7XCIsXG5cdFx0XHRcImZzdDpuXCI6IFwiZm9udC1zdHJldGNoOm5vcm1hbDtcIixcblx0XHRcdFwiZnN0OnVjXCI6IFwiZm9udC1zdHJldGNoOnVsdHJhLWNvbmRlbnNlZDtcIixcblx0XHRcdFwiZnN0OmVjXCI6IFwiZm9udC1zdHJldGNoOmV4dHJhLWNvbmRlbnNlZDtcIixcblx0XHRcdFwiZnN0OmNcIjogXCJmb250LXN0cmV0Y2g6Y29uZGVuc2VkO1wiLFxuXHRcdFx0XCJmc3Q6c2NcIjogXCJmb250LXN0cmV0Y2g6c2VtaS1jb25kZW5zZWQ7XCIsXG5cdFx0XHRcImZzdDpzZVwiOiBcImZvbnQtc3RyZXRjaDpzZW1pLWV4cGFuZGVkO1wiLFxuXHRcdFx0XCJmc3Q6ZVwiOiBcImZvbnQtc3RyZXRjaDpleHBhbmRlZDtcIixcblx0XHRcdFwiZnN0OmVlXCI6IFwiZm9udC1zdHJldGNoOmV4dHJhLWV4cGFuZGVkO1wiLFxuXHRcdFx0XCJmc3Q6dWVcIjogXCJmb250LXN0cmV0Y2g6dWx0cmEtZXhwYW5kZWQ7XCIsXG5cdFx0XHRcIm9wXCI6IFwib3BhY2l0eTp8O1wiLFxuXHRcdFx0XCJvcCtcIjogXCJvcGFjaXR5OiAkMTtcXG5maWx0ZXI6IGFscGhhKG9wYWNpdHk9JDIpO1wiLFxuXHRcdFx0XCJvcDppZVwiOiBcImZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0xMDApO1wiLFxuXHRcdFx0XCJvcDptc1wiOiBcIi1tcy1maWx0ZXI6J3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTEwMCknO1wiLFxuXHRcdFx0XCJyc3pcIjogXCJyZXNpemU6fDtcIixcblx0XHRcdFwicnN6Om5cIjogXCJyZXNpemU6bm9uZTtcIixcblx0XHRcdFwicnN6OmJcIjogXCJyZXNpemU6Ym90aDtcIixcblx0XHRcdFwicnN6OmhcIjogXCJyZXNpemU6aG9yaXpvbnRhbDtcIixcblx0XHRcdFwicnN6OnZcIjogXCJyZXNpemU6dmVydGljYWw7XCIsXG5cdFx0XHRcImN1clwiOiBcImN1cnNvcjoke3BvaW50ZXJ9O1wiLFxuXHRcdFx0XCJjdXI6YVwiOiBcImN1cnNvcjphdXRvO1wiLFxuXHRcdFx0XCJjdXI6ZFwiOiBcImN1cnNvcjpkZWZhdWx0O1wiLFxuXHRcdFx0XCJjdXI6Y1wiOiBcImN1cnNvcjpjcm9zc2hhaXI7XCIsXG5cdFx0XHRcImN1cjpoYVwiOiBcImN1cnNvcjpoYW5kO1wiLFxuXHRcdFx0XCJjdXI6aGVcIjogXCJjdXJzb3I6aGVscDtcIixcblx0XHRcdFwiY3VyOm1cIjogXCJjdXJzb3I6bW92ZTtcIixcblx0XHRcdFwiY3VyOnBcIjogXCJjdXJzb3I6cG9pbnRlcjtcIixcblx0XHRcdFwiY3VyOnRcIjogXCJjdXJzb3I6dGV4dDtcIixcblx0XHRcdFwicGdiYlwiOiBcInBhZ2UtYnJlYWstYmVmb3JlOnw7XCIsXG5cdFx0XHRcInBnYmI6YXVcIjogXCJwYWdlLWJyZWFrLWJlZm9yZTphdXRvO1wiLFxuXHRcdFx0XCJwZ2JiOmFsXCI6IFwicGFnZS1icmVhay1iZWZvcmU6YWx3YXlzO1wiLFxuXHRcdFx0XCJwZ2JiOmxcIjogXCJwYWdlLWJyZWFrLWJlZm9yZTpsZWZ0O1wiLFxuXHRcdFx0XCJwZ2JiOnJcIjogXCJwYWdlLWJyZWFrLWJlZm9yZTpyaWdodDtcIixcblx0XHRcdFwicGdiaVwiOiBcInBhZ2UtYnJlYWstaW5zaWRlOnw7XCIsXG5cdFx0XHRcInBnYmk6YXVcIjogXCJwYWdlLWJyZWFrLWluc2lkZTphdXRvO1wiLFxuXHRcdFx0XCJwZ2JpOmF2XCI6IFwicGFnZS1icmVhay1pbnNpZGU6YXZvaWQ7XCIsXG5cdFx0XHRcInBnYmFcIjogXCJwYWdlLWJyZWFrLWFmdGVyOnw7XCIsXG5cdFx0XHRcInBnYmE6YXVcIjogXCJwYWdlLWJyZWFrLWFmdGVyOmF1dG87XCIsXG5cdFx0XHRcInBnYmE6YWxcIjogXCJwYWdlLWJyZWFrLWFmdGVyOmFsd2F5cztcIixcblx0XHRcdFwicGdiYTpsXCI6IFwicGFnZS1icmVhay1hZnRlcjpsZWZ0O1wiLFxuXHRcdFx0XCJwZ2JhOnJcIjogXCJwYWdlLWJyZWFrLWFmdGVyOnJpZ2h0O1wiLFxuXHRcdFx0XCJvcnBcIjogXCJvcnBoYW5zOnw7XCIsXG5cdFx0XHRcInVzXCI6IFwidXNlci1zZWxlY3Q6JHtub25lfTtcIixcblx0XHRcdFwid2lkXCI6IFwid2lkb3dzOnw7XCIsXG5cdFx0XHRcIndmc21cIjogXCItd2Via2l0LWZvbnQtc21vb3RoaW5nOiR7YW50aWFsaWFzZWR9O1wiLFxuXHRcdFx0XCJ3ZnNtOmFcIjogXCItd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkO1wiLFxuXHRcdFx0XCJ3ZnNtOnNcIjogXCItd2Via2l0LWZvbnQtc21vb3RoaW5nOnN1YnBpeGVsLWFudGlhbGlhc2VkO1wiLFxuXHRcdFx0XCJ3ZnNtOnNhXCI6IFwiLXdlYmtpdC1mb250LXNtb290aGluZzpzdWJwaXhlbC1hbnRpYWxpYXNlZDtcIixcblx0XHRcdFwid2ZzbTpuXCI6IFwiLXdlYmtpdC1mb250LXNtb290aGluZzpub25lO1wiXG5cdFx0fVxuXHR9LFxuXHRcblx0XCJodG1sXCI6IHtcblx0XHRcImZpbHRlcnNcIjogXCJodG1sXCIsXG5cdFx0XCJwcm9maWxlXCI6IFwiaHRtbFwiLFxuXHRcdFwic25pcHBldHNcIjoge1xuXHRcdFx0XCIhISFcIjogICAgXCI8IWRvY3R5cGUgaHRtbD5cIixcblx0XHRcdFwiISEhNHRcIjogIFwiPCFET0NUWVBFIEhUTUwgUFVCTElDIFxcXCItLy9XM0MvL0RURCBIVE1MIDQuMDEgVHJhbnNpdGlvbmFsLy9FTlxcXCIgXFxcImh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0L2xvb3NlLmR0ZFxcXCI+XCIsXG5cdFx0XHRcIiEhITRzXCI6ICBcIjwhRE9DVFlQRSBIVE1MIFBVQkxJQyBcXFwiLS8vVzNDLy9EVEQgSFRNTCA0LjAxLy9FTlxcXCIgXFxcImh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0L3N0cmljdC5kdGRcXFwiPlwiLFxuXHRcdFx0XCIhISF4dFwiOiAgXCI8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXFxcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBUcmFuc2l0aW9uYWwvL0VOXFxcIiBcXFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtdHJhbnNpdGlvbmFsLmR0ZFxcXCI+XCIsXG5cdFx0XHRcIiEhIXhzXCI6ICBcIjwhRE9DVFlQRSBodG1sIFBVQkxJQyBcXFwiLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5cXFwiIFxcXCJodHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkXFxcIj5cIixcblx0XHRcdFwiISEheHhzXCI6IFwiPCFET0NUWVBFIGh0bWwgUFVCTElDIFxcXCItLy9XM0MvL0RURCBYSFRNTCAxLjEvL0VOXFxcIiBcXFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxMS9EVEQveGh0bWwxMS5kdGRcXFwiPlwiLFxuXG5cdFx0XHRcImNcIjogXCI8IS0tIHwke2NoaWxkfSAtLT5cIixcblx0XHRcdFwiY2M6aWU2XCI6IFwiPCEtLVtpZiBsdGUgSUUgNl0+XFxuXFx0JHtjaGlsZH18XFxuPCFbZW5kaWZdLS0+XCIsXG5cdFx0XHRcImNjOmllXCI6IFwiPCEtLVtpZiBJRV0+XFxuXFx0JHtjaGlsZH18XFxuPCFbZW5kaWZdLS0+XCIsXG5cdFx0XHRcImNjOm5vaWVcIjogXCI8IS0tW2lmICFJRV0+PCEtLT5cXG5cXHQke2NoaWxkfXxcXG48IS0tPCFbZW5kaWZdLS0+XCJcblx0XHR9LFxuXHRcdFxuXHRcdFwiYWJicmV2aWF0aW9uc1wiOiB7XG5cdFx0XHRcIiFcIjogXCJodG1sOjVcIixcblx0XHRcdFwiYVwiOiBcIjxhIGhyZWY9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImE6bGlua1wiOiBcIjxhIGhyZWY9XFxcImh0dHA6Ly98XFxcIj5cIixcblx0XHRcdFwiYTptYWlsXCI6IFwiPGEgaHJlZj1cXFwibWFpbHRvOnxcXFwiPlwiLFxuXHRcdFx0XCJhYmJyXCI6IFwiPGFiYnIgdGl0bGU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImFjcm9ueW1cIjogXCI8YWNyb255bSB0aXRsZT1cXFwiXFxcIj5cIixcblx0XHRcdFwiYmFzZVwiOiBcIjxiYXNlIGhyZWY9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwiYmFzZWZvbnRcIjogXCI8YmFzZWZvbnQvPlwiLFxuXHRcdFx0XCJiclwiOiBcIjxici8+XCIsXG5cdFx0XHRcImZyYW1lXCI6IFwiPGZyYW1lLz5cIixcblx0XHRcdFwiaHJcIjogXCI8aHIvPlwiLFxuXHRcdFx0XCJiZG9cIjogXCI8YmRvIGRpcj1cXFwiXFxcIj5cIixcblx0XHRcdFwiYmRvOnJcIjogXCI8YmRvIGRpcj1cXFwicnRsXFxcIj5cIixcblx0XHRcdFwiYmRvOmxcIjogXCI8YmRvIGRpcj1cXFwibHRyXFxcIj5cIixcblx0XHRcdFwiY29sXCI6IFwiPGNvbC8+XCIsXG5cdFx0XHRcImxpbmtcIjogXCI8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwibGluazpjc3NcIjogXCI8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcIiR7MTpzdHlsZX0uY3NzXFxcIiAvPlwiLFxuXHRcdFx0XCJsaW5rOnByaW50XCI6IFwiPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCIkezE6cHJpbnR9LmNzc1xcXCIgbWVkaWE9XFxcInByaW50XFxcIiAvPlwiLFxuXHRcdFx0XCJsaW5rOmZhdmljb25cIjogXCI8bGluayByZWw9XFxcInNob3J0Y3V0IGljb25cXFwiIHR5cGU9XFxcImltYWdlL3gtaWNvblxcXCIgaHJlZj1cXFwiJHsxOmZhdmljb24uaWNvfVxcXCIgLz5cIixcblx0XHRcdFwibGluazp0b3VjaFwiOiBcIjxsaW5rIHJlbD1cXFwiYXBwbGUtdG91Y2gtaWNvblxcXCIgaHJlZj1cXFwiJHsxOmZhdmljb24ucG5nfVxcXCIgLz5cIixcblx0XHRcdFwibGluazpyc3NcIjogXCI8bGluayByZWw9XFxcImFsdGVybmF0ZVxcXCIgdHlwZT1cXFwiYXBwbGljYXRpb24vcnNzK3htbFxcXCIgdGl0bGU9XFxcIlJTU1xcXCIgaHJlZj1cXFwiJHsxOnJzcy54bWx9XFxcIiAvPlwiLFxuXHRcdFx0XCJsaW5rOmF0b21cIjogXCI8bGluayByZWw9XFxcImFsdGVybmF0ZVxcXCIgdHlwZT1cXFwiYXBwbGljYXRpb24vYXRvbSt4bWxcXFwiIHRpdGxlPVxcXCJBdG9tXFxcIiBocmVmPVxcXCIkezE6YXRvbS54bWx9XFxcIiAvPlwiLFxuXHRcdFx0XCJtZXRhXCI6IFwiPG1ldGEvPlwiLFxuXHRcdFx0XCJtZXRhOnV0ZlwiOiBcIjxtZXRhIGh0dHAtZXF1aXY9XFxcIkNvbnRlbnQtVHlwZVxcXCIgY29udGVudD1cXFwidGV4dC9odG1sO2NoYXJzZXQ9VVRGLThcXFwiIC8+XCIsXG5cdFx0XHRcIm1ldGE6d2luXCI6IFwiPG1ldGEgaHR0cC1lcXVpdj1cXFwiQ29udGVudC1UeXBlXFxcIiBjb250ZW50PVxcXCJ0ZXh0L2h0bWw7Y2hhcnNldD13aW5kb3dzLTEyNTFcXFwiIC8+XCIsXG5cdFx0XHRcIm1ldGE6dnBcIjogXCI8bWV0YSBuYW1lPVxcXCJ2aWV3cG9ydFxcXCIgY29udGVudD1cXFwid2lkdGg9JHsxOmRldmljZS13aWR0aH0sIHVzZXItc2NhbGFibGU9JHsyOm5vfSwgaW5pdGlhbC1zY2FsZT0kezM6MS4wfSwgbWF4aW11bS1zY2FsZT0kezQ6MS4wfSwgbWluaW11bS1zY2FsZT0kezU6MS4wfVxcXCIgLz5cIixcblx0XHRcdFwibWV0YTpjb21wYXRcIjogXCI8bWV0YSBodHRwLWVxdWl2PVxcXCJYLVVBLUNvbXBhdGlibGVcXFwiIGNvbnRlbnQ9XFxcIiR7MTpJRT03fVxcXCIgLz5cIixcblx0XHRcdFwic3R5bGVcIjogXCI8c3R5bGU+XCIsXG5cdFx0XHRcInNjcmlwdFwiOiBcIjxzY3JpcHQ+XCIsXG5cdFx0XHRcInNjcmlwdDpzcmNcIjogXCI8c2NyaXB0IHNyYz1cXFwiXFxcIj5cIixcblx0XHRcdFwiaW1nXCI6IFwiPGltZyBzcmM9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImlmcmFtZVwiOiBcIjxpZnJhbWUgc3JjPVxcXCJcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIj5cIixcblx0XHRcdFwiZW1iZWRcIjogXCI8ZW1iZWQgc3JjPVxcXCJcXFwiIHR5cGU9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwib2JqZWN0XCI6IFwiPG9iamVjdCBkYXRhPVxcXCJcXFwiIHR5cGU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInBhcmFtXCI6IFwiPHBhcmFtIG5hbWU9XFxcIlxcXCIgdmFsdWU9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwibWFwXCI6IFwiPG1hcCBuYW1lPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJhcmVhXCI6IFwiPGFyZWEgc2hhcGU9XFxcIlxcXCIgY29vcmRzPVxcXCJcXFwiIGhyZWY9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImFyZWE6ZFwiOiBcIjxhcmVhIHNoYXBlPVxcXCJkZWZhdWx0XFxcIiBocmVmPVxcXCJcXFwiIGFsdD1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJhcmVhOmNcIjogXCI8YXJlYSBzaGFwZT1cXFwiY2lyY2xlXFxcIiBjb29yZHM9XFxcIlxcXCIgaHJlZj1cXFwiXFxcIiBhbHQ9XFxcIlxcXCIgLz5cIixcblx0XHRcdFwiYXJlYTpyXCI6IFwiPGFyZWEgc2hhcGU9XFxcInJlY3RcXFwiIGNvb3Jkcz1cXFwiXFxcIiBocmVmPVxcXCJcXFwiIGFsdD1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJhcmVhOnBcIjogXCI8YXJlYSBzaGFwZT1cXFwicG9seVxcXCIgY29vcmRzPVxcXCJcXFwiIGhyZWY9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImZvcm1cIjogXCI8Zm9ybSBhY3Rpb249XFxcIlxcXCI+XCIsXG5cdFx0XHRcImZvcm06Z2V0XCI6IFwiPGZvcm0gYWN0aW9uPVxcXCJcXFwiIG1ldGhvZD1cXFwiZ2V0XFxcIj5cIixcblx0XHRcdFwiZm9ybTpwb3N0XCI6IFwiPGZvcm0gYWN0aW9uPVxcXCJcXFwiIG1ldGhvZD1cXFwicG9zdFxcXCI+XCIsXG5cdFx0XHRcImxhYmVsXCI6IFwiPGxhYmVsIGZvcj1cXFwiXFxcIj5cIixcblx0XHRcdFwiaW5wdXRcIjogXCI8aW5wdXQgdHlwZT1cXFwiJHsxOnRleHR9XFxcIiAvPlwiLFxuXHRcdFx0XCJpbnBcIjogXCI8aW5wdXQgdHlwZT1cXFwiJHsxOnRleHR9XFxcIiBuYW1lPVxcXCJcXFwiIGlkPVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImlucHV0OmhpZGRlblwiOiBcImlucHV0W3R5cGU9aGlkZGVuIG5hbWVdXCIsXG5cdFx0XHRcImlucHV0OmhcIjogXCJpbnB1dDpoaWRkZW5cIixcblx0XHRcdFwiaW5wdXQ6dGV4dFwiOiBcImlucFwiLFxuXHRcdFx0XCJpbnB1dDp0XCI6IFwiaW5wXCIsXG5cdFx0XHRcImlucHV0OnNlYXJjaFwiOiBcImlucFt0eXBlPXNlYXJjaF1cIixcblx0XHRcdFwiaW5wdXQ6ZW1haWxcIjogXCJpbnBbdHlwZT1lbWFpbF1cIixcblx0XHRcdFwiaW5wdXQ6dXJsXCI6IFwiaW5wW3R5cGU9dXJsXVwiLFxuXHRcdFx0XCJpbnB1dDpwYXNzd29yZFwiOiBcImlucFt0eXBlPXBhc3N3b3JkXVwiLFxuXHRcdFx0XCJpbnB1dDpwXCI6IFwiaW5wdXQ6cGFzc3dvcmRcIixcblx0XHRcdFwiaW5wdXQ6ZGF0ZXRpbWVcIjogXCJpbnBbdHlwZT1kYXRldGltZV1cIixcblx0XHRcdFwiaW5wdXQ6ZGF0ZVwiOiBcImlucFt0eXBlPWRhdGVdXCIsXG5cdFx0XHRcImlucHV0OmRhdGV0aW1lLWxvY2FsXCI6IFwiaW5wW3R5cGU9ZGF0ZXRpbWUtbG9jYWxdXCIsXG5cdFx0XHRcImlucHV0Om1vbnRoXCI6IFwiaW5wW3R5cGU9bW9udGhdXCIsXG5cdFx0XHRcImlucHV0OndlZWtcIjogXCJpbnBbdHlwZT13ZWVrXVwiLFxuXHRcdFx0XCJpbnB1dDp0aW1lXCI6IFwiaW5wW3R5cGU9dGltZV1cIixcblx0XHRcdFwiaW5wdXQ6bnVtYmVyXCI6IFwiaW5wW3R5cGU9bnVtYmVyXVwiLFxuXHRcdFx0XCJpbnB1dDpjb2xvclwiOiBcImlucFt0eXBlPWNvbG9yXVwiLFxuXHRcdFx0XCJpbnB1dDpjaGVja2JveFwiOiBcImlucFt0eXBlPWNoZWNrYm94XVwiLFxuXHRcdFx0XCJpbnB1dDpjXCI6IFwiaW5wdXQ6Y2hlY2tib3hcIixcblx0XHRcdFwiaW5wdXQ6cmFkaW9cIjogXCJpbnBbdHlwZT1yYWRpb11cIixcblx0XHRcdFwiaW5wdXQ6clwiOiBcImlucHV0OnJhZGlvXCIsXG5cdFx0XHRcImlucHV0OnJhbmdlXCI6IFwiaW5wW3R5cGU9cmFuZ2VdXCIsXG5cdFx0XHRcImlucHV0OmZpbGVcIjogXCJpbnBbdHlwZT1maWxlXVwiLFxuXHRcdFx0XCJpbnB1dDpmXCI6IFwiaW5wdXQ6ZmlsZVwiLFxuXHRcdFx0XCJpbnB1dDpzdWJtaXRcIjogXCI8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIiB2YWx1ZT1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJpbnB1dDpzXCI6IFwiaW5wdXQ6c3VibWl0XCIsXG5cdFx0XHRcImlucHV0OmltYWdlXCI6IFwiPGlucHV0IHR5cGU9XFxcImltYWdlXFxcIiBzcmM9XFxcIlxcXCIgYWx0PVxcXCJcXFwiIC8+XCIsXG5cdFx0XHRcImlucHV0OmlcIjogXCJpbnB1dDppbWFnZVwiLFxuXHRcdFx0XCJpbnB1dDpidXR0b25cIjogXCI8aW5wdXQgdHlwZT1cXFwiYnV0dG9uXFxcIiB2YWx1ZT1cXFwiXFxcIiAvPlwiLFxuXHRcdFx0XCJpbnB1dDpiXCI6IFwiaW5wdXQ6YnV0dG9uXCIsXG5cdFx0XHRcImlzaW5kZXhcIjogXCI8aXNpbmRleC8+XCIsXG5cdFx0XHRcImlucHV0OnJlc2V0XCI6IFwiaW5wdXQ6YnV0dG9uW3R5cGU9cmVzZXRdXCIsXG5cdFx0XHRcInNlbGVjdFwiOiBcIjxzZWxlY3QgbmFtZT1cXFwiXFxcIiBpZD1cXFwiXFxcIj5cIixcblx0XHRcdFwic2VsZWN0OmRpc2FibGVkXCI6IFwic2VsZWN0W2Rpc2FibGVkXVwiLFxuXHRcdFx0XCJzZWxlY3Q6ZFwiOiBcInNlbGVjdFtkaXNhYmxlZF1cIixcblx0XHRcdFwib3B0aW9uXCI6IFwiPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj5cIixcblx0XHRcdFwidGV4dGFyZWFcIjogXCI8dGV4dGFyZWEgbmFtZT1cXFwiXFxcIiBpZD1cXFwiXFxcIiBjb2xzPVxcXCIkezE6MzB9XFxcIiByb3dzPVxcXCIkezI6MTB9XFxcIj5cIixcblx0XHRcdFwibWFycXVlZVwiOiBcIjxtYXJxdWVlIGJlaGF2aW9yPVxcXCJcXFwiIGRpcmVjdGlvbj1cXFwiXFxcIj5cIixcblx0XHRcdFwibWVudTpjb250ZXh0XCI6IFwibWVudVt0eXBlPWNvbnRleHRdPlwiLFxuXHRcdFx0XCJtZW51OmNcIjogXCJtZW51OmNvbnRleHRcIixcblx0XHRcdFwibWVudTp0b29sYmFyXCI6IFwibWVudVt0eXBlPXRvb2xiYXJdPlwiLFxuXHRcdFx0XCJtZW51OnRcIjogXCJtZW51OnRvb2xiYXJcIixcblx0XHRcdFwidmlkZW9cIjogXCI8dmlkZW8gc3JjPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJhdWRpb1wiOiBcIjxhdWRpbyBzcmM9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImh0bWw6eG1sXCI6IFwiPGh0bWwgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcXFwiPlwiLFxuXHRcdFx0XCJrZXlnZW5cIjogXCI8a2V5Z2VuLz5cIixcblx0XHRcdFwiY29tbWFuZFwiOiBcIjxjb21tYW5kLz5cIixcblx0XHRcdFwiYnV0dG9uOnN1Ym1pdFwiIDogXCJidXR0b25bdHlwZT1zdWJtaXRdXCIsXG5cdFx0XHRcImJ1dHRvbjpzXCIgOiBcImJ1dHRvblt0eXBlPXN1Ym1pdF1cIixcblx0XHRcdFwiYnV0dG9uOnJlc2V0XCIgOiBcImJ1dHRvblt0eXBlPXJlc2V0XVwiLFxuXHRcdFx0XCJidXR0b246clwiIDogXCJidXR0b25bdHlwZT1yZXNldF1cIixcblx0XHRcdFwiYnV0dG9uOmRpc2FibGVkXCIgOiBcImJ1dHRvbltkaXNhYmxlZF1cIixcblx0XHRcdFwiYnV0dG9uOmRcIiA6IFwiYnV0dG9uW2Rpc2FibGVkXVwiLFxuXHRcdFx0XCJmaWVsZHNldDpkaXNhYmxlZFwiIDogXCJmaWVsZHNldFtkaXNhYmxlZF1cIixcblx0XHRcdFwiZmllbGRzZXQ6ZFwiIDogXCJmaWVsZHNldFtkaXNhYmxlZF1cIixcblx0XHRcdFxuXHRcdFx0XCJicVwiOiBcImJsb2NrcXVvdGVcIixcblx0XHRcdFwiYWNyXCI6IFwiYWNyb255bVwiLFxuXHRcdFx0XCJmaWdcIjogXCJmaWd1cmVcIixcblx0XHRcdFwiZmlnY1wiOiBcImZpZ2NhcHRpb25cIixcblx0XHRcdFwiaWZyXCI6IFwiaWZyYW1lXCIsXG5cdFx0XHRcImVtYlwiOiBcImVtYmVkXCIsXG5cdFx0XHRcIm9ialwiOiBcIm9iamVjdFwiLFxuXHRcdFx0XCJzcmNcIjogXCJzb3VyY2VcIixcblx0XHRcdFwiY2FwXCI6IFwiY2FwdGlvblwiLFxuXHRcdFx0XCJjb2xnXCI6IFwiY29sZ3JvdXBcIixcblx0XHRcdFwiZnN0XCI6IFwiZmllbGRzZXRcIixcblx0XHRcdFwiZnN0OmRcIjogXCJmaWVsZHNldFtkaXNhYmxlZF1cIixcblx0XHRcdFwiYnRuXCI6IFwiYnV0dG9uXCIsXG5cdFx0XHRcImJ0bjpiXCI6IFwiYnV0dG9uW3R5cGU9YnV0dG9uXVwiLFxuXHRcdFx0XCJidG46clwiOiBcImJ1dHRvblt0eXBlPXJlc2V0XVwiLFxuXHRcdFx0XCJidG46c1wiOiBcImJ1dHRvblt0eXBlPXN1Ym1pdF1cIixcblx0XHRcdFwiYnRuOmRcIjogXCJidXR0b25bZGlzYWJsZWRdXCIsXG5cdFx0XHRcIm9wdGdcIjogXCJvcHRncm91cFwiLFxuXHRcdFx0XCJvcHRcIjogXCJvcHRpb25cIixcblx0XHRcdFwidGFyZWFcIjogXCJ0ZXh0YXJlYVwiLFxuXHRcdFx0XCJsZWdcIjogXCJsZWdlbmRcIixcblx0XHRcdFwic2VjdFwiOiBcInNlY3Rpb25cIixcblx0XHRcdFwiYXJ0XCI6IFwiYXJ0aWNsZVwiLFxuXHRcdFx0XCJoZHJcIjogXCJoZWFkZXJcIixcblx0XHRcdFwiZnRyXCI6IFwiZm9vdGVyXCIsXG5cdFx0XHRcImFkclwiOiBcImFkZHJlc3NcIixcblx0XHRcdFwiZGxnXCI6IFwiZGlhbG9nXCIsXG5cdFx0XHRcInN0clwiOiBcInN0cm9uZ1wiLFxuXHRcdFx0XCJwcm9nXCI6IFwicHJvZ3Jlc3NcIixcblx0XHRcdFwiZnNldFwiOiBcImZpZWxkc2V0XCIsXG5cdFx0XHRcImZzZXQ6ZFwiOiBcImZpZWxkc2V0W2Rpc2FibGVkXVwiLFxuXHRcdFx0XCJkYXRhZ1wiOiBcImRhdGFncmlkXCIsXG5cdFx0XHRcImRhdGFsXCI6IFwiZGF0YWxpc3RcIixcblx0XHRcdFwia2dcIjogXCJrZXlnZW5cIixcblx0XHRcdFwib3V0XCI6IFwib3V0cHV0XCIsXG5cdFx0XHRcImRldFwiOiBcImRldGFpbHNcIixcblx0XHRcdFwiY21kXCI6IFwiY29tbWFuZFwiLFxuXHRcdFx0XCJkb2NcIjogXCJodG1sPihoZWFkPm1ldGFbY2hhcnNldD1VVEYtOF0rdGl0bGV7JHsxOkRvY3VtZW50fX0pK2JvZHlcIixcblx0XHRcdFwiZG9jNFwiOiBcImh0bWw+KGhlYWQ+bWV0YVtodHRwLWVxdWl2PVxcXCJDb250ZW50LVR5cGVcXFwiIGNvbnRlbnQ9XFxcInRleHQvaHRtbDtjaGFyc2V0PSR7Y2hhcnNldH1cXFwiXSt0aXRsZXskezE6RG9jdW1lbnR9fSkrYm9keVwiLFxuXG5cdFx0XHRcImh0bWw6NHRcIjogIFwiISEhNHQrZG9jNFtsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6NHNcIjogIFwiISEhNHMrZG9jNFtsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6eHRcIjogIFwiISEheHQrZG9jNFt4bWxucz1odHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIHhtbDpsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6eHNcIjogIFwiISEheHMrZG9jNFt4bWxucz1odHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIHhtbDpsYW5nPSR7bGFuZ31dXCIsXG5cdFx0XHRcImh0bWw6eHhzXCI6IFwiISEheHhzK2RvYzRbeG1sbnM9aHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCB4bWw6bGFuZz0ke2xhbmd9XVwiLFxuXHRcdFx0XCJodG1sOjVcIjogICBcIiEhIStkb2NbbGFuZz0ke2xhbmd9XVwiLFxuXHRcdFx0XG5cdFx0XHRcIm9sK1wiOiBcIm9sPmxpXCIsXG5cdFx0XHRcInVsK1wiOiBcInVsPmxpXCIsXG5cdFx0XHRcImRsK1wiOiBcImRsPmR0K2RkXCIsXG5cdFx0XHRcIm1hcCtcIjogXCJtYXA+YXJlYVwiLFxuXHRcdFx0XCJ0YWJsZStcIjogXCJ0YWJsZT50cj50ZFwiLFxuXHRcdFx0XCJjb2xncm91cCtcIjogXCJjb2xncm91cD5jb2xcIixcblx0XHRcdFwiY29sZytcIjogXCJjb2xncm91cD5jb2xcIixcblx0XHRcdFwidHIrXCI6IFwidHI+dGRcIixcblx0XHRcdFwic2VsZWN0K1wiOiBcInNlbGVjdD5vcHRpb25cIixcblx0XHRcdFwib3B0Z3JvdXArXCI6IFwib3B0Z3JvdXA+b3B0aW9uXCIsXG5cdFx0XHRcIm9wdGcrXCI6IFwib3B0Z3JvdXA+b3B0aW9uXCJcblx0XHR9XG5cdH0sXG5cdFxuXHRcInhtbFwiOiB7XG5cdFx0XCJleHRlbmRzXCI6IFwiaHRtbFwiLFxuXHRcdFwicHJvZmlsZVwiOiBcInhtbFwiLFxuXHRcdFwiZmlsdGVyc1wiOiBcImh0bWxcIlxuXHR9LFxuXHRcblx0XCJ4c2xcIjoge1xuXHRcdFwiZXh0ZW5kc1wiOiBcImh0bWxcIixcblx0XHRcInByb2ZpbGVcIjogXCJ4bWxcIixcblx0XHRcImZpbHRlcnNcIjogXCJodG1sLCB4c2xcIixcblx0XHRcImFiYnJldmlhdGlvbnNcIjoge1xuXHRcdFx0XCJ0bVwiOiBcIjx4c2w6dGVtcGxhdGUgbWF0Y2g9XFxcIlxcXCIgbW9kZT1cXFwiXFxcIj5cIixcblx0XHRcdFwidG1hdGNoXCI6IFwidG1cIixcblx0XHRcdFwidG5cIjogXCI8eHNsOnRlbXBsYXRlIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInRuYW1lXCI6IFwidG5cIixcblx0XHRcdFwiY2FsbFwiOiBcIjx4c2w6Y2FsbC10ZW1wbGF0ZSBuYW1lPVxcXCJcXFwiLz5cIixcblx0XHRcdFwiYXBcIjogXCI8eHNsOmFwcGx5LXRlbXBsYXRlcyBzZWxlY3Q9XFxcIlxcXCIgbW9kZT1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcImFwaVwiOiBcIjx4c2w6YXBwbHktaW1wb3J0cy8+XCIsXG5cdFx0XHRcImltcFwiOiBcIjx4c2w6aW1wb3J0IGhyZWY9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJpbmNcIjogXCI8eHNsOmluY2x1ZGUgaHJlZj1cXFwiXFxcIi8+XCIsXG5cblx0XHRcdFwiY2hcIjogXCI8eHNsOmNob29zZT5cIixcblx0XHRcdFwieHNsOndoZW5cIjogXCI8eHNsOndoZW4gdGVzdD1cXFwiXFxcIj5cIixcblx0XHRcdFwid2hcIjogXCJ4c2w6d2hlblwiLFxuXHRcdFx0XCJvdFwiOiBcIjx4c2w6b3RoZXJ3aXNlPlwiLFxuXHRcdFx0XCJpZlwiOiBcIjx4c2w6aWYgdGVzdD1cXFwiXFxcIj5cIixcblxuXHRcdFx0XCJwYXJcIjogXCI8eHNsOnBhcmFtIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcInBhcmVcIjogXCI8eHNsOnBhcmFtIG5hbWU9XFxcIlxcXCIgc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwidmFyXCI6IFwiPHhzbDp2YXJpYWJsZSBuYW1lPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJ2YXJlXCI6IFwiPHhzbDp2YXJpYWJsZSBuYW1lPVxcXCJcXFwiIHNlbGVjdD1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcIndwXCI6IFwiPHhzbDp3aXRoLXBhcmFtIG5hbWU9XFxcIlxcXCIgc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwia2V5XCI6IFwiPHhzbDprZXkgbmFtZT1cXFwiXFxcIiBtYXRjaD1cXFwiXFxcIiB1c2U9XFxcIlxcXCIvPlwiLFxuXG5cdFx0XHRcImVsZW1cIjogXCI8eHNsOmVsZW1lbnQgbmFtZT1cXFwiXFxcIj5cIixcblx0XHRcdFwiYXR0clwiOiBcIjx4c2w6YXR0cmlidXRlIG5hbWU9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImF0dHJzXCI6IFwiPHhzbDphdHRyaWJ1dGUtc2V0IG5hbWU9XFxcIlxcXCI+XCIsXG5cblx0XHRcdFwiY3BcIjogXCI8eHNsOmNvcHkgc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwiY29cIjogXCI8eHNsOmNvcHktb2Ygc2VsZWN0PVxcXCJcXFwiLz5cIixcblx0XHRcdFwidmFsXCI6IFwiPHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XFxcIlxcXCIvPlwiLFxuXHRcdFx0XCJlYWNoXCI6IFwiPHhzbDpmb3ItZWFjaCBzZWxlY3Q9XFxcIlxcXCI+XCIsXG5cdFx0XHRcImZvclwiOiBcImVhY2hcIixcblx0XHRcdFwidGV4XCI6IFwiPHhzbDp0ZXh0PjwveHNsOnRleHQ+XCIsXG5cblx0XHRcdFwiY29tXCI6IFwiPHhzbDpjb21tZW50PlwiLFxuXHRcdFx0XCJtc2dcIjogXCI8eHNsOm1lc3NhZ2UgdGVybWluYXRlPVxcXCJub1xcXCI+XCIsXG5cdFx0XHRcImZhbGxcIjogXCI8eHNsOmZhbGxiYWNrPlwiLFxuXHRcdFx0XCJudW1cIjogXCI8eHNsOm51bWJlciB2YWx1ZT1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcIm5hbVwiOiBcIjxuYW1lc3BhY2UtYWxpYXMgc3R5bGVzaGVldC1wcmVmaXg9XFxcIlxcXCIgcmVzdWx0LXByZWZpeD1cXFwiXFxcIi8+XCIsXG5cdFx0XHRcInByZXNcIjogXCI8eHNsOnByZXNlcnZlLXNwYWNlIGVsZW1lbnRzPVxcXCJcXFwiLz5cIixcblx0XHRcdFwic3RyaXBcIjogXCI8eHNsOnN0cmlwLXNwYWNlIGVsZW1lbnRzPVxcXCJcXFwiLz5cIixcblx0XHRcdFwicHJvY1wiOiBcIjx4c2w6cHJvY2Vzc2luZy1pbnN0cnVjdGlvbiBuYW1lPVxcXCJcXFwiPlwiLFxuXHRcdFx0XCJzb3J0XCI6IFwiPHhzbDpzb3J0IHNlbGVjdD1cXFwiXFxcIiBvcmRlcj1cXFwiXFxcIi8+XCIsXG5cblx0XHRcdFwiY2hvb3NlK1wiOiBcInhzbDpjaG9vc2U+eHNsOndoZW4reHNsOm90aGVyd2lzZVwiLFxuXHRcdFx0XCJ4c2xcIjogXCIhISEreHNsOnN0eWxlc2hlZXRbdmVyc2lvbj0xLjAgeG1sbnM6eHNsPWh0dHA6Ly93d3cudzMub3JnLzE5OTkvWFNML1RyYW5zZm9ybV0+e1xcbnx9XCJcblx0XHR9LCBcblx0XHRcInNuaXBwZXRzXCI6IHtcblx0XHRcdFwiISEhXCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz5cIlxuXHRcdH1cblx0fSxcblx0XG5cdFwiaGFtbFwiOiB7XG5cdFx0XCJmaWx0ZXJzXCI6IFwiaGFtbFwiLFxuXHRcdFwiZXh0ZW5kc1wiOiBcImh0bWxcIixcblx0XHRcInByb2ZpbGVcIjogXCJ4bWxcIlxuXHR9LFxuXHRcblx0XCJzY3NzXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJjc3NcIlxuXHR9LFxuXHRcblx0XCJzYXNzXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJjc3NcIlxuXHR9LFxuXHRcblx0XCJsZXNzXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJjc3NcIlxuXHR9LFxuXHRcblx0XCJzdHlsdXNcIjoge1xuXHRcdFwiZXh0ZW5kc1wiOiBcImNzc1wiXG5cdH0sXG5cblx0XCJzdHlsXCI6IHtcblx0XHRcImV4dGVuZHNcIjogXCJzdHlsdXNcIlxuXHR9XG59XG47XG52YXIgcmVzID0gcmVxdWlyZSgncmVzb3VyY2VzJyk7XG52YXIgdXNlckRhdGEgPSByZXMuZ2V0Vm9jYWJ1bGFyeSgndXNlcicpIHx8IHt9O1xucmVzLnNldFZvY2FidWxhcnkocmVxdWlyZSgndXRpbHMnKS5kZWVwTWVyZ2UodXNlckRhdGEsIHNuaXBwZXRzKSwgJ3VzZXInKTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlMi1hY2UtZWRpdG9yL25vZGVfbW9kdWxlcy9lbW1ldC9lbW1ldC5qc1xuLy8gbW9kdWxlIGlkID0gNDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///475\n");

/***/ })

});